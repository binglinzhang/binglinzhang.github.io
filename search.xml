<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端安全]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[常见的前端安全问题有XSS、CSRF、cookies、点击劫持、SQL注入、流量攻击等，以下简单的记录学习过程中的笔记与要点。 一、XSSxss跨站攻击类型有：反射型：URL参数直接注入(可通过短网址等方式进行url转换，从而更加隐秘)存储型：存储数据到DB时读取注入，危害更大 xss攻击注入点：1、html节点内容(即利用了innerHTML插入执行的脚本)2、html属性(利用src属性，或者图片的onerror属性)3、javascript代码4、富文本的本质就是一段复杂的html代码，这样才得以保留富文本的格式。当富文本保存到DB时保存的即该html代码。当存在html时会存在xss攻击风险。 防御措施：1、浏览器自带防御(针对反射型，且只能防御html节点内容及属性，针对JavaScript代码无法防御) 2、针对html节点内容，转义&lt;&gt;1234let escapeHtml = function(str) &#123; str = str.replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;') return str&#125; 3、针对html属性，转义””1234567let escapeHtmlProperty = function(str) &#123;if(!str) return ''str = str.replace(/"/g,'&amp;quto;')str = str.replace(/'/g,'&amp;#39;')str = str.replace(/ /g,'&amp;#32;')return str&#125; 以上两个函数合并成一个：123456789let escapeHtml = function(str) &#123; if(!str) return '' str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g,'&amp;quto;') str = str.replace(/'/g,'&amp;#39;') //str = str.replace(/ /g,'&amp;#32;') 按html标准书写代码，该处可以不对空格进行转义 return str&#125; 4、针对js的转义(注意html转义与js代码转义不一样)123456let escapeForjs = function(str) &#123; if(!str) return '' str = str.replace(/\\/g,'\\\\') str = str.replace(/"/g,'\\"') return str&#125; 上面的转义函数可以防御大部分js代码注入，但还不是很安全，最保险的方式是直接将用户输入的代码用JSON.stringify格式化，再原封返回即可。 5、富文本的输入一般在输入数据库之前进行过滤5.1、黑名单过滤的方式(比较繁琐)1234567let xssFilter = function(html) &#123; if(!html) return '' html = html.replace(/&lt;\s*\/?script\s*&gt;/g,'') html.replace(/javascript:[^'"]*/g,'') ... return html&#125; 5.2、白名单过滤的方式(只保留部分标签与属性，比较保险)介绍一个cheerio库进行解析dom还可以直接利用第三方库–js-xss6、CSP(content-security-policy设置，可查看MDN) 二、CSRFCSRF跨站请求伪造原理：1.用户登录A网站2.A网站确认身份信息3.B网站页面向A网站发起请求(带A网站身份信息)…特征：B网站向A网站发起请求带A网站的cookies不访问A网站的前端referer指向B网站…危害：利用了用户登录态用户不知情完成业务请求防御：1.在服务器返回的cookies中将samesite属性设置为strict，这样只有同域网站才能获取到cookies(但是该属性目前只有在谷歌浏览器中支持)2.向服务器提交信息的时候需要前端A网站的验证信息，比如验证码，token等(nodejs中ccp插件用于提供图形验证码)3.利用前后端匹配token值(前端可以通过在input输入框中隐藏直接提交或者通过将token值保存到meta标签中)，从而判断是否来自正规的A网站的请求4.验证referer，禁止第三方网站请求1/^https?:\/\/localhost/.test(request.header.referer) 三、cookies特性1、只能使用自己域名下的cookies2、有效期3、设置URL上的层级有效4、http-only只允许请求或者接受的时候读取，不允许document.cookie读取5、secure只允许在https中获取6、sameSite7、删除的方式只能通过设置有效期为过去式cookies作用1.存储个性化设置2.存储未登录时用户的唯一标识3.存储已经登录的用户凭证4.存储其他业务数据cookies-登录用户凭证的使用方式：1.用户ID + 后台签名(服务器通过sha2等方式对用户ID进行算法加密之后连着用户ID及签名字符串一块通过cookies返回到前端，当前端提交请求时将该cookies一并提交，后台再计算用户ID进行校验)2.sessionId(用户初次登录成功的时候服务器根据用户ID匹配生成一个sessionId返回给到前端cookies中，之后前端每次请求将带着该sessionId与后台服务器缓存或者数据库中进行匹配获取到对应的用户信息)cookis的安全策略有：1.使用签名防止篡改2.对用户ID进行加密(避免明文显示)3.设置http-only(防止XSS盗用cookies)4.设置secure(只允许https获取cookies)5.设置same-site(防止CSRF利用用户的登录态) 四、点击劫持用户不知情情况下亲手点击(将实际真实的A网站通过iframe嵌入到B网站中，并设置opacity为0，在用户看不到的情况下诱导用户点击B网站上的信息，实则已点击了透明的A网站)防御方法：1.通过JavaScript脚本禁止内嵌(通过判断top.location == window.location)2.X-FRAME-OPTIONS禁止内嵌(通过在相应头header中设置X-Frame-Options属性值为DENY即可禁止该网站被内嵌)，该方法各浏览器兼容很好，推荐使用 五、httpshttp传输窃听篡改(traceroute/window下tracert可以查看网站访问背后的链路节点(各种代理转发)，任何一个节点都可以查看http的明文内容)https原理在浏览器端用SSL(也叫TLS)进行加密之后在链路节点间用密文传输，到达服务器之后再按规则进行明文转换 六、密码-哈希算法1.明文-密文 == 一一对应2.雪崩效应，只要明文有一个差异，整个密文都会不一样3.密文-明文无法反推4.密文固定长度常用的哈希算法：md5、sha1、sha256等单向变换可以通过彩虹表(彩虹表罗列多种密码组合，然后通过查询密文获取对应的明文)进行查询，如果要对抗彩虹表防止密码轻易在彩虹表中被查询到，可以增加密码长度及复杂度，甚至通过多重md5加密，如md5(md5(codecodecode…))，md5(sha1(codecodecode…))等帮用户密码加盐 七、SQL注入防御1.关闭错误输出2.入参时检查数据类型3.对入参数据进行转义4.使用参数化查询(更有保障)5.使用ORM(对象关系映射) 八、流量攻击服务器大规模流量攻击(很难防御)1.TCP半连接2.Http连接3.DNS(解析域名服务器)4.大规模DDOS攻击防御1.防火墙2.交换机、路由器3.流量清洗4.高防IP(云服务厂商重指向到高防IP进行流量清洗)预防1.避免重逻辑业务2.快速失败快速返回3.防雪崩机制4.有损服务5.CDN(静态请求,减轻服务器压力) 九、总结1.简述XSS原理来自用户输入的数据被当做脚本程序被执行，主要包括2.简述XSS防御方法浏览器内置方法对数据进行适当转义&lt;&gt;”‘&amp;对富文本设置白名单CSP指定哪些内容可以被执行哪些不被执行3.XSS防御需要注意的点转义的时候需要注意使用的场景与范围4.CSRF的原理盗用用户登录态，携带cookies对目标网站发起请求5.CSRF危害在用户不知情情况下盗用用户身份6.如何防御same-site规定只允许指定网站访问带验证码或token判断referer7.cookies的作用浏览器存储数据，用户个性化设置、登录标识、身份识别8.cookies与localStorage最大区别是cookies在范围网站时可以自动携带，而storage不可以9.cookies与session关系：服务端产生sessionId通过cookies存在到浏览器中10.cookies具有：无法跨域、存在path层级、有效期、http-only无法通过js读取、secure、same-site等特性，cookies只能通过设置过期时间才能进行删除]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的2种跨域请求方式]]></title>
    <url>%2F2017%2F06%2F10%2Fjsonp%E7%9A%842%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JSON和JSONP虽然只有一个字母的差别，但其实两者根本不是一回事：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。本文主要介绍下常用的jsonp跨域请求方式传输JSON格式数据以及jsonp与ajax的区别。 先解释下JSONP的由来： 1、因为浏览器的安全机制，只要请求资源与当前页面地址的域名或端口号不一致，那么ajax发送的数据请求皆会存在跨域无权限访问的问题，不管是静态页面、动态网页、web服务资源，都访问不了。 2、我们都知道凡带有”src”属性的标签都拥有跨域的能力，常见的标签如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;，加上Web页面上只要能获取js脚本文件即可调用或执行，不受跨域影响。 3、于是，推演出了一种称作JSONP的非正式传输协议，该协议的要点就是允许用户传递一个callback参数给服务端，然后服务端通过该callback参数作为函数名包装JSON数据，然后返回数据给到客户端，客户端提供一个自定义回调函数进行数据处理。 4、这种获取远程数据的方式看起来很像ajax，但ajax和jsonp两者本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签调用服务器提供的js脚本。ajax与jsonp的区别并不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。所以两者最大的区别还是在于获取服务器数据的行为方式上的不一样。 基于以上几点，本文介绍jsonp跨域发送数据请求常用的2种方法，虽然写法上不同，但实质上都是一致的，只是jq在ajax中对其进行了封装，但注意ajax与jsonp没有实质关系。 本文以百度搜索提供的一个支持JSONP请求的API接口进行发送请求，地址为：http://suggestion.baidu.com/su?wd=#content#&amp;cb=callback (#content#为搜索关键词) 一、原生js实现12345678910111213141516171819// 定义一个数组，发送多次请求 let arr = ['苹果', 'apple', 'fruit', '我爱苹果'], headEle = document.querySelector('head'), resultArr = [] arr.forEach(val =&gt; &#123; let scriptEle = document.createElement('script') let url = `http://suggestion.baidu.com/su?wd=$&#123;val&#125;&amp;cb=callback` // ES6的反引号写法 // 注意！上面的`cb`为百度定义的格式，不可以更改！！！ scriptEle.src = encodeURI(url) // encodeURI为js原生的中文url编码方法 headEle.appendChild(scriptEle) headEle.removeChild(headEle.querySelector('script')) // 先添加再移除 &#125;) function callback(data) &#123; // 回调函数调用接受响应数据 resultArr.push(data.s) // 's'属性是返回json数据中的属性 if (resultArr.length === arr.length) console.log(resultArr) // 输出包含4个数组元素的一个数组 &#125; 二、使用JQuery封装实现12345678910111213141516171819202122&lt;script src='http://code.jquery.com/jquery-latest.js'&gt;&lt;/script&gt; let arr = ['苹果', 'apple', 'fruit', '我爱苹果'], resultArr = [] arr.forEach(val =&gt; &#123; let url = `http://suggestion.baidu.com/su?wd=$&#123;val&#125;` $.ajax(&#123; type: 'get', url: encodeURI(url), // 指定此请求为jsonp请求，响应返回的数据格式即为jsonp格式 dataType: 'jsonp', jsonp: 'cb', success: function(data) &#123; resultArr.push(data.s) if (resultArr.length === arr.length) console.log(resultArr) &#125;, error: function(err) &#123; console.log(err) &#125; &#125;) &#125;) 注意点： json格式的数据结构长这样: {‘a’:’apple’,’b’:’banana’}，而jsonp格式的数据结构长这样: callback({‘a’:’apple’,’b’:’banana’})，由上面的定义知道，发送jsonp请求需要服务器返回一个callback参数作为函数名包装的JSON数据，所以如果服务器没有设定允许返回jsonp格式的数据，那么我们是无法完成jsonp跨域请求的，哪怕强制在url地址上加了”&amp;callback=handleCallbackFunction”,服务器返回的数据还是json数据，无法被客户端定义的回调函数获取，下面这个url地址就无法进行jsonp请求，有兴趣的可以将上面代码中的url换成这个试一试。替换url：1`http://api.tmkoo.com/search.php?keyword=$&#123;val&#125;&amp;apiKey=4399320012393234&amp;apiPassword=331nd3342d&amp;pageSize=30&amp;pageNo=1` 解决方案由后端发起http跨域请求，以nodejs为例，引入request模块，关键代码如下：1234567891011121314const express = require('express')const request = require('request')const app = express()let url = `http://api.tmkoo.com/search.php?keyword=$&#123;val&#125;&amp;apiKey=4399320012393234&amp;apiPassword=331nd3342d&amp;pageSize=30&amp;pageNo=1`request(encodeURI(url), (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body) //body中即可获得返回的json数据 &#125;&#125;)app.listen(8888, () =&gt; &#123; console.log('started...')&#125;)]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回到原点]]></title>
    <url>%2F2017%2F06%2F07%2F%E5%9B%9E%E5%88%B0%E5%8E%9F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[今天全国高考，回想2011年我的高考作文命题——回到原点，思绪有些复杂。今天我再一次高考，交上这篇800字文章，谨记过往，不忘原点，从心出发。 2011年6月7号早上9点01分，我拿到语文卷的命题作文——回到原点。跟大多数人一样，夹杂着紧张与惊喜，我当时脑子里的第一反应就是诸如“最初的梦想”，“不忘初心，砥砺前行”，“又回到最初的起点，记忆中你青涩的脸…”这样的关键词，其实这跟“回到原点”还是有些差别。 回到原点，其实讲的是田径场上一圈下来由起点回到原点的意思，放远点讲就是一个由土生向尘亡的轮回归属。古希腊赫拉克利特说，“一双脚永远不可能踏进同一条河流”，因为时间会韶逝，空间会易转，你永远也找不到两片同样的树叶。花开复花落，潮涨既潮退，云卷亦云舒。一个圆规画圆，两只脚由始再到原，转到的那个原点永远不会是同一个点，那我们为什么还要回到原点？ 回想一下，我们是否经常耳荡“如果让我再年轻十年”,“如果再给我一个大学”，“如果再给我一个机会”…种种如果，皆为原点，皆为重塑。我们常说梦想还是要有的，万一实现了，可梦想何来？真的是某天白日做梦想想就来，还是跋山涉水之后醍醐灌顶，东风自然来？没错，回到原点，就是要重新审视最初的梦想与现实历经之间的矛盾，也是重整旗鼓韬光养晦的契约。一次踏进冰河并不可怕，但如果两次三次踏进“同一条”河流，那么这个原点将越描越黑。 回到原点，其实就是在面对各种洗礼之后重新面临选择。生命之流汩汩，总有九十九式的桥需要去回眸，有青葱绿石的，有古典端庄的，有陆离斑驳的…走一遭，到东吴，择一桥，回西蜀。不管择与否，主动的随流的，浪淘尽之后，回归原点，还得再次选择。当然，只要有选择总是有机会成本的，成本公式就是πr²。走的时间越远路子越长，圆饼就越大，当再次回到圆点面临选择时，能易志甚至舍弃的代价就越高。所以生命洪流，需要时时省思脚下船，船到桥头虽直，可怕一条暗道直流到黑，适时需要登桥眺望，择善流行。 2017年2月6号，依昔记得是大年初八，一个背包的独行客，走到起点般的原点。昨日6月6号，刚好满四月。四个月的朝七晚九，四个月的独往孤来，四个月的点滴获取，四个月的日行一小时，满满当当。如今重赴原点，从心出发。 好了，匆匆一瞥，已然神游，开卷啦，原点常在，期待大家都能给各自生活交上一份满意的答卷。 林龙儿2017/06/07•广州]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2 开发"饿了么"项目的一些总结]]></title>
    <url>%2F2017%2F06%2F01%2Fvue2%E5%BC%80%E5%8F%91%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近一段时间探索着运用vue2开发一个饿了么的开源项目，纵观网上大部分资料只介绍了前端单页面的开发过程，并没有涉及到后端及数据库部分。本项目以前端SPA的开发为主，并针对前端到后端服务器的逻辑层进行编写。css部分直接引用了网上开源的代码，未重点关注。本文记录开发过程中踩过的坑以及一些注意点，供大家参考。 本项目开发过程中使用到的技术栈 vue-cli + vue-router + axios + vue2 + vuex + Express + MongoDB + mongoose + webpack2 + ES6 使用vue-cli脚手架快速搭建项目结构通过vue自带的vue-cli工具，可以快速的创建一个项目结构，我们只需在src中进行源码编写即可，其他大部分工作cli工具都已经帮我们生成。本项目的目录结构说明如下： 使用vue-router实现SPAvue-router的基本思想是在主页面中引入标签，然后定义路由，通过&lt;router-link&gt;&lt;/router-link&gt;把router挂在到app上，并把各个子页面渲染到&lt;router-view&gt;&lt;/router-view&gt;里面。通过vue-router创建一个实例对象并进行路径配置，即可轻易实现前端路由的切换，本项目主要实现在一个单页面上进行3个子页面间的切换动作，图示红色区域即为典型的单页面路由功能。 使用axios进行后台数据请求运用axios插件的优势在于支持ES6的Promise特性，通过.then() .catch()的方式很方便的对响应结果进行处理。在引入axios的时候需要注意一点，要么可以直接将axios挂载到全局Vue的prototype原型链上，这样所有的vue实例均可直接通过this.$axios.get()…调用，要么通过import方法在需要使用axios的地方引入，然后直接axios.get()…调用，但注意这里并不需要加上vue.use(axios)，因为axios就是一个纯粹的第三方插件，引入之后即可直接使用。axios的使用方法如下：123456this.$axios.get('/api/seller').then(res =&gt; &#123; //this.$axios的用法前提是将axios挂载到Vue的原型上，否则需要使用import引入axios的方法 this.seller = JSON.parse(JSON.stringify(res.data)) &#125;).catch(err =&gt; &#123; console.log(err) &#125;) 另外还需要注意一点，这里因为涉及到前后端服务器不同端口号的跨域请求问题，需要在vue-cli生成的目录中找到config文件夹下的index.js文件，在proxyTable属性中添加上如下代码，从而在本地重新启动一个新的服务器进行代理。12345678910proxyTable: &#123; //配置跨域请求参数 '/api': &#123; target: 'http://localhost:3000/', //本地'localhost:8080/api'的地址将被代理为'http://localhost:3000/' changeOrigin: true, pathRewrite: &#123; '/api': '' // '/api'将被替换为''(空) &#125; &#125; &#125; 基于vue2搭建前端架构Vue.set()开发商品数量模块的时候，使用了一个Vue.set()或者vm.$set()方法，该方法可响应式的给对象添加一个属性，并触发view视图更新。如果只是简单的使用 Object.assign() 或 extend() 添加属性,无法响应视图更新。在该模块中通过给一个商品动态附上一个数量属性还有一个明显的优势，就是该属性在任意的父组件或子组件间进行值的更改之后，其他的引用组件都会响应更改，”一动而牵全身”，因为他们引用的是同一片内存地址。本项目中共有3个地方引用到该属性，分别是商品显示页、商品详情页、购物车详情页。12345678addCart(event) &#123; if (!this.food.count) &#123; Vue.set(this.food, 'count', 1) //强制赋予food一个新的属性，并监听该数据 &#125; else &#123; this.food.count++ &#125;&#125; better-scroll项目中要实现移动端滑动，所以引入了一个”better-scroll”插件，该插件虽然简单的几个配置之后即可达到滑动效果，但是它的创建时机相当重要，因为它的创建需要依据滚动元素的css布局进行计算，所以如果在数据尚未取得并渲染之后创建，最终将得不到滑动效果。基于这一点，推荐结合vue提供的nextTick()方法(nextTick是vue中一个类似setTimeout的方法)，在下一次DOM更新之后进行计算，并且在每次数据更新(DOM结构树发生变动)之后调用refresh()方法重计算，必要时可通过watch属性监听变动数据实时refresh，否则将会出现滚动误差。该插件的引入一般在mounted钩子函数中引入,但是如果是通过axios发送请求，因为请求是异步的，需要等待服务器响应，所以可能会出现数据尚未回来，但mounted已挂载的情况，所以这时候该插件的引入就需要放在axios的回调函数中去执行了。123456789mounted() &#123; this.$nextTick(() =&gt; &#123; //nextTick方法相当于setTimeout定时器，用于处理异步回调问题 this.scroll = new BScroll(this.$refs.ratings, &#123; click: true, bounceTime: 300 &#125;) &#125;)&#125; 子组件的多重引用在设置子组件的时候，需要给子组件绑定多少个变量，多少个方法，这是个宏观问题。可能这个地方引用需要2个变量，另一个地方引用该组件需要4个变量，同时2个地方的引用需要的方法也各不同，那这时候就要考虑该组件的可复用性，重新进行变量和方法设定，或者尽可能减少变量和方法数量的绑定，提高可复用性。这一点在我重写评价筛选方法的时候代码的冗长，难以复用性，就是个很大的坑。 vuex数据统一访问接口在项目中多个地方引用了这行数据classMap: [&#39;decrease&#39;, &#39;discount&#39;, &#39;special&#39;, &#39;invoice&#39;, &#39;guarantee&#39;]，会出现的很大问题是，如果项目中需要对该数据进行增删，那每一个引用的地方都要相应找出来并进行修改，当引用的数量多了之后，那就麻烦大了。好在vue中有一个vuex插件，有个state”中间仓库”概念，它负责保存关键的数据状态，所有的组件只可mapGetter到这个数据并在mutations中操作数据，不可能直接更改，这样如果需要改动数据，只要改动state中的数据，其他引用的组件将跟着发生改变。本项目中将该组数据单独放在state中，共有3个子组件引用了该数据，子组件可通过this.$store.state.classMap方式访问到该数据。注册store的方式如下：123456789import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; classMap: ['decrease', 'discount', 'special', 'invoice', 'guarantee'] &#125;&#125;) export与importES6中export与import 有4种常用的使用方式：1、export的时候将需要导出的变量用一个{}包装起来，然后在import的时候相对应用{}引入该变量；12345let exportVar = 'have a nice day!', fooexport &#123;exportVar,foo&#125; //导出,也可以通过as将foo名字改为bar再导出import &#123;exportVar,foo&#125; from '...' //导入console.log(exportVar) 2、这种方式是直接在export后面定义要导出的函数或变量；123export let foo = () =&gt; &#123;console.log("fnFoo")&#125;, bar = "stringBar" //导出import &#123;foo, bar&#125; from "..." //导入console.log(foo()) 3、这种导出方式不需要知道变量的名字，相当于匿名，直接将开发接口给export，如果一个js模块文件只有一个功能，可以使用export default默认导出，在引入之后可以将default变量名随意更改，这也是本项目中使用最多的一种方式；12export default &#123;&#125; //导出import someName from "..." //导入 4、整体导出导入，导出文件中有多个export；12345678export function getName() &#123; //导出 console.log('name')&#125;export function getAge()&#123; //导出 console.log('age')&#125;import * as someName form '....' //导入console.log(someName.getName()) 使用Express搭建后台服务器这里主要使用node.js中比较优秀的express框架快速搭建一个服务器，释放可访问端口号及暴露的文件路径，并且提供http访问接口，express还可以使用各种中间件对请求及相应前后的数据进行中间操作，可扩展性很强大。本项目以前端为主，express只是简单提供3个请求接口，并对接数据库返回请求资源。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const express = require('express')const path = require('path')const app = express()app.get('/seller', (req, res, next) =&gt; &#123; //多个回调 console.log('访问了seller数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].seller) &#125; &#125;)&#125;)app.get('/ratings', (req, res, next) =&gt; &#123; console.log('访问了ratings数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].ratings) &#125; &#125;)&#125;)app.get('/goods', (req, res, next) =&gt; &#123; console.log('访问了goods数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].goods) &#125; &#125;)&#125;)app.set('port', process.env.PORT || 3000)app.use(express.static(path.join(__dirname, '.'))) //托管静态资源app.listen(app.get('port'), () =&gt; &#123; console.log('Express server listening on port ' + app.get('port'))&#125;) 使用MongoDB数据库储存数据使用MongoDB数据库的原因是因为饿了么开源项目提供的数据为json数据类型，可以直接导入使用，而且MongoDB非SQL型数据库具有更加灵活的操作性。 使用mongoose操作数据库mongoose是一个针对MongoDB操作的第三方插件，该插件封装了很多原生的操作指令，使得通过mongoose的操作更加简洁高效。另外项目中还通过Robomongo这个可视化的数据库GUI进行数据导入，可省去在shell窗口中敲送指令并提供更良好的数据展示。数据库的创建关键代码如下： 123456789101112const mongoose = require('mongoose')mongoose.connect('mongodb://localhost:27017/elemeDB')const schema = mongoose.Schemaconst aModel = new schema(&#123; //定义数据类型 seller: Object, goods: Array, ratings: Array&#125;)const MDL = mongoose.model('elemes', aModel) //创建或连接到指定集合// 本项目只针对数据查询，未涉及insert、update、remove等操作 使用webpack2打包项目webpack主要是在项目完成开发之后，进行的一种代码打包动作，它可以将项目主页中使用到的链接、资源等进行加载注入并进行一定的编码操作。webpack2与webpack1略微不同，webpack2最主要的有以下4个属性： entry：指入口文件的配置项，它可以是一个数组，允许有多个入口点。 如果只有一个入口的话，可以直接使用双引号”./entry.js”；output：配置打包结果，path定义输出的文件夹，filename定义打包结果文件的名称；module：定义对模块的处理逻辑，可以用loaders定义一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。plugins：这个是放置各种第三方插件的属性，使用第三方插件可以完成更多loader不能完成的功能。 本项目在确认开发基本ok之后，通过npm run build，即可完成项目打包上线。 使用ES6新语法编写代码众所周知，ES6是以后的常态化书写趋势，所以在该项目中边学边用，最常用的大概就是解决回调金字塔的Promise属性、箭头函数、反引号、const/let、属性属性值同名简写、export/import等，具体使用方法就不细写了，ES6的主要作用还是起到代码规范化同时更简洁高效的达到以前需要冗长代码才能实现的效果。ES6新特性传送门 最终效果]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Vue</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5新特性--本地dataDaseStorage的运用]]></title>
    <url>%2F2017%2F05%2F24%2FH5%E6%96%B0%E7%89%B9%E6%80%A7--%E6%9C%AC%E5%9C%B0dataDaseStorage%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于HTML5中新增的”SQLite”数据库存储方式，网上的介绍资料比较少，这种存储方式突破往常cookie临时性及存储空间限制，可以将数据永久存储在本地，并且存储空间可扩展至5~10MB，本篇以一个通讯录存储demo进行演示，同时温习下MySQL的相关语法，以供参考。 完整代码及相关注释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;HTML5 dataDaseStorage&lt;/title&gt; &lt;link rel="stylesheet" href="./bootstrap.min.css"&gt; &lt;style&gt; .middle-box &#123; display: table; width: 450px; height: 300px; border: 1px solid lightskyblue; margin: 0 auto; &#125; .middle-inner &#123; display: table-cell; vertical-align: middle; text-align: center; &#125; #list &#123; text-align: center; &#125; .table.table-bordered &#123; width: 50%; margin: 0 auto; &#125; th, td &#123; border: 2px solid green !important; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="middle-box"&gt; &lt;div class="middle-inner"&gt; &lt;form class="form-inline"&gt; &lt;h3&gt;通讯录&lt;/h3&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="userName"&gt;姓名：&lt;/label&gt; &lt;input type="text" id="userName" name="userName" class="form-control text" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="mobilephone"&gt;手机：&lt;/label&gt; &lt;input type="text" id="mobilephone" name="mobilephone" class="form-control" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="company"&gt;公司：&lt;/label&gt; &lt;input type="text" id="company" name="company" class="form-control" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;input type="button" onclick="saveMsg()" value="新增记录" class="btn btn-default btn-info" style="width: 55%;" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;div id="list"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 加载完毕后取出数据 window.onload = function() &#123; loadAll(); &#125; // 创建或打开已有数据库API var db = openDatabase('contactdb', '', 'local database describe', 204800); // 4个参数含义： // databasename: 数据库名字； // version：数据库版本号，选填； // description：数据库描述； // size：给数据库分配的空间大小； //保存数据API function saveMsg() &#123; var userName = document.getElementById("userName").value; var mobilephone = document.getElementById("mobilephone").value; var company = document.getElementById("company").value; var timestamp = parseInt(new Date().getTime()/1000); if (userName &amp;&amp; mobilephone &amp;&amp; company) &#123; db.transaction(function(tx) &#123; //contact为 table name，4个问号分别由后一个参数值替代，后2个参数为回调函数 tx.executeSql('insert into contact values(?,?,?,?)', [userName, mobilephone, company, timestamp], onSuccess, onError); &#125;); &#125; else &#123; alert('请输入完整信息！') &#125; &#125; //删除数据API function deleteMsg(phone) &#123; if (confirm('确定要删除吗？')) &#123; db.transaction(function(tx) &#123; tx.executeSql('delete from contact where phone=?', [String(phone)], onSuccess, onError); &#125;); &#125; &#125; // 两个回调 function onSuccess() &#123; alert("操作成功"); document.getElementById("userName").value = ''; document.getElementById("mobilephone").value = ''; document.getElementById("company").value = ''; loadAll(); &#125; function onError(tx, error) &#123; alert("操作失败" + error.message); &#125; //读取本地sqlLite数据API function loadAll() &#123; var list = document.getElementById("list"); db.transaction(function(tx) &#123; //如果初始数据表不存在，则创建一个空的数据表 tx.executeSql('create table if not exists contact(name text,phone text,company text,createtime INTEGER)', []); tx.executeSql('select * from contact', [], function(tx, rs) &#123; // console.log(rs); if (rs.rows.length) &#123; var tableEle = document.createElement('table'); tableEle.classList.add('table'); tableEle.classList.add('table-bordered'); tableEle.innerHTML = "&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;手机&lt;/th&gt;&lt;th&gt;公司&lt;/th&gt;&lt;th&gt;添加时间&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;"; for (var i = 0; i &lt; rs.rows.length; i++) &#123; var row = rs.rows[i]; tableEle.innerHTML += "&lt;tr&gt;&lt;td&gt;" + (i + 1) + "&lt;/td&gt;&lt;td&gt;" + row.name + "&lt;/td&gt;&lt;td&gt;" + row.phone + "&lt;/td&gt;&lt;td&gt;" + row.company + "&lt;/td&gt;&lt;td&gt;" + TimeChange(row.createtime) + "&lt;/td&gt;&lt;td&gt;&lt;input type='button' value='删除' onclick='deleteMsg(" + row.phone + ")' class='btn btn-danger'/&gt;&lt;/td&gt;&lt;/tr&gt;"; &#125; list.innerHTML = ''; list.appendChild(tableEle); &#125; else &#123; list.innerHTML = "目前通讯录为空，请添加新成员吧"; &#125; &#125;); &#125;); &#125; //根据时间戳生成时间对象 function TimeChange(value) &#123; var d = new Date(value * 1000); return (d.getFullYear()) + "-" + (d.getMonth() + 1) + "-" + (d.getDate()) + " " + (d.getHours()) + ":" + (d.getMinutes()) + ":" + (d.getSeconds()); &#125;&lt;/script&gt;&lt;/html&gt; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-Flex 弹性响应式布局的栗子]]></title>
    <url>%2F2017%2F05%2F21%2FCSS3%20Flex%E5%BC%B9%E6%80%A7%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E6%A0%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[本栗子主要记录如何运用CSS3的flex新特性进行快速的响应式布局，以及区别于以往DIV+CSS繁琐的垂直居中定位方法，通过flex方法方便快捷的实现子元素的垂直居中。 主体body布局如下： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;body&gt; &lt;header&gt;I am header&lt;/header&gt; &lt;div id='main-body'&gt; &lt;nav&gt;&lt;h3&gt;nav&lt;/h3&gt;&lt;/nav&gt; &lt;article&gt;&lt;h3&gt;article&lt;/h3&gt;&lt;/article&gt; &lt;aside&gt;&lt;h3&gt;aside&lt;/h3&gt;&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;I am footer&lt;/footer&gt;&lt;/body&gt;&lt;/head&gt;&lt;/html&gt; CSS样式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768* &#123; margin: 0; padding: 0;&#125;body &#123; font: 24px Arial; min-width: 300px;&#125;/*头尾普通布局*/header, footer &#123; display: block; height: 60px; line-height: 60px; background: lightyellow; text-align: center;&#125;/*内容区使用flex弹性布局*/#main-body &#123; display: flex; display: -webkit-flex; flex-direction: row; -webkit-flex-direction: row; min-height: calc(100vh - 120px); /*保证sticky-footer, 即让footer永远沉底不会浮起来，配合display:flex 使用*/ background: lightgrey;&#125;#main-body&gt;nav &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 1 1 20%; -webkit-flex: 1 1 20%; align-items: center; justify-content: center; background: lightskyblue;&#125;/*3个值，第1个表示窗口拉伸时的该子元素的扩展倍数，第2个表示窗口缩小时的缩小倍数，第3个表示该子元素所占父元素的比例*/#main-body&gt;article &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 2 4 55%; -webkit-flex: 2 4 55%; align-items: center; justify-content: center; background: lightgreen;&#125;#main-body&gt;aside &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 1 2 25%; -webkit-flex: 1 2 25%; align-items: center; justify-content: center; background: #CCCCFF;&#125;#main-body h3 &#123; padding: 5px 40px; border: 1px dashed #FFF;&#125;@media (max-width:768px) &#123; #main-body &#123; flex-direction: column; -webkit-flex-direction: column; &#125; #main-body&gt;article &#123; order: -1; -webkit-order: -1; &#125;&#125; 屏幕宽度大于768px时的效果：（高度保持不变） 屏幕宽度压缩小于等于768px的效果：（高度保持不变） 以下记录下几个设置要点： 1、设置display属性值为flex的元素即成为了父项，其内部包含的子元素即可使用flex属性进行弹性布局，子元素如若继续添加display: flex的属性，则该子元素也将成为其所包含的子元素的父项，以上栗子中设置子元素成为父项目的是让其包含的元素可以进行垂直居中设置。 2、以上两种效果的子元素项目的排序与html中默认的顺序相关，但可通过flex中的order属性进行切换，默认值为0，值设置的越小则更顺序靠前。 3、各个子元素的内容垂直居中效果是利用flex中justify-content 和 align-items两个属性进行调整，前者调整主轴方向上的对齐方式，后者调整交叉轴上的对齐方式，在父项上设置两个属性值均为”center”，则可以让包含的子元素垂直水平居中。 不使用flex属性的情况下实现元素垂直居中的代码，基本兼容所有浏览器： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; /*以下带*号的属性设置是为了兼容IE6、7*/ .middle-box &#123; display: table; /*关键设置*/ width: 300px; height: 200px; border: 1px solid #ff0000; margin: 0 auto; *position: relative; &#125; .middle-inner &#123; display: table-cell; /*关键设置*/ vertical-align: middle; /*关键设置*/ text-align: center; /*关键设置*/ *position: absolute; *top: 50%; *left: 50%; &#125; .middle-inner&gt;p &#123; *position: relative; *top: -50%; *left: -50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="middle-box"&gt; &lt;div class="middle-inner"&gt; &lt;p&gt; &lt;span&gt;Nice to meet YOU !&lt;/span&gt;&lt;/br&gt; &lt;span&gt;Have a nice day !&lt;/span&gt;&lt;/br&gt; &lt;span&gt;See YOU !&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果： 另外，今天学到一个实用的方法，可在不熟悉一个陌生函数的情况下，借助ES6中新增的Array.from方法，获知未知函数的参数个数及类型。顺利mark一下，代码： 1234[1,2,3].filter(function() &#123; console.log(Array.from(arguments)); &#125;)//result: [1, 0, Array(3)] [2, 1, Array(3)] [3, 2, Array(3)]]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DocumentFragment重构页面]]></title>
    <url>%2F2017%2F05%2F17%2FDocumentFragment%E9%87%8D%E6%9E%84%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Javascript里面有这样一个东西: DocumentFragment (中文翻译大概就叫”文档片段”)，很多前端攻城狮可以并不怎么常用或者了解它，它本身并不属于主DOM树的一部分，但它可以将一批子元素附加到自身，然后再将自身附加的所有子元素一次性添加到主DOM树中。这种方式不需要对一个真正的根节点进行操作，DocumentFragment附加子元素的所有操作都在浏览器内存中进行，不影响DOM树，因此将子元素插入到DocumentFragment对象中不会引起页面回流(reflow，即对元素位置和几何上的重新计算)。因此使用DocumentFragment重构页面能很大的优化性能，网上试验的结果显示比直接操作DOM快了70% … 下面举个简单的栗子： 以往的写法： 12345678910&lt;ul id='ul'&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt;const fruit = ['apple', 'cherry', 'banana']for (let i in fruit) &#123; let liEle = document.createElement('li') liEle.innerHTML = fruit[i] document.querySelector('#ul').appendChild(liEle)&#125;&lt;/script&gt; 运行结果： DocumentFragment的写法： 123456789101112&lt;ul id='ul'&gt;&lt;/ul&gt;&lt;script&gt;let docFragment = document.createDocumentFragment() //创建一个新的DocumentFragment对象const fruit = ['apple', 'cherry', 'banana']fruit.forEach(value =&gt; &#123; let liEle = document.createElement('li') liEle.innerHTML = value docFragment.appendChild(liEle)&#125;)document.querySelector('#ul').appendChild(docFragment) //一次性插入DOM树&lt;/script&gt; 第一种方法中每进行一次遍历，appendChild操作会向DOM树请求一次回流，注意是回流不是重绘(回流比重绘耗时更多)，因为append操作改变了ul元素之后的整体结构。第二种方法中DocumentFragment实际上像一个伪DOM父节点，在这个例子中可以把它当成虚拟的UL元素。这种方法代码量虽然稍微多了点，但只在最后进行一次appendChild操作改变DOM模型树，浏览器只进行一次性回流，因此能很好的优化加载性能。 Vue框架中就是大量运用了该方法，不直接针对DOM对象进行操作，而是将需要增删改的对象都先挂载在DocumentFragment这个虚拟的DOM对象上进行操作，最后完成数据处理之后再一次性提交给浏览器进行回流、重绘呈现新的页面。 关于页面的回流与重绘，简单的理解就是： 回流是指页面的重新布局，任何元素的规模尺寸、布局、显示隐藏等操作都会改变BOM树结构，因此每改动一次都需要进行一次重构。每个页面至少需要一次回流，就是在页面第一次加载的时候。 重绘是指当标签元素更新了一些不会影响到页面布局的属性时，浏览器进行的重新绘制。诸如的属性主要是外观风格这些，比如color、background等等。 详细的内容参考点这里]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Express 单页面切换与跨域请求实例]]></title>
    <url>%2F2017%2F05%2F15%2FVue-Express%20%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最近在学习Vue2.0单页面应用，基本想要达到的效果是前端单页面不刷新切换，同时利用Vue-resource插件实现ajax跨域请求数据的功能，本文主要记录下实践过程中觉得是个坑的地方。实现效果如下： 初始化项目// 全局安装 vue-cli $ npm install vue-cli --g // 创建一个基于 webpack 模板的新项目，项目名为`aVueTest` $ vue init webpack aVueTest // 安装package依赖 $ cd aVueTest $ npm install // 启动项目 $ npm run dev 初始化之后浏览器打开并出现Vue的界面，则初始化成功，进行下一步。 创建前端主页面比较简单，主要注意下router-link中不同的路径写法对应不同to的绑定方法，代码如下： 123456789101112131415161718192021222324&lt;template&gt; &lt;div id="app2"&gt; &lt;h1&gt;Have a nice day!&lt;/h1&gt; &lt;button @click="getOne()"&gt;getOne&lt;/button&gt; &lt;button @click="getZero()"&gt;getZero&lt;/button&gt; &lt;p&gt;返回的数据 :&#123;&#123; resResult &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;b&gt;result:&lt;/b&gt; &lt;router-view class='changestyle'&gt;&lt;/router-view&gt; &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to='/' tag="button"&gt;home&lt;/router-link&gt; &lt;!--路径为字符串时，to不需要v-bind绑定，tag属性设置渲染成什么标签--&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link :to='&#123;name: "foo"&#125;' tag="button"&gt;foo&lt;/router-link&gt; &lt;!--绑定一个对象--&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to='/bar' tag="button"&gt;bar&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;span class="icon"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 前端路由功能的实现其中演示只写了Home、Foo、Bar3个基本的路由功能，实现单页面不刷新的状态下进行组件切换，在浏览器中表现为域名后/#/routerPath，这也是与直接跳转刷新地址的一个区别。代码如下： 123456789101112131415161718192021222324252627282930313233import Vue from 'vue'import App from './App.vue'import VueRouter from 'vue-router'import VueResource from 'vue-resource'// import Home from './components/Home/home.vue'// import Foo from './components/Foo/foo.vue'import Bar from './components/Bar/bar.vue' //一次性引入，会影响加载效率const Home = resolve =&gt; require(['./components/Home/home.vue'],resolve) //懒加载引入，当路由指向该路径时再进行加载const Foo = resolve =&gt; require(['./components/Foo/foo.vue'],resolve) //懒加载Vue.config.productionTip = falseVue.use(VueRouter) //必写，告诉Vue以下要使用Router插件Vue.use(VueResource) //必写，告诉Vue以下要使用Resource插件const router = new VueRouter(&#123; routes: [ &#123;path: '/', name:'home', component: Home&#125;, &#123;path: '/foo', name:'foo', component: Foo&#125;, &#123;path: '/bar', name:'bar', component: Bar&#125; ]&#125;)/* eslint-disable no-new */new Vue(&#123; router: router, template: '&lt;Appoo&gt;&lt;/Appoo&gt;', //该template属性与components属性配合使用，该模板文件最终将绑定在#app内 components: &#123; Appoo: App &#125;&#125;).$mount('#app')router.push('/bar') //初始加载时默认选中的地址 Vue-resource发送跨域请求ajax的跨域请求一般都是通过在服务器端设置头部信息接受跨域请求，而Vue-resource的跨域请求方式不同，是通过在本地虚拟一个代理服务器，然后再通过这个代理服务器向目标服务器发送请求信息，之后再原路返回响应信息，因此需要在Vue的config文件夹中对index.js文件中进行代理服务器配置，配置如下： 123456789proxyTable: &#123; //配置跨域请求参数 '/api': &#123; target: 'http://localhost:10086/', //本地'localhost:8080/api'的地址将被代理为'http://localhost:10086/' changeOrigin: true, pathRewrite: &#123; '/api': '' // '/api'将被替换为''(空) &#125; &#125; &#125; 配置完之后，现在回到App.vue文件中，敲写Vue-resource的代码，注意其他的路由组件只要需要进行后台请求，都可以在Vue实例中利用Vue-resource，以下只在App.vue中实现从后端请求返回一个&quot;0&quot;和&quot;1&quot;的数据。代码如下： 12345678910111213141516171819202122232425262728export default &#123; data() &#123; return &#123; //data数据需要用一个函数包装 resResult: '', sendUrl: '/api/getOne', //这里的'/api'在代理服务之后会被rewrite为'' params: &#123;code: '007'&#125; &#125; &#125;, methods: &#123; getOne() &#123; let vm = this //这里的vm===this，申明vm的作用是为了减少后面this对原型链多层查找 vm.$http.post(vm.sendUrl, vm.params).then((res) =&gt; &#123; //这里就是Vue-resource的写法了，使用了ES6 promise的语法 console.log(res.body) vm.resResult = res.body &#125;). catch((err) =&gt; &#123; //捕获错误 console.log(err) &#125;) &#125;, getZero() &#123; this.sendUrl = '/api/getZero' this.params = &#123;code: '008'&#125; this.getOne() this.sendUrl = '/api/getOne' this.params = &#123;code: '007'&#125; &#125; &#125; &#125; 后台服务器的启动基于Node.js的Express框架，简单编写2个路由接口供前端请求，代码如下： 1234567891011121314151617181920212223const express = require('express')const app = express()const path = require('path')const bodyParser = require('body-parser')app.use(bodyParser.json()) //request.body的解析middlewareapp.use(bodyParser.urlencoded(&#123;extended: true&#125;))let routerArray = ["/getZero",'/getOne'] //接受所有的路由apiapp.post(routerArray,(req,res)=&gt; &#123; if (req.body.code == '007') &#123; res.end('1') &#125; else if(req.body.code == '008') &#123; res.end('0') &#125; else &#123; res.end('Not allowed...') &#125;&#125;)app.use(express.static(path.join(__dirname,'.')))app.listen(10086,() =&gt; console.log('started...')) //启动10086端口与前端Vue启动的8080就是通过proxyTable实现互通的 项目文件结构树如下：]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现百度搜索的跨域请求]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[今天在写ajax的时候查了个资料，了解到HTML标签中script标签的src属性是可以进行跨域请求的，而在ajax请求中，默认情况下，浏览器不允许其访问跨域访问资源，只要源地址与请求的域名、端口号不同，则请求失败，当然通过在服务端设置头文件请求等方式也可实现跨域请求(如设置&quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;)。但对于一些特殊的跨域请求可以变相通过script标签去获得，比如本栗子通过调用百度的搜索功能接口，实现百度首页中的搜索联想功能。 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JS跨域搜索&lt;/title&gt; &lt;style&gt; * &#123; margin: 0px; padding: 0px; &#125; img &#123; width: 270px; height: 129px; /*display: block; margin: 0 auto;*/ &#125; .container &#123; width: 100%; text-align: center; &#125; .search &#123; margin-top: 30px; height: 38px; overflow: hidden; &#125; #inputID &#123; width: 540px; height: 36px; border: 1px solid #3385ff; border-right: none; vertical-align: top; text-indent: 6px; &#125; #inputBtn &#123; width: 100px; height: 38px; border: none; background: #3385ff; color: white; cursor: pointer; font-size: 15px; &#125; .content &#123; width: 640px; margin: 0 auto; border: 1px solid lightgrey; display: none; &#125; ul &#123; list-style: none; text-align: left; &#125; li &#123; margin-left: 3px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;img src="bd_logo.png" alt="百度logo"&gt; &lt;div class="search"&gt; &lt;input type="text" id="inputID"/&gt;&lt;input type="button" value="百度一下" id="inputBtn" onclick="location.href = 'http://www.baidu.com/';"&gt; &lt;/div&gt; &lt;ul class="content"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var searchSuggestion = "http://suggestion.baidu.com/su?wd=#content#&amp;cb=callback"; var headEle = document.getElementsByTagName('head')[0]; document.querySelector("#inputID").addEventListener('keyup', function(e) &#123; var scriptMark = document.getElementsByClassName('JSONP')[0]; if (e.keyCode == "13") &#123; //监听enter事件 location.href = 'http://www.baidu.com/'; &#125; else &#123; if (scriptMark) &#123; headEle.removeChild(scriptMark); &#125; var scriptEle = document.createElement('script'); scriptEle.classList.add('JSONP'); scriptEle.src = searchSuggestion.replace("#content#", document.querySelector("#inputID").value); headEle.appendChild(scriptEle); &#125; &#125;) function callback(data) &#123; document.querySelector(".content").innerHTML = ""; if (data['s'].length) &#123; for (let i in data["s"]) &#123; document.querySelector(".content").style.display = "inline-block"; document.querySelector(".content").innerHTML += "&lt;li onclick=handleClk(this)&gt;" + data["s"][i] + "&lt;/li&gt;"; &#125; &#125; else &#123; //如果输入的关键词不存在联想，则将ul框隐藏 document.querySelector(".content").style.display = "none"; &#125; &#125; function handleClk(e) &#123; //处理选中词条 document.querySelector("#inputID").value = e.innerHTML; document.querySelector(".content").style.display = "none"; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组与对象的深复制与浅复制]]></title>
    <url>%2F2017%2F05%2F09%2FJS%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[今天记录一下Javascript语言中数组与对象两种数据结构的深复制与浅复制方法，温故知新常乐也。 对象的浅复制方法有：浅复制, 复制的是该对象的内存地址，任意一个数据变动会导致另一个也变。1obj = &#123;x:1,y:3&#125;; 方法1：1var obj2 = obj; 方法2：1var obj2 = Object.create(obj); //浅复制 对象的深复制方法有：方法1：1var obj2 = JSON.parse(JSON.stringfy(obj)); //深复制，复制的只是数据 方法2： 数组的浅复制与对象类似，这里只写数组深复制的几种方法：注意字符串、数字每次赋值之后都会将一个新的内存地址指向给到新变量。 1var arr = [1,3,5]; 方法1：1var arr2 = arr.slice(); 方法2：1var arr2 = arr.concat(); 方法3：1var arr2 = arr.filter(()=&gt;&#123;return true&#125;); 方法4：1var arr2 = JSON.parse(JSON.stringfy(arr)); 总结： 基本的数据类型都属于深复制，包括数字、字符串、布尔值等，数组与对象不属于基本数据类型，直接赋值的方式属于内存地址（即指针）的赋值，所以实际指向的值会动态变化。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾几道JS基础算法题]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%9B%9E%E9%A1%BE%E5%87%A0%E9%81%93JS%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[士别三日当刮目相看，题隔三月也有了些许新意。最近静下心来，回头去重新看看以前在freeCodeCamp上做过的JS基础算法题，结合最近了解的ES6一些新特性，对同样的题目可能会有不一样的想法了，所以选了几题梳理并记录一下，如果有更好的解题思路或者建议欢迎指教呀。 给定N个字符串,找出其中重复的字符串和它重复的次数主要有两种思路： 简单粗暴的使用2个 for 循环 正则表达式match方法 第1种方法： 1234567891011121314151617181920212223function abc(str) &#123; var obj = &#123;&#125;, flag = 0, resultStr = ''; for (let i = 0 ;i &lt;str.length; i++) &#123; if (str[i] in obj) &#123; obj[str[i]] += 1; //注意此处必须使用[]形式赋值！！！ flag = 1; &#125; else &#123; obj[str[i]] = 1; &#125; &#125; if (flag == 0) &#123; console.log("字符串不存在重复元素！"); //判断不存在重复元素 &#125; else &#123; var max = Math.max.apply(null,Object.values(obj)); for (let i in obj) &#123; if (obj[i] == max) &#123; resultStr += i + ","; &#125; &#125; console.log("结果为：" + resultStr + "出现的次数"+ max); &#125; &#125;abc("广东省广州市广州大学城广东工业大学") 第2种方法： 1234567891011121314151617function abc(str) &#123; var n = 0, newChar; for (var i=0; i&lt;str.length; i++) &#123; var regExp = new RegExp(str.charAt(i),"g"); //注意此处如果匹配的正则表达式是变量值，则必须通过new RegExp构造函数来创建一个正则实例 var arr = str.match(regExp); if (arr.length&gt;n) &#123; //match方法获得匹配到的值并组成一个数组 n = arr.length; newChar = str.charAt(i); &#125; &#125; return newChar + "出现的次数："+ n;&#125;abc("广东省广州市广州大学城广东工业大学")//栗子：//input: "广东省广州市广州大学城广东工业大学".match(/广/g);//output: ["广", "广", "广", "广"] 重复输出一个给定的字符串主要有三种思路： 使用 for 循环 使用递归 使用ES6 repeat() 第1种使用for循环最常规的方法： 12345678function repeatStringNumTimes(string, times) &#123; var repeatedString = ""; for(var i = 0 ; i &lt; times ; i++) &#123; repeatedString += string; &#125; return repeatedString;&#125;repeatStringNumTimes("abc", 3) 第2种通过条件判断和递归的方法：123456function repeatStringNumTimes(string, times) &#123; if(times &lt; 0) return ""; if(times == 1) return string; else &#123; return string + repeatStringNumTimes(string, times - 1); &#125;&#125;repeatStringNumTimes("abc", 3); 第3种使用ES6 repeat() 方法：ES6新特性虽然带来很大的使用便利性，但要多少理解一些底层的原理.1234function repeatStringNumTimes(string, times) &#123; return times &gt; 0 ? string.repeat(times) : ""; //三目运算&#125;repeatStringNumTimes("abc", 3); 数组去重也有三种思路： 索引比值法 使用数组filter函数 利用ES6 引进的Set数据结构与Array.from() 利用对象属性的唯一性 第一种方法： 123456789function getOut(arr) &#123; var anArr = []; for (let i=0; i&lt;arr.length; i++) &#123; if (anArr.indexOf(arr[i]) == -1) &#123; anArr.push(arr[i]); &#125; &#125; return anArr;&#125; 第二种方法： 1arr.filter((v,s)=&gt;arr.indexOf(v) == s); //s在本函数中代表v元素的下标 第三种方法： 123456Array.from(new Set(arr)); //arr数组传入Set构造函数之后形成一个Set类型的数据结构//说说Array.from函数的好用，将函数实参变数组：//function f() &#123; //return Array.from(arguments); //可用于对未知函数形参个数或者对应位置做判断//&#125; 第四种方法： 1234567let obj = &#123;&#125;, resultArr = []arr.forEach(v =&gt; &#123; if (!obj[v]) &#123; obj[v] = 1 // 若不存在，进行存储赋值，之后再判断 resultArr.push(v) &#125;&#125;)]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让博客加载速度快一些]]></title>
    <url>%2F2017%2F05%2F05%2F%E8%AE%A9%E5%8D%9A%E5%AE%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%BF%AB%E4%B8%80%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[每每打开自己的博客时，发现加载速度真的要好久好久，体验感实在有点差，最近实在看不下去了，想着到底是啥原因导致的，有什么办法可以提高那么一点点的加载速度也行。网上查看了一些资料，知道GitHub的服务器是在美国GitHub公司，我又刚好是把代码托管在GitHub上，所以每次访问自己的GitHub Pages都需要爬山涉水往美国所在地的服务器取数据啊，加上访问的带宽也很一般，加载缓慢也在所难免了，这真是个悲伤的故事 … 不过还好，国内也有一个“高仿”GitHub的代管仓库Coding码市，Coding最近也提供了免费的Coding Pages以及自定义域名。所以我们的想法是通过将代码托管在两个仓库上，然后当输入同一个域名时，DNS可以通过解析IP让国外的IP地址访问到GitHub上的Pages，让国内的IP地址访问国内的Coding服务器上的托管Pages，这样不仅国内访客访问速度可以快一些，还能实现国内外分流，大概有了这个简单的想法，于是以下结合网上一些资料进行了一番尝试。 第一步注册创建一个Coding账号，新建一个repo仓库，基本与GitHub类似，不同的一点就是Coding上可以免费创建私有仓库。创建完成之后进入该仓库的代码菜单中，选中Pages服务，在该页面中分别设置以下几个参数： 第二步完成Coding的配置之后，进行DNS解析，因为我用的是万网的域名，万网自带DNS云解析，所以这里演示的是万网的域名解析配置，但是都大同小异，配置如下： 第三步完成以上配置后，接下来就是让Hexo每次deploy代码的时候往GitHub和Coding仓库都push一份，这就需要在Hexo的_config.yml 配置文件中修改deploy路径，具体如下： 12345deploy: ##发布的仓库地址 type: git repo: github: https://github.com/binglinzhang/binglinzhang.github.io.git,master coding: https://git.coding.net/zhangbinglin/myBlog.git,master 配置完之后以后每次hexo generate和hexo deploy都会往这两个仓库一起push，中间可能需要输入账号密码，可通过在电脑跟仓库上添加公钥，之后在本机电脑push就不需要再输入密码了。 最后以上所有配置完成之后，在浏览器再次输入域名访问，发现国内IP加载速度确实快了一点。在cmd中ping一下域名发现IP地址有2个，一个显示是美国一个是香港，而之前域名只配置GitHub仓库的时候，每次ping出来的IP地址都在美国，这可能也是用Coding Pages访问比较快一些的原因吧。当然网页加载速度慢还跟其他很多因素相关，比如跟外部资源加载，音乐图片链接等息息相关，这就涉及到前端性能优化的大范畴了。以上只从服务器距离写点自己个人的愚见，如果有不对的地方还请指正，感激感激。。。]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恰同学少年，谁主沉浮]]></title>
    <url>%2F2017%2F05%2F04%2F%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4%EF%BC%8C%E8%B0%81%E4%B8%BB%E6%B2%89%E6%B5%AE%2F</url>
    <content type="text"><![CDATA[红日初升，其道大光；河出伏流，一泻汪洋；潜龙腾渊，鳞爪飞扬；乳虎啸谷，百兽震惶；鹰隼试翼，风尘翕张；奇花初胎，矞矞皇皇；干将发硎，有作其芒；天戴其苍，地履其黄；纵有千古，横有八荒，前途似海，来日方长。美哉，我少年中国，与天不老；壮哉，我中国少年，与国无疆！]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5 webWorkers的异步多线程]]></title>
    <url>%2F2017%2F05%2F03%2FH5%20webWorkers%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[假如有这样一个需求：在浏览器页面上输出1~99999之间的所有质数，要求有较好的用户体验，且不借助setTimeout()，setInterval()或调用XMLHttpRequest，该如何设计？ 第一种方法 完整代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1~99999之间的质数有：&lt;p id="result"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; for (let i = 2; i&lt;= 99999; i++) &#123; //求质数方法 let j = 2; while (i%j != 0) &#123; j++ ; &#125; if ( j == i ) &#123; document.getElementById("result").innerHTML += i + ", "; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 以上方法的优点是代码少，且只需要一个文件，不存在跨文件传输数据问题，但缺点也很明显，只有当浏览器JS引擎全部处理完所有的数据之后才会通过DOM把数据添加到HTML页面上，那么当处理99999内质数的时候浏览器大概需要歇菜5秒钟，此时用户只能干瞪着浏览器无法继续操作，如果99999之后再加上一个9，那需要等待的时间还得翻几倍，这就是JS单线程处理存在的一个问题。 那么有没有可能让浏览器优先把页面展示出来，然后后台一边处理数据，一边把处理好的数据先返回回来，再通过DOM动态添加到页面上？最近学习到web Workers，它是运行在后台的 JavaScript，独立于其他脚本，不影响页面性能。用户可以继续点击、选取页面内容等，而此时 web worker 在后台继续运行，多线程并行，上代码。 第二种方法 前端完整代码如下：其中worker.js为另一个js文件，用于处理业务，之后通过postMessage接口与worker进行通信，这也是跨源通信（cross-origin messaging）的一种方式。postMessage接口除了可以向worker传递私有数据类型，还支持JSON数据结构的传递。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1~99999之间的质数有：&lt;p id="result"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var worker = new Worker("worker.js"); //new Worker()构造函数引进一个js文件 worker.onmessage = function(e) &#123; //监听message事件 document.getElementById("result").innerHTML += e.data + ", " ; &#125;&lt;/script&gt;&lt;/html&gt; worker.js文件的代码如下： 123456789for (let i = 2; i&lt;= 99999; i++) &#123; let j = 2; while (i%j != 0) &#123; j++ ; &#125; if ( j == i ) &#123; postMessage(i) ; //postMessage()方法对应前端onmessage监听事件，发送数据的接口 &#125; &#125; 那么还有一个问题，因为onmessage该监听事件是一个回调函数，存在异步问题，如果单个js文件需要处理的业务逻辑太多，需要分成多个js文件去处理，且下一个js文件的执行需要得到上一个js文件处理的结果，这时候就会想到用ES6中的promise方法，于是模拟代码如下： 123456789101112131415new Promise(function(resolve,reject) &#123; resolve(); &#125;).then(function() &#123; var worker = new Worker("worker.js"); worker.onmessage = function(e) &#123; //监听获取worker返回的数据 document.getElementById("result").innerHTML += e.data + ", " ; &#125; &#125;).then(function() &#123; var worker2 = new Worker("worker2.js"); worker2.onmessage = function(e) &#123; //监听获取worker2返回的数据 document.getElementById("result").innerHTML += e.data + ", " ; &#125; &#125;).then(null,function(err) &#123; console.log(err); &#125;) 假设两个js文件postMessage回来的数据是”aaa”和”bbb”，这时候在浏览器运行多次之后会出现2种不同的结果，原因请大家想想。不甘心的我在没有其他更好的方法的情况下又重回了“回调金字塔”，能勉强实现功能的代码如下： 12345678910var worker = new Worker("worker.js"); worker.onmessage = function(e) &#123; document.getElementById("result").innerHTML += e.data + ", " ; var worker2 = new Worker("worker2.js"); worker2.onmessage = function(e) &#123; document.getElementById("result").innerHTML += e.data + ", " ; worker2.close(); //worker属于系统层面的线程,占用资源密集。因此，在完成任务之后及时终止进程 &#125; worker.close(); &#125; 以上是我在学习这个知识点的时候的一些尝试与想法，如果你有更好的办法呢，希望指教，O(∩_∩)O。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入URL到页面加载发生了什么]]></title>
    <url>%2F2017%2F05%2F01%2F%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[最近网上看到这样一个问答题，先前从没想到过有这么深入复杂的各种逻辑，涉及到计算机网络、域名服务器、浏览器性能优化等等，今天参考网上的一些说法大概写几点简单的理解，以待闲暇之余继续逐个深入了解探讨。 1、浏览器查找域名对应的IP地址 这一步包括DNS具体的解析查找过程以及DNS的优化，包括DNS多级缓存，由近及远有：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;域名服务器缓存…，还有就是DNS负载均衡，具体知识点需要google更多。 2、浏览器向web服务器发送一个HTTP请求 服务器的永久重定向响应（从http://example.com 到 http://www.example.com），关于为什么要重定向，其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://example.com/和http://www.example.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。所以要把带www的和不带www的地址归到同一个网站排名下。 还有一个原因是用不同的地址会造成缓存友好性变差。 3、浏览器跟踪重定向地址，发起GET请求 该过程浏览器向远程服务器请求该IP地址对应存放的HTML页面。 4、服务器”处理”请求，向浏览器发回一个HTML响应 该过程服务器响应请求并返回一个静态的HTML页面给到浏览器解析。 5、浏览器解析显示HTML 浏览器解析HTML页面结构构建DOM树，同时找出需要继续向外加载的请求。 6、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 浏览器再次发送网络请求，获取页面上所需的图片、音视频、外部资源等。 7、浏览器发送异步请求（ajax请求等） 浏览器处理script标签中的JS代码，如果存在局部ajax请求则继续发送网络请求。 更详细的参考资料]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《滚蛋吧，肿瘤君》有点感]]></title>
    <url>%2F2017%2F04%2F29%2F%E3%80%8A%E6%BB%9A%E8%9B%8B%E5%90%A7%E8%82%BF%E7%98%A4%E5%90%9B%E8%A7%82%E6%84%9F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今晚忙里偷闲，看了个电影，名字叫《滚蛋吧，肿瘤君》。感触颇多，记录下此刻内心的一点想法。 生活品性虽不忠，却不影响对才华的仰慕，斯者如超级丹。 主演白百合确实演的细腻入微，几番哽咽。 故事主要分3条线索，一个是孤身港湾之外，幸之如艾米、老郑之辈的水手护帆， 时常惊喜，时而轻狂，三言两语陪你理尽光头，处理“生前生后事”的娃娃亲们。 一个是伶仃远洋憋屈无助时候一句“妈，我要回港湾”的谷底暖阳。 最后一个也是倾注更多帧数的话题， 般若艾米追逐事业无视身体加班加点优秀上进的生活， 般若熊顿率性欢颜敢梦敢为有你有我有色有味的人生。 无谓好坏，都是生活态度的一种抉择。 生活本不止于脚下的非黑即白，心往远阳的人多了，生活也就多了更多炫彩。 但笑傲江湖讲，气剑归宗葵花宝典，身体就是生活的葵花宝典。 逐事业也好，戏人生也罢，坐井底也可，游江左也堪，总归一“本”字到头。 活着，你才有所有，有所无，非命无情，一无所有，夫复何求？]]></content>
      <categories>
        <category>生活呀</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创业是一种生活态度]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%88%9B%E4%B8%9A%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%9F%E6%B4%BB%E6%80%81%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[如果你问一个二十出头的年轻人，是想要被催促着买车买房结婚生子的生活，还是谈论着梦想改变世界、让自己一辈子不白活的生活，大多数人会想要后者，却最终选择前者。这就像苹果和微软一样，大多数人都喜欢苹果，但他们都在用Windows操作系统。那些谈论的人还在谈论，而那些梦想改变世界的人，才是真的没有白活。你能想象十几年前睡在硅谷Univ Ave（大学街）165号地板上那几个20出头的小伙儿，后来分别创办了视频网站YouTube、社交网站Linkedin和点评网站Yelp么？ 创业就像走在一条长长的道路上，你看不见尽头，望不到边。有人忍受不了孤独而走上众人的通途，有人受不了困苦沿着脚印一步步退后，只有一种人可以看到豁然开朗的景色：他们从不畏孤独、险途，他们始终与梦想相伴，他们记得为什么出发，所以他们始终都能到达。 你为什么要创业？以下罗列3个参考意见： 1、创业是一种态度冯大辉（丁香园首席技术官）所理解的“创业”，是一种对待工作的态度。 不是说自己一定要单干，比如注册个公司，当个说一不二的老板，才是在创业。想明白工作是为了自己，而不是感觉在为别人打工，这就是创业。 创业，就是一个更为积极、更为明确的工作态度。“我不在创业，就在去创业的路上。”这是我刚加入阿里巴巴那段时间的签名。 罗云登（电商创业者）同样认为创业和态度有关。 如果明天是世界末日，我还会选择创业，这是一种人生态度。 小时候想创业，那是因为受到家人的影响，让人感到一种成就感；中学时候想创业，是为了能住上自己喜欢的房子，开上自己喜欢的车子，去梦想的地方旅行；高中时候开始做网店，找货源，搞宣传，明白赚钱不易。创业是为了让父母过上好的生活，能帮助到自己身边困难的亲人朋友，不仅仅是为了自己要成就什么；大学后开始尝试做不一样的事情，慢慢知道自己要干什么样的事情，并为之努力，未曾放弃，坚持至今。 随着时间的推移，创业观、世界观、互联网观逐渐成熟，明白了创业最大的乐趣是，当你知道你正在做的事情改善了许多人的生活，你慢慢意识到这是一件多么有价值的事情啊！然后继续下去，乐此不疲。其实我们兜售的不是产品，而是梦想。 2、改变自己老杨（懒汉互联网站创始人）刚刚步入创业的行列，这个问题是他不可逾越、但又总想躲避的一个问题。 好好的办公室坐着不舒服吗？ 非得花3个小时的路程只为见客户5分钟，而且一路上又是地铁、公交、步行，又不熟悉见面地点，空气也不好。这是为什么？ 每个月有稳定的收入不舒服吗？ 非得冒着付出远大于回报，甚至是没有回报还倒贴的风险去做事情。这是为什么？ 轻松的工作不舒服吗？ 非得出去苦口婆心地介绍自己及自己的产品，既充当开发者、又当美工、编辑、市场、销售，还要充当财务。这是为什么？ 朝九晚五的工作不舒服吗？ 非得比别人起得早、干得晚，周末毫无怨言地加班，没时间陪家人，没有假期。这是为什么？ …… 我不想等自己老去的时候，回想起过去却是一片空白，一点值得回忆的事情都没有。我不想后悔和叹息，自己尝试了，不管是对还是错，努力过后就无怨无悔。我只是不想虚度光阴。充实和富有挑战，才是自己骨子里最本质的东西。我不期望自己能改变别人的世界，但愿能改变自己的世界。 3、实现人生目标林培中（知乎控，无业游民）认为，要回答为什么创业，有个前提是弄清楚我们的人生目标是什么？ 这个问题，因人而异，没有标准答案。 第一种人希望自己成为一个比降临人世之初更好的人，例如稻盛和夫。这种人往往希望每天都能过得更充实，能把每一分每一秒都用在提高自己、实现自己的人生价值上。 第二种人，希望能好好地享受生活。只要自己和身边的人能够幸福快乐，就已经足够了。 这两种人，并没有优劣之分。克里斯托弗·莫利有一句话说得很好：“只有一种成功——能以你自己的生活方式度过你的一生。” 还有第三种人，他们认为人生就是一场灾难，只希望人生能早早结束。但第三种人没有明确的创业动机，可以忽略。 在了解了不同的人有不同的人生目标后，我们就可以分别讨论他们创业的目标了。 在第一种人中，选择了创业的人也可以分为两类： 一类是有着明确目标的人，第二类是没有明确目标的人（这里假设他们都能承担责任）。胜间和代说过：“我们的人生设计应该是，尽量做自己擅长的事，把赚来的钱请别人做自己不擅长的事。”然而在日常工作中，作为员工的我们往往从事着老板安排的工作，而这些有可能对我们本身价值并不大，或是我们并不愿意做的。从事这样的工作，会让我们对自己产生深深的违和感。 “这就是我想要的生活？”“我这么辛苦到底为了什么？”（正在从事自己感兴趣的工作或是只想得过且过的人除外。）每个人都希望从事自己喜欢的职业，每天做自己想做的事，然而现实是，并非每个人都能如愿以偿。 于是，在第一种人中，第一类人不甘这样下去，有着自己明确的目标，而且有勇气去承担责任的人，选择了创业。对于他们而言，创业是为了充分利用时间，提高自我，实现自己的价值。而第二类人则只是认为与其为别人工作，不如为自己工作。他们创业的目的只是渴望随心所欲的自由，或是认为只有为自己工作，才能实现人生价值。他们只是单纯地在逃避生活。 第二种人创业的目的很简单。创业就是他们享受生活的方式。就像有人会选择骑着自行车环游世界，而有人则会选择坐飞机环游世界一样，是创业还是为他人工作，只是个人享受生活的方式不同罢了。 最后，请让我引用最近微博上很流行的一句话为这个回答终结。 一个不成熟男人的标志是他愿意为某种事业英勇地死去，一个成熟男人的标志是他愿意为某种事业卑贱地活着。——《麦田守望者》 本文内容是我在读《创业时，我们在知乎聊什么》P6~12的文摘，我手中在读是第116899本，欢迎借阅分享。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express + Formidable 实现拖拽文件上传服务器]]></title>
    <url>%2F2017%2F04%2F23%2FExpress%20%2B%20Formidable%20%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%8B%96%E6%8B%BD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[功能需求：以往通过设置“input”标签的type类型为“file”可进行文件选择上传，但该方法效率较低，用户交互体验不是很好，因此通过H5新增的拖放API进行多个文件选择上传，并能在服务端保存成功。 前端页面简单代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;style media="screen"&gt; #target &#123; border: medium double black; width: 200px; height: 80px; text-align: center; line-height: 75px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="target"&gt;Drop files here&lt;/div&gt; &lt;div id="data"&gt;&lt;/div&gt; &lt;br&gt; &lt;input type="submit" value="提交" onclick="handleCLK()"&gt;&lt;/body&gt;&lt;/html&gt; 前端通过Ajax发送上传数据请求，关键代码如下： 其中关键点在于通过FormData对象包装得到一个“文件对象”，从而满足Ajax数据发送要求。 12345678910111213141516171819202122232425262728293031323334353637&lt;script type="text/javascript" src="jquery-1.12.4.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var target = document.getElementById("target");target.ondragenter = handleDrag;target.ondragover = handleDrag;function handleDrag(e) &#123; e.preventDefault();&#125;var fd = new FormData(); //实例化一个FormData对象target.ondrop = function (e) &#123; var files = e.dataTransfer.files; //存储上传的所有文件 var divP = document.getElementById("data"); for (var i = 0; i &lt; files.length; i++) &#123; divP.innerHTML += "文件名：" + files[i].name + "文件大小：" + files[i].size + "&lt;br&gt;"; fd.append("file" + i, files[i]); //将上传的文件丢给FormData实例对象，才能传输给后端，否则需要使用form表单形式提交 &#125; e.preventDefault();&#125;function handleCLK() &#123; $.ajax(&#123; type: "POST", url: "/upload", data: fd, //该对象即为上面FormData实例化之后append到的数据文件 processData: false, //此两行必须添加，否则会与jQuery库冲突报错 contentType: false, //此两行必须添加，否则会与jQuery库冲突报错 success: function (data) &#123; if (data == "1") &#123; console.log("success..."); &#125; else &#123; console.log("something wrong..."); &#125; &#125; &#125;)&#125;&lt;/script&gt; 后端处理响应并返回响应值给前端请求，关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637var express = require("express") //引入Express模块var app = express()var formidable = require('formidable') //引入formidable模块var fs = require("fs")app.post("/upload", function (req, res) &#123;var form = new formidable.IncomingForm();form.parse(req, function (err, fields, files) &#123; for (let i in files) &#123; //此处必须使用let定义i，否则会出现异步问题，具体可参考setTimeout(function()&#123;&#125;,0)的含义 var n = 0; var stream = fs.createReadStream(files[i].path); //创建一个读数据流 stream.on("data", function (chunk) &#123; fs.writeFile(require("path").join(__dirname, files[i].name), chunk, &#123;flag: "a"&#125;, function (err) &#123; //将上传的内容从磁盘读取并写入当前文件夹 if (err) &#123; console.log(err); res.end("0"); &#125; &#125;) &#125;) stream.on("end", function () &#123; n++; if (n == Object.keys(files).length) &#123; //获取对象属性数量生成一个数组，通过数组length得知对象属性个数 console.log("end"); res.end("1"); //当同时上传多个文件时需要对n进行判断，只有当全部上传完成之后才返回响应值 &#125; &#125;) &#125;&#125;);&#125;)app.use(express.static(require("path").join(__dirname, "."))); //暴露文件app.listen(8080, function () &#123;console.log("started..");&#125;) 其中关键点在于”formidable”模块实例一个对象之后对数据流的写入保存，而且需要考虑如果同时上传多个文件使用for…in的遍历方法时，需要考虑let块级作用域结合回调函数异步处理的相互影响。另外如何获取一个对象的属性数量？ 以上代码只是作为演示，具体项目中还有很多可以优化，比如如果用户拖拽文件之后，又重新拖拽几个文件，点击上传，这样在前端代码块中的files会出现问题。另外formidable模块会将数据直接写入磁盘，而且不会擦除，时间久了会很占用空间，关于后端接收数据是否有更优解，比如express中间件multer?等等 …]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习过程中积累的笔记]]></title>
    <url>%2F2017%2F04%2F21%2FJavascript%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A7%AF%E7%B4%AF%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近整理先前作为初学者积累的Javascript学习笔记，回过头来看还是觉得基础很重要啊，虽然随着积累的知识越多，经验越丰富，但基本的知识点万变不离宗，还是要回过头时常翻看下，想起了当年我高考的语文作文：“回到原点”，多恰当哈哈 … 解释型语言：可直接在浏览器或者操作系统执行的文件编译型语言：源代码通过编译器编译生成二进制可执行文件（特点：运行速度快，执行效率高） 局部变量只能在本变量声明的函数内部调用，跳出该函数体之后即无法调用。全局变量在整个代码中都可以进行调用。栗子： 123456789var i = "bling"; //通过var定义了全局之后在控制台中输出i跟输出window.i效果一样function myName() &#123; var i = "Bryn"; // 注意此处通过var定义变量之后，i变为局部变量，如果把var关键字去掉,则变成了给i重新赋值，i还是挂载在window下的全局变量，返回输出的结果即为“Bryn"&#125; myName(); function myLikes() &#123; alert(i);&#125;myLikes(); //返回结果为"bling" 在for语句或者switch选择语句中有以下2个关键语句：continue:执行该语句后即停止当前循环，进入下一次循环；break:执行该语句后立马跳出循环体，不再执行后面动作。 A+=10等效于A=A+10A-=10等效于A=A-10同理还有A=10；A/=10*栗子： 12345var a=10, b=20 , c=30;++a; //立马执行，a即为11a++; //再次调用时执行，此时a还是11e=++a+(++b)+(c++)+a++; //e = 13 + 21 + 30 + 13alert(e); //弹出提示对话框：77 形参即形式，实参即内容，形参只充当占位符，实参决定形参真正的值。函数内的局部变量优先级高于全局变量。 全等运算符（===）：只有当数值大小与数值类型一样才能返回true。&amp;&amp;表示与逻辑运算符，只有当多个参数同时满足条件才执行；||表示或逻辑运算符，只要有任一参数满足条件即执行； JavaScript Object Notation 简称 JSON，它使用JavaScript对象的格式来存储数据。JSON是灵活的，因为它允许数据结构是字符串，数字，布尔值，字符串，和对象的任意组合。 12345678Math.random(); //生成一个[0,1)之间的随机数Math.round(); //把一个数字四舍五入为最接近的整数,算法为Math.floor(x+0.5)，将原来的数字加上0.5后再向下取整，所以Math.round(11.5)结果为12，Math.round(-11.5)结果为-11Math.floor(); //向下取整，如floor(8.9)=8Math.ceil(); //向上取整,如ceil(8.1)=9parseInt(); //字符串取整，如parseInt("15.49")=15,parseInt(1.5)=1Math.max.apply(null,arr); //取任意长度数组中的最大值Math.min.apply(null.arr); //取任意长度数组中的最小值 正则表达式支持的通配符：. 通配任何字符中的一个字符；\d 通配数字中的一个字符,[0,9]；\D 不是数字的字符；\s 空白字符（空白字符有5个，空格” “、换行\n、回车\r、制表符\t、换页符\f）；\S 非空白字符；\w 通配所有的单词字符，包括数字、大小写字母、下划线（63个字符）；\W 通配非单词字符；[a-z]、[A-Z]、[0-9]、[A-Za-z]（包含大小写英文字符）、[a-z0-9]；栗子： [afg]==(a|f|g)；[a\-fg]==(a|-|f|g) ;^ 以什么开始；$ 以什么结束；？ 出现0次或者1次（用于修饰前面的通配字符，不可单独使用，下面同理）；* 出现0次或者多次，即可匹配任意长度 ;+ 出现1次或者多次；{m,n} 出现m到n次；\b 不会消耗任何字符只匹配一个位置，常用于匹配单词边界；栗子：从字符串中”This is Regex”匹配单独的单词 “is” 正则表达式为：\bis\b；\b 不匹配”is”两边的字符，只识别两边是否为单词的边界；栗子：/^[a-z].$/ 表示以小写字母开头的任意2个字符,如a7；p8/^[a-z].？$/ aaa错误/^[a-z].*$/ aaa正确/^[a-z].+$/ aaa正确/^[a-z].{1,3}$/ aaaa正确/^[a-z].{3}$/ 只有aaaa正确 /\d/ 只匹配包含一个数字的字符，如2，5；/\d+/ +用于修饰d，所以匹配到包含一个或者多个的数字组合，如50,123；/\d/g 匹配全局包含一个数字的字符，如25匹配得到[“2”,”5”]；/\d+/g 如25,123匹配得到[“25”,”123”]；/\d+/gi 不分大小写匹配；([ab]+)\1：\1是对前面括号内容的引用次数，因此该匹配只会匹配多个重复a或重复b； 以下这些正则表达式中”^”表示字符类的否定：[^a]表示“匹配除了a的任意字符”;[^a-zA-Z0-9]表示”找到一个非字母也非数字的字符”;[\^abc]表示”找到一个插入符^或者a或者b或者c”;[^\^]表示”找到除了插入符^外的任意字符”;经过对比，发现只要是”^”这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头，也就是说”[]”代表的是一个字符集，”^”只有在字符集中才是反向字符集的意思。 字符串与数组一些常用的内置函数：1234567891011121314151617181920212223242526var regExp=new RegExp() //创建正则表达式；new RegExp().test(string) //测试字符串是否包含表达式，返回值为true or false；string.replace(new RegExp(),and) //用and把字符串中的所有.替换成and；string.match(new RegExp()) //输出匹配到的数组结果，最长匹配原则；string.search(new RegExp()) //输出匹配到的值的首个索引号；var myArr=new Array() //数组创建的其他方式 ;Arr.push() //往最后一个元素后添加数组元素，返回数组长度，更改原数组；Arr.pop() //移除数组最后一个元素,并返回该元素的值,更改原数组的长度；Arr.shift() //移除数组第一个元素，并返回该元素的值,更改原数组的长度；Arr.unshift() //添加元素作为数组的第一个元素，返回值为数组长度；//以上4个方法作用效果相反，push(),pop(),shift(),unshift();string.split(//) //split后面可以加正则表达式按最长匹配原则进行分割；string.slice() //截断字符串，左边括号部分包括，右边括号部分不包括，不改变原数组；string.substr() //返回字符串中从指定位置开始到指定长度的子字符串；string.charCodeAt() //字符串转ASCII码；String.fromCharCode() //ASCII码转字符串；array.reverse() //就地反转数组顺序，改变原数组；array.join() //数组连成字符串；array.toString() //数组转换为字符串；array.slice() //截断数组，左边括号部分包括，右边括号部分不包括；array.slice(n,array.length) //返回一个数组被截断n个元素之后还剩余的元素；array.map(function()&#123;&#125;) //mapmap函数对每一个数组元素进行计算，如+3，-50，*4a等；array.reduce(function()&#123;&#125;,0) //reduce函数对数组内部元素间进行操作，如前后相加相减等；array.filter(function()&#123;&#125;) //filter过滤函数，不改变原数组；array.sort(function(a,b)&#123;return a-b;&#125;) //sort实现重新排序数组大小，升降序通过reverse()改变；array.splice() //增加或减少数组内元素，返回值为被删除元素组成的数组，该函数改变原数组； 不会改变原数组的函数操作有： filter();concat();map();slice();replace();改变原数组的函数操作有： push();shift();unshift();splice();reverse();sort();]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo +Markdown 搭建个人博客关键步骤]]></title>
    <url>%2F2017%2F04%2F15%2FGitHub%20%2B%20Hexo%20%2BMarkdown%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[前人摘树，后人乘凉。小的我喝了茶乘了凉，总不能一下就人走茶凉吧，因此也记录下自己在搭建本blog过程中认为比较重要的几点，如果能助人一二，那敢情甚好，不若自己遗忘时回望回望也是极好的，O(∩_∩)O …环境要求：本文基于win7编写，电脑上需安装node.js及git. 一、创建gitHub特定托管仓库登录个人gitHub账号（没有注册的请自行百度注册），点击右上角+图标，选中“New repository”新建一个仓库. 建仓填写仓库相关信息，如图所示，仓库“Repository name”的命名必须遵循如下规则：“Owner”中的用户名+.github.io，该地址具有唯一性. 图中因为我已经创建过该用户名仓库，所以限制不允许重复创建. 其中仓库描述为选填，仓库默认为“Public”公共仓库，“Private”私人仓库需要付费购买，这里用公共仓库进行演示。初始化仓库也可选可不选，这里不选，后面直接git push自己需要的文件上去，点击“Create Repository”完成创建. 完成创建后，返回该仓库，进入“Settings”中，找到GitHub Pages 可见到“binglinzhang.github.io”显示已经发布，此时即可通过访该地址进行访问. 访问该地址默认会查找仓库根目录下的index.html文件，由于现在我们的仓库为空，需要在本地建仓并push文件到自己的GitHub上，具体的git操作功能不详细说明（常用的git clone，git add –all，git commit -m “…”，git push，git status必须会啊），不明白的可以参考廖雪峰大神的git教程，此处push一个index.html文件到自己的远程仓库上，通过访问自己的仓库即可看到刚刚上传的index.html页面的内容. 图片地址栏中显示的是域名，具体设置参考以下. 想要绑定自己的域名，则需对自己已注册过的域名进行解析(没有注册的可以通过万网注册，需要RMB)，我使用的是阿里云的万网域名解析，按图示进行设置，其中192.30.252.153和192.30.252.154为github提供的两个服务器IP地址，CNAME记录值为上面我们创建的github博客地址. 设置完成之后放回上面提到的“Settings”，在Custom domain下填入自己的域名，保存即可. 二、Hexo的安装与配置下载安装hexo，打开cmd命令行，输入： npm install -g hexo-cli 该安装为全局安装，完成之后在桌面创建一个文件夹，随意命名为”myBlog”, 在命令行中cd到该文件夹中，输入： hexo init 通过以上命令，Hexo帮我们初始化了一个博客项目，内容包括如下： 如果没有.deploy_git文件夹，则需cd到myBlog文件夹下输入： npm install hexo-deployer-git --save 以上文件中_config.yml为主要的配置文件，我们主要修改的内容为以下几项： · 修改网站相关信息123456title: yourblogsubtitle: your subtitledescription: your describeauthor: XXXlanguage: zh-CNtimezone: Asia/Shanghai 注意： 每一项的填写，其:后面都必须保留一个空格，下同。 · 配置个人域名url: http://zhangbinglin.cn · 配置部署1234deploy:type: gitrepo: https://github.com/binglinzhang/binglinzhang.github.io.gitbranch: master 其中repo项为上面创建的Github仓库地址，通过如下图方式copy，注意不要漏掉最后的.git. 此时，在cmd命令行中输入hexo server即可启动本地服务器，默认端口号是4000，因此在游览器中输入http://localhost:4000/ 即可进行访问. 如果希望别人也能访问到我们的文件，此时则需要将本地的文件push到GitHub上，具体指令如下： hexo generate hexo deploy 此时即可通过binglinzhang.github.io或者我们解析后的域名zhangbinglin.cn进行访问. 具体的主题、模板、插件等可访问官网进行优化设置：Hexo文档 三、Markdown书写Markdown是一门简便轻量级的高效率的标记语言，有自己的语法，不多也不难，网上看几个例子即能领会，这里不细讲，推荐一款MarkdownPad2软件，可实现基本的日常写作，看图，百度云盘传送门：密码：fg0v 以上内容只是写了关键的几个步骤，最关键的是要有清晰的思路，比如GitHub在这里起到什么作用，Hexo是怎么跟GitHub结合的，为什么要用Markdown，Markdown如何更高效的插入大量图片，在线存储自己的图片有哪些途径，GitHub仓库地址解析为自己的域名后如何通过自己的域名让别人访问到更多资源等等.]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>