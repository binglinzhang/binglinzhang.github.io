<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于vue搭建管理平台开发模板思路]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%9F%BA%E4%BA%8Evue%E6%90%AD%E5%BB%BA%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[整体分析搭建一个完善管理平台的步骤以及需要注意的要点，主要技术栈为vue + axios + elementUI。 step one: 基于vue-cli快速生成目录结构通过vue-cli下载项目基础模板，其中大部分webpack配置都已经设置好，不需要做过多的调整，需要调整的地方主要有几个地方： run build生成的包文件地址，配置config/index里的assetsRoot属性，以及静态资源assetsSubDirectory文件地址，注意静态文件目录下的资源不会被打包进项目，只会引用。 将config/index里的productionSourceMap属性值改为false，这样不会打包生成map文件，提高打包速度，减少打包时间。生成map文件主要是用于定位错误。 在config/index里可通过proxyTable字段设置反向代理，注意页面中需要走代理的接口需要写成相对路径。 webpack.prod.conf.js文件中new UglifyJsPlugin对象上添加drop_debugger: true, drop_console: true，作用是去除线上代码控制台的输出与debugger。 static文件夹不建议放静态资源，因为开发环境与线上环境static与引用文件的相对路径不一致，可能会导致出错。 创建各views模块文件夹建议按照路由层级进行划分，目标就是可以轻易通过router直接找到文件路径，而不需要去翻route合集。 step two: 入口文件调整可能会出现一种情况，开发过程中各组件css样式以及覆盖ui框架都没什么问题，但通过run build之后出现ui框架样式无法覆盖的问题，导致整体样式布局错乱。这是由于build之后webpack将所有的css默认打包成了一个css文件，这样就会出现后面的样式覆盖前面样式的问题，所以需要考虑一个样式引入的顺序问题。一个原则是框架类的样式提前引入，重置及覆盖类样式延后引入，且将组件入口app文件放到最后再引入，这样组件内的样式在最后被打包，提高优先级。开发阶段没有这个问题。 123456import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css' //框架样式import '@/assets/css/normalize.css' //重置样式import '@/assets/css/common.less' //通用样式import '@/assets/css/index.less' //覆盖样式import App from './App' //最后引入 step three: 路由与菜单配置路由方面大多情况下需要设置为按需加载，提交资源效率，引入es7的import()方法，封装成方法调用。在router文件目录下引入一个menus.js文件，专用于配置多级菜单的路由，其余的路由诸如登录页、404页等独立写路由。menus.js数组有几个注意点： 每个对象提供一个name属性，表明在菜单中要显示的名称。 对于支持链接的菜单对象提供path及component字段，用于路由跳转，提供children字段表明子级菜单位置。 meta属性中auth字段针对所有用户验证session权限，perm字段针对不同用户验证路由权限，icon提供菜单图标。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const ladyLoading = url =&gt; () =&gt; import(`@/views/$&#123;url&#125;.vue`)const Nav1 = ladyLoading('Nav1/index')const Nav2 = ladyLoading('Nav2/index')const Nav3 = ladyLoading('Nav3/index')const Nav11 = ladyLoading('Nav1/Nav11')const Nav12 = ladyLoading('Nav1/Nav12')const Nav13 = ladyLoading('Nav1/Nav13')const Nav131 = ladyLoading('Nav1/Nav131')const menus = [ &#123; name: '导航一', meta: &#123; auth: true, icon: 'el-icon-location', perm: 'nav1' &#125;, children: [&#123; path: 'nav1/Nav11', name: '分组一', meta: &#123; auth: true, icon: 'el-icon-location-outline', perm: 'nav11' &#125;, component: Nav11, &#125;, &#123; path: 'nav1/Nav12', name: '分组二', meta: &#123; auth: true, icon: 'el-icon-phone-outline', perm: 'nav12' &#125;, component: Nav12, &#125;, &#123; name: '分组三', meta: &#123; auth: true, icon: 'el-icon-picture', perm: 'nav13' &#125;, children: [&#123; path: 'nav1/Nav13/Nav131', name: '选项一', meta: &#123; auth: true, icon: 'el-icon-edit', perm: 'nav131' &#125;, component: Nav131 &#125;] &#125;] &#125;, &#123; path: '/nav2', name: '导航二', meta: &#123; auth: true, icon: 'el-icon-menu', perm: 'nav2' &#125;, component: Nav2 &#125;, &#123; path: '/nav3', name: '导航三', meta: &#123; auth: true, icon: 'el-icon-setting', perm: 'nav3' &#125;, component: Nav3 &#125;] 以上菜单数组配置完成之后，接下来将该菜单通过递归生成对应路由，并设置全局路由拦截。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import menus from './menus'const Home = () =&gt; import(`@/views/Home.vue`)const Login = () =&gt; import(`@/views/Login.vue`)// 递归方式const generateRouters = (menus = [], routers = []) =&gt; &#123; menus.forEach(item =&gt; &#123; if(item.path &amp;&amp; item.component) &#123; routers.push(item) &#125; else &#123; generateRouters(item.children, routers) &#125; &#125;) return routers&#125;const router = new Router(&#123; routes: [ &#123; path: '/', name: 'home', meta: &#123; auth: true &#125;, component: Home, children: generateRouters(menus) //生成层级路由 &#125;, &#123; path: '/login', name: 'login', component: Login &#125; ]&#125;)// 全局路由拦截router.beforeEach((to, from, next) =&gt; &#123; if(to.name !== 'login') &#123; //验证session权限 if(to.meta.auth &amp;&amp; !Utils.getLocal('sessionid')) &#123; next(&#123;name: 'login'&#125;) return &#125; //验证路由权限 const perms = Utils.getLocal('perm') || [] if(to.meta.perm &amp;&amp; perms.indexOf(to.meta.perm) &lt; 0) &#123; next(&#123;name: 'login'&#125;) return &#125; &#125; next()&#125;) step four: 生成菜单栏首先在components文件夹下新建一个layout用于存放全局布局样式，主要分为header、menuNav、footer等，并在Home组件中引入各组件，运用css3的calc方法调整好整体的适配。之后也是通过递归生成菜单栏，这里需要关注的一点是由于菜单层级不确定，所以需要使用到组件递归，单独提取一个树状组件，并在template标签上使用v-for进行组件自递归。其中还有一点需要关注的是验证菜单的配置权限，该权限列表根据登录角色由后台维护。步骤是在登录成功之后调用权限接口保存到本地，然后在菜单组件的created事件中进行匹配，当然这里的逻辑是只要父级菜单没有权限，其下所有子级菜单也不会显示。关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Home组件结构&lt;template&gt;&lt;div id="home"&gt; &lt;div class="top-header"&gt; &lt;top-header /&gt; &lt;/div&gt; &lt;div class="main-container"&gt; &lt;menu-nav /&gt; &lt;div class="body-container"&gt; &lt;router-view /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;// 递归组件结构&lt;template&gt;&lt;div class="menu-tree"&gt; &lt;template v-for="item in menuData"&gt; &lt;el-submenu :index="item.name" v-if="item.children"&gt; &lt;template slot="title"&gt; &lt;i :class="item.meta.icon"&gt;&lt;/i&gt; &lt;span slot="title"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;menu-tree :menuData="item.children"&gt;&lt;/menu-tree&gt; &lt;/el-submenu&gt; &lt;el-menu-item :index="item.name" v-else @click='handleClick(item)'&gt; &lt;i :class="item.meta.icon"&gt;&lt;/i&gt; &lt;span slot="title"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/template&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'menuTree', props: &#123; menuData: &#123; type: Array, default: [] &#125; &#125;, methods: &#123; handleClick(item) &#123; if(item.path &amp;&amp; item.name) &#123; this.$router.push(&#123;name: item.name&#125;) &#125; &#125; &#125;&#125;&lt;/script&gt;//验证菜单权限created() &#123; const perms = Utils.getLocal('perm') || [] const filterPerms = menus =&gt; &#123; return menus.filter(item =&gt; &#123; if(item.children) &#123; item.children = filterPerms(item.children) &#125; return perms.indexOf(item.meta.perm) &gt; -1 &#125;) &#125; this.menuData = filterPerms(menus)&#125; step five: 封装请求方法src目录下新增一个api文件夹存放基于axios实例化的http对象，并配置超时、状态码拦截、错误跳转等。封装两种常见请求方式，常规数据提交与数据流上传。这里考虑到可维护性单独将所有接口地址提取为单独一个文件，并转接为一个常量解耦。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const http = axios.create(&#123; timeout: 30000, responseType: 'json'&#125;)http.interceptors.response.use( res =&gt; &#123; const resData = res.data switch (resData.code) &#123; case '200': Promise.resolve(resData.body) break default: Promise.reject(resData.msg) break &#125; &#125;, error =&gt; &#123; const errData = error.response switch (errData.status) &#123; case 404: router.push(&#123; name: 'notFound' &#125;) break case 500: router.push(&#123; name: 'serverError' &#125;) break case 504: router.push(&#123; name: 'internetError' &#125;) break default: break &#125; &#125;)//普通接口调用export const FetchData = (url, method = 'get', params = &#123;&#125;) =&gt; &#123; const path = paths.hasOwnProperty(url) ? paths[url] : url if (method.toUpperCase() === 'GET') &#123; let query = '?' + Object.keys(params).map(key =&gt; &#123; return `$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(params[key])&#125;` &#125;).join('&amp;') return http.get(path + query) &#125; else &#123; return http.post(path, params) &#125;&#125;// 文件上传接口export const Upload = (url, data) =&gt; &#123; const path = paths.hasOwnProperty(url) ? paths[url] : url let params = new FormData() Object.keys(data).forEach(key =&gt; &#123; params.append(key, data[key]) &#125;) return http(&#123; method: 'post', url: path, data: params, headers: &#123;'Content-Type': 'multiple/form-data'&#125; &#125;)&#125; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web视频上传的若干问题]]></title>
    <url>%2F2018%2F06%2F08%2Fweb%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[针对视频时长以及首帧缩略图大部分情况下需要后台文件系统进行处理，考虑特殊情况下，web端能否处理拿到上传视频的相关参数，以下简单封装一个较为完整的视频上传方法。 几点说明： 可自定义上传按钮样式，封装原生ajax方法，封装上传类方法，实例化支持配置不同格式、文件大小等。 上传前可播放预览本地视频，并获取视频时长传给后台，但只支持浏览器可播放的mp4文件，无法播放的文件无法上传时长。 上传成功返回的视频列表提供link prefetch资源预加载。 支持获取视频首帧base64缩略图传递给后台，但不建议直接传递base64，体积太大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;web视频上传的若干问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button class="btn"&gt;点我上传&lt;/button&gt; &lt;input type="file" accept="video/*" class="upload-btn" onchange='upload.handleFileChange(event)' style="display:none"&gt; &lt;video src='' controls class="video-duration" oncanplay="upload.onVideoPlay(event)" onerror="upload.onError()" style="display:none"&gt;&lt;/video&gt; &lt;script&gt; const $ = document.querySelector.bind(document) $('.btn').onclick = function() &#123; $('.upload-btn').click() &#125; class Upload &#123; constructor(options) &#123; this.$ = document.querySelector.bind(document) this.params = &#123; id: options.userId, file: &#123;&#125;, duration: '' &#125; if(options.isCaptureImage) &#123; this.handleCaptureImage() &#125; this.options = options &#125; handleFileChange(evt) &#123; const file = evt.target.files[0] const fileType = file.name.slice(file.name.lastIndexOf('.') + 1).toLowerCase() const types = this.options.types || ['mp4', 'ogg'] const maxSize = this.options.maxSize || 30 * 1024 * 1000 if (file.size &gt; maxSize) &#123; alert('文件超过限制大小') return &#125; if (types.indexOf(fileType) === -1) &#123; alert(`只能上传$&#123;types.join('，')&#125;格式`) return &#125; this.options.videoEle.src = URL.createObjectURL(file) //该方法为h5 API,有兼容性问题 this.params.file = file &#125; onVideoPlay(e) &#123; this.params.duration = this.formatTime(e.target.duration) this._submitFile() &#125; onError() &#123; if(!this.params.file.name) return this.params.duration = '' this._submitFile() &#125; _submitFile() &#123; this.uploadFn(this.options.url, this.params) &#125; uploadFn(url, data) &#123; let params = new FormData() Object.keys(data).forEach(key =&gt; &#123; params.append(key, data[key]) &#125;) const xhr = new XMLHttpRequest() xhr.timeout = 30000 xhr.onerror = () =&gt; &#123; alert('服务器异常') &#125; xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; const res = JSON.parse(xhr.responseText) if (res.code === 200) &#123; alert('上传成功') this.prefetch(res.list) // 预加载视频列表资源 &#125; else &#123; alert('上传失败') &#125; &#125; &#125; xhr.open('POST', url, true) // xhr.setRequestHeader('Content-Type', 'multiple/form-data') // 不需要设置该头部，否则上传失败 xhr.send(params) &#125; prefetch(list) &#123; const headEle = this.$('head') const links = this.$('link[rel=prefetch]') || [] links.length &amp;&amp; [...links].forEach(item =&gt; &#123; headEle.removeChild(item) &#125;) let fragment = document.createDocumentFragment() (list || []).forEach(item =&gt; &#123; let link = document.createElement('link') link.setAttribute('rel', 'prefetch') link.setAttribute('href', item.src) fragment.appendChild(link) &#125;) headEle.appendChild(fragment) &#125; handleCaptureImage() &#123; const scale = 0.8 const video = this.options.videoEle video.addEventListener('loadeddata', () =&gt; &#123; let canvas = document.createElement('canvas') canvas.width = video.videoWidth * scale canvas.height = video.videoHeight * scale canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height) this.params.imageSrc = canvas.toDataURL("image/png") // base64格式 &#125;) &#125; formatTime(seconds) &#123; return seconds ? [ parseInt(seconds / 60 / 60), parseInt(seconds / 60 % 60), parseInt(seconds % 60) ].join(':').replace(/\b(\d)\b/g, '0$1') : '' &#125; &#125; const upload = new Upload(&#123; url: '/restful/upload', userId: 007, types: ['mp4'], maxSize: '', isCaptureImage: false, videoEle: $('.video-duration') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面不可见状态下的性能优化]]></title>
    <url>%2F2018%2F06%2F03%2Fweb%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近开发过程遇到一个需求，web浏览器tab切换的过程需要对即将显示以及隐藏的页面分别进行预处理，本文介绍H5新增API visibilitychange的使用，该API对提高浏览器内存利用、优化性能等有较大作用，实际开发中可尝试接入使用。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152~function() &#123; var EventUtil = &#123; addEventHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler) &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler) &#125; else &#123; element["on" + type] = handler &#125; &#125;, removeEventHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.removeEventListener(type, handler) &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler) &#125; else &#123; element["on"+type] = null &#125; &#125; &#125; var vcConfig = &#123; hidden: '', visibilityChange: '', handler: function() &#123; if (!document[this.hidden]) &#123; console.log('handle sth here...') &#125; else &#123; console.log('stop some action here...') &#125; &#125; &#125; if (typeof document.hidden !== 'undefined') &#123; vcConfig.hidden = 'hidden' vcConfig.visibilityChange = 'visibilitychange' &#125; else if (typeof document.msHidden !== 'undefined') &#123; vcConfig.hidden = 'msHidden' vcConfig.visibilityChange = 'msvisibilitychange' &#125; else if (typeof document.webkitHidden !== 'undefined') &#123; vcConfig.hidden = 'webkitHidden' vcConfig.visibilityChange = 'webkitvisibilitychange' &#125; EventUtil.addEventHandler(window, 'load', function() &#123; EventUtil.addEventHandler(document, vcConfig.visibilityChange, vcConfig.handler) &#125;) EventUtil.addEventHandler(window, 'unload', function() &#123; EventUtil.removeEventHandler(document, vcConfig.visibilityChange, vcConfig.handler) &#125;)&#125;() 1、handler执行的条件包括tab页切换以及窗口最小化后打开。2、针对定时轮询的页面特别有优势，在页面不可见时停止轮询动作，可极大的减少服务端不必要的开销。3、对于音视频的缓冲、循环播放等，在页面隐藏状态下停止操作，减少不必要带宽支出。4、页面中涉及到图片轮播、动画特效、定时操作等，页面不可见时减少浏览器内存开销，这一点有点类似requestAnimationFrame，在处于不可见状态时将停止定时动作。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些js方法的人工babel]]></title>
    <url>%2F2018%2F05%2F20%2F%E4%B8%80%E4%BA%9Bjs%E6%96%B9%E6%B3%95%E7%9A%84%E4%BA%BA%E5%B7%A5babel%2F</url>
    <content type="text"><![CDATA[浏览器内置的原生方法诸如bind、apply、forEach、create，甚至ES6的解构、let、promise等，不止于会使用，如果能用原生代码模拟实现其相关功能，对于更深入理解及正确使用其方法有重要作用。 call、apply的实现call与apply是所有函数对象内置的两个方法，均用于改变this的指向， 二者区别在于执行函数接收参数的形式不同。1234567Function.prototype.call = Function.prototype.call || function() &#123; var content = Object.prototype.shift.call(arguments) if(content === null || content === undefined) content = window content.fn = this content.fn(...arguments) //如果是apply，则换成content.fn(arguments) delete content.fn&#125; bind的实现bind的实现需要考虑2种可能，一种是直接bind完的函数直接被调用，一种是bind完的函数执行new操作，其中的this指向不同，得到的结果不一样，需要区别开来。1234567891011121314151617181920Function.prototype.bind = Function.prototype.bind || function() &#123; var arr = [] var content = Object.prototype.shift.call(arguments) arr.push(...arguments) var _this = this function Fn() &#123; arr.push(...arguments) //new操作的情况 if(this instanceof Fn) &#123; _this(arr) return &#125; //函数直接被调用的情况，即call的过程 content.fn = _this content.fn(...arr) delete content.fn &#125; Fn.prototype = Object.create(this.prototype) return Fn&#125; 对象与数组解构ES6语法中三个点的解构写法，可通过以下方法babel转换，注意解构可能是空对象赋值，也可能是原有对象新增属性。12345678910111213141516171819202122// 对象赋值解构: newObj = &#123; ...obj1, ...obj2 &#125;var _extends = Object.assign || function() &#123; var target = [].shift.call(arguments) || &#123;&#125; for (var i = 0; i &lt; arguments.length; i++) &#123; var source = arguments[i] for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key] &#125; &#125; return target&#125;// 数组赋值解构: newArr = [ ...arr1, ...arr2 ]var _extends = function() &#123; var target = [].shift.call(arguments) || [] for (var i = 0; i &lt; arguments.length; i++) &#123; target.concat(arguments[i]) &#125; return target&#125;// 使用方式_extends(newObj, obj1, obj2) || _extends(newArr, arr1, arr2) let实现js中没有块级作用域的概念，let的声明实则是通过闭包模拟了一个块级作用域。12345678910for (let i = 0; i &lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 0)&#125;// 实则为：function let_loop(params) &#123; setTimeout(() =&gt; &#123; console.log(params) &#125;, 0)&#125;for (var i = 0; i &lt; 5; i++) &#123; let_loop(i)&#125; Object.create实现该方法接收一个对象并返回一个新的对象，新对象的原型将指向接收的参数对象。12345Object.prototype.create = Object.prototype.create || function(obj) &#123; var F = function() &#123;&#125; F.prototype = obj return new F()&#125; Object.keys实现Object.keys与Object.getOwnProperty两者的相同点在于当且只能遍历自身属性，无法遍历原型链上属性，区别点在于前者只能遍历自身可枚举的属性，后者可遍历自身可枚举与不可枚举属性。1234567Object.keys = Object.keys || function(o) &#123; var k = [], p = '' for (p in o) &#123; if (Object.prototype.hasOwnProperty.call(o, p)) k.push(p) &#125; return k&#125; clone深复制实现主要通过递归遍历方式进行简单的复制与赋值，未考虑函数类型的处理。12345678910Object.prototype.clone = function() &#123; var ts = Object.prototype.toString var o = ts.call(this) === '[object Array]' ? [] : &#123;&#125; for (var i in this) &#123; if (Object.prototype.hasOwnProperty.call(this, i)) &#123; o[i] = ['[object Object]', '[object Array]'].indexOf(ts.call(this[i])) &gt; -1 ? this[i].clone() : this[i] &#125; &#125; return o&#125; Promise实现ES6中Promise的实现比较复杂，涉及到多种状态机的判断，本模拟只是提供一种简单粗暴的实现思路，未做具体的状态判定，例如多级链式调用等情况。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class myPromise &#123; constructor(fn) &#123; this.sus = null this.fail = null this.stat = '' this.queue = [] const _this = this function reslove() &#123; _this.stat = 'sus' _this.sus = [...arguments] _this.queue.forEach(obj =&gt; &#123; obj.fn1(..._this.sus) &#125;) &#125; function reject() &#123; _this.stat = 'fail' _this.fail = [...arguments] _this.queue.forEach(obj =&gt; &#123; obj.fn2(..._this.fail) &#125;) &#125; fn(resolve, reject) &#125; then(fn1, fn2) &#123; if (this.stat === 'sus') &#123; fn1(...this.sus) return this &#125; else if (this.stat === 'fail') &#123; fn2(...this.fail) return this &#125; else &#123; this.queue.push(&#123; fn1, fn2 &#125;) return this &#125; &#125; //该all方式使用的是同步调用，与实际异步方式不同 all(arr) &#123; return new myPromise((resolve, reject) =&gt; &#123; var resArr = [], i = 0 function next() &#123; arr[i].then(res =&gt; &#123; resArr.push(res) i++ i === arr.length ? reslove(resArr) : next() &#125;, reject) &#125; next() &#125;) &#125;&#125; 自定义监听事件浏览器内置的事件监听有click，dbclick及其他鼠标事件等，但对于一些鼠标三击事件等非内置事件可能需要自定义。另外自定义事件还可用于参数传递，这点在vue里面的eventBus体现。123456789101112131415161718192021222324class Evt &#123; constructor() &#123; this.obj = &#123;&#125; &#125; on(name, fn) &#123; this.obj[name] &amp;&amp; this.obj[name] = [] this.obj[name] = fn &#125; emit(name, ...args) &#123; const _this = this if(!this.obj[name] || !this.obj[name].length) return this.obj[name].forEach(fn =&gt; &#123; fn.apply(_this, args) &#125;) &#125; remove(name, handler) &#123; if(!this.obj[name] || !this.obj[name].length) return this.obj[name].forEach((fn, index) =&gt; &#123; if(fn === handler) &#123; this.obj[name].splice(index, 1) &#125; &#125;) &#125;&#125; forEach/map/reduce/filter常见的几种高阶函数的模拟实现。1234567891011121314151617181920212223242526272829303132//forEachArray.prototype.forEach = Array.prototype.forEach || function(fn, _this = null) &#123; for (var i = 0; i &lt; this.length; i++) &#123; fn.call(_this, this[i], i) &#125;&#125;//mapArray.prototype.map = Array.prototype.map || function(fn, _this = null) &#123; var arr = this, len = this.length, i = 0, resArr = [] while (i &lt; len) &#123; if (i in arr) &#123; resArr[i] = fn.call(_this, arr[i], i, arr) &#125; i++ &#125; return resArr&#125;//reduceArray.prototype.reduce = Array.prototype.reduce || function(fn, _this = null) &#123; var init = 0 for (var i = 0; i &lt; this.length; i++) &#123; init = fn.call(_this, init, this[i], i) &#125; return init&#125;//filterArray.prototype.filter = Array.prototype.filter || function(fn, _this = null) &#123; var arr = this, len = this.length, i = 0, resArr = [] while (i &lt; len) &#123; if (i in arr &amp;&amp; fn.call(_this, arr[i], i, arr)) &#123; resArr[i] = arr[i] &#125; i++ &#125; return resArr&#125; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究函数执行过程]]></title>
    <url>%2F2018%2F05%2F15%2F%E6%8E%A2%E7%A9%B6%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[了解函数执行过程发生了什么，有利于充分理解作用域、作用域链、闭包等问题，也有利于编写更优化更高性能的代码。本文按照本人的初步理解，尽最大可能讲明白执行过程的关键概念，可能有理解不到位出入的地方，毕竟这是个复杂的过程，欢迎讨论指正。 函数被调用的初始化阶段可以用一个执行环境EC对象来表示，该执行环境在函数被调用时压入执行环境栈中，保证程序按照正确的顺序被执行。每个函数有自己的执行环境，当执行一个函数时，该函数的执行环境被推入执行环境栈顶部并获取执行权(push)，当该函数执行完毕，其执行环境将从栈顶删除(pop)，并把执行权交给之前的执行环境。执行环境EC包含3个属性，分别为变量对象VO、作用域scope及作用域链scopeChain，初始化的过程就是给这3个属性求值并完成赋值的过程。先大概记住这么几句话： 函数的作用域与声明位置有关，与调用位置无关。 函数被调用的过程有2个阶段，一个是初始化阶段，一个是执行阶段。 函数内部this的指向与函数被调用环境有关，与声明位置无关。 函数的形参及变量提升在函数初始化阶段被声明，且函数内部声明的函数可覆盖形参中的函数，其他类型的声明则不会。 函数的作用域链在函数被调用的初始化阶段才真正形成。 变量对象VO属性VO对象包括所有的形参、内部函数提升的变量、内部函数声明，以及[[scope]]，this等属性，函数被调用的初始化阶段分别对这些属性求值。 参数声明其中arguments对象、形参、内部提升的变量以及内部函数声明，有以下几点规则： 函数形参 :VO对象的一个属性，属性名为形参名，值为实参值，若无实参传入，则值为undefined； 变量声明 :只针对通过var声明的变量才具有变量提升作用，此时属性名为变量名，值为undefined，如果该变量名与声明的函数名或函数的形参名相同，该变量声明将直接被忽略； 函数声明 :函数内部通过function关键字声明出来的具名函数，如果该函数名在变量对象中已存在，则该声明函数将覆盖原有的属性值。举2个栗子：123456789101112131415161718192021222324// 栗子一function a(x) &#123; console.log(x) function x() &#123;&#125;&#125;a(11) // function x()&#123;&#125;function b(x) &#123; console.log(x) var x = 22 console.log(x)&#125;b(11) // 11和22// 栗子二var name = 'World'~function () &#123;if (typeof name === 'undefined') &#123; var name = 'Jack' console.log('Goodbye ' + name)&#125; else &#123; console.log('Hello ' + name)&#125;&#125;()// 打印结果为：'Goodbye Jack' [[scope]]该属性根据内部函数定义声明的环境确定其属性值，其属性值指向VO对象本身。举个栗子，假设现有函数A，在其内部定义声明一个函数B，则在A函数的VO(A)对象上将会有属性{B: function, B[[scope]]: this或VO(A)}。每个函数在定义的时候，都会创建一个与之关联的[[scope]]属性，该属性总是指向定义函数时所在的环境，这也可以理解为函数的作用域与其定义声明的环境相关，因为[[scope]]属性指向VO本身，所以能访问到的属性有且只有当前的VO属性及索引到以上作用域的变量。12345678910111213141516171819202122232425262728293031var x = 10function a() &#123; console.log(x)&#125;function b() &#123; var x = 5 a()&#125;b()//变形1var x = 10function a() &#123; console.log(x)&#125;function b() &#123; x = 5 a()&#125;b()//变形2var x = 10function b() &#123; var x = 5 a() function a() &#123; console.log(x) &#125;&#125;b()// 分别打印: 10 5 5 thisthis属性求值，以下罗列几种值的可能性： Function Invocation Pattern诸如foo()的调用形式，是函数最直接的使用形式，注意这里的foo是作为单独的变量出现，而不是属性。在这种模式下，foo函数体中的this永远为Global对象，在浏览器中就是window对象。主要严格模式下为undefined。 Method Invocation Pattern诸如foo.bar()的调用形式，注意其特点是被调用的函数作为一个对象的属性出现，必然会有“.”或者“[]”这样的关键符号。在这种模式下，bar函数体中的this永远为“.”或“[”前的那个对象，如上例中就一定是foo对象。 Constructor Patternnew foo()的调用形式，其关键字new就很能说明问题，非常容易识别。在这种模式下，foo函数内部的this永远是new foo()返回的对象。 Apply Patternfoo.call(thisObject)和foo.apply(thisObject)的的调用形式，使用了内置的call和apply函数。在这种模式下，call和apply的第一个参数就是foo函数体内的this，如果thisObject是null或undefined，那么会变成Global对象。 指向html自身元素这种在事件处理中通过传递this可以将本身元素标签进行传递。 this还可能在函数内部指向arguments对象当函数作为形参传递时，通过arguments对象可以获取到该函数调用，这时函数内部的this指向即为arguments对象。应用以上6种方式，确定一个函数是使用什么样的Pattern进行调用的，就能很容易确定this是什么。另外，this是永远不会延作用域链或原型链出现一个“查找”的过程的，只会在函数调用时就完全确认。1234567891011121314151617181920212223//栗子var res = (function () &#123; var a = b = 11 var obj = &#123; a: 22, b: this.a, c: this.b, fn: function() &#123; console.log(this.a, b); (() =&gt; &#123; console.log(this.a) &#125;)() return function(c) &#123; var c console.log(this.a, b, c) &#125; &#125; &#125; return obj&#125;)()res.fn()(33)// 打印结果：// 22 11// 22// undefined 11 33 scope属性scope属性与VO对象同级，该属性与VO对象中的[[scope]]属性不一样，前者指的是上一级的作用域，后者指的是当前的作用域，两者的区别就在于作用域范围的不同。 scopeChain属性作用域链scopeChain属性值在初始化时，获取到EC对象中的scope属性，同时将VO属性添加到作用域链的顶端，这样就形成一条自顶向下的作用域链。任何标识符的查找都是通过这条链进行检索，一直检索到全局作用域下，如果还未检索到，则返回undefined，结束检索。 整理的一张导图，仅供参考 more]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas创建水印背景的思路]]></title>
    <url>%2F2018%2F04%2F25%2Fcanvas%E5%88%9B%E5%BB%BA%E6%B0%B4%E5%8D%B0%E8%83%8C%E6%99%AF%E7%9A%84%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最近入职一家金融公司，由于金融安全等级比较高，公司内部所有电脑、app等页面均默认带上个人登录账号信息水印，本文尝试着模拟实现一个添加自适应水印背景的方案。 step one: 创建canvas元素及容器 首先老样子，上来先写好所需元素结构，然后给点color see see，注意一点的是canvas元素添加宽高方式不能直接在样式表里面设置，转换一下思路，把canvas元素当做一个img标签来看就能明白为什么了，图片如果直接通过style设置宽高，将会有拉伸的可能。 canvas没有写width跟height属性时，默认值为300和150，这里先不写，因为后面需要根据容器的大小动态设置。 给canvas元素设置display:none是因为该画布并不需要出现在页面上，且不应该占据页面文档流位置。1234567891011&lt;!--元素部分--&gt;&lt;body&gt; &lt;canvas id="canvas" style="display:none"&gt;&lt;/canvas&gt; &lt;div id='container'&gt;test&lt;/div&gt;&lt;/body&gt;&lt;!--样式部分--&gt;&lt;style&gt;html,body &#123; margin: 0; padding: 0; &#125;#container &#123; width: 100vw; height: 100vh; &#125;&lt;/style&gt; step two: 函数实现部分考虑到函数的可复用性，将实现函数进行作用域封装，通过FIFE方式的好处是变量跟函数的声明动作只需要进行一次，当然也因此造成了作用域链长的问题。作用域内部全局声明2个变量，一个类似jq的$元素选择器，一个是不同函数间传递的图片变量。之后是3个实现的具体步骤，也分别通过函数方式进行区分。 动态获取容器宽高。首先获取需要添加背景水印的容器尺寸，由于元素的宽高设置可能通过内联也可能是外联样式进行设置，因此这里使用getComputedStyle方法进行获取元素的宽高(IE下是另外一个方法)，由于获取到的值是带px单位的字符串，而canvas只接受数字类型的宽高，因此通过parseInt方法进行一下转换，最后将值赋给canvas的width、height属性即可。 生成canvs图片。canvas是参数设置先行的特点，即所有的参数设置需要在画笔画下去之前进行设置才能生效，这里通过canvas画布的大小动态设置水印字符的规格可根据需求调整，比如间隔、字体、大小等，设置canvas字符串的关键方法是fillText，接受3个参数，分别是字符串、x坐标、y坐标。最后将canvas画布通过toDataURL方法导出为base64的图片格式。 设置canvas图片作为背景图。这一步比较简单，就是将第二步获取到的图片设置为容器的背景。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let getWaterMark = (function() &#123; //声明2个全局变量 const $ = document.querySelector.bind(document) let watermarkImage = null //声明3个函数 function getContainerSize(canvas, containerId) &#123; const containerEle = window.getComputedStyle($(containerId)) canvas.width = parseInt(containerEle.width, 10) canvas.height = parseInt(containerEle.height, 10) &#125; function getCanvasImg(canvas, str) &#123; let ctx = canvas.getContext("2d") ctx.font = "20px Helvetica" ctx.fillStyle = "rgba(225, 0, 0, .5)" ctx.rotate(-45 * Math.PI / 180) const canvasW = canvas.width * 1.414 const canvasH = canvas.height * 2 let widthArr = [], heightArr = [], n = 0 while (n &lt;= canvasW) &#123; widthArr.push(n) n += canvasW * .2 &#125; n = 100 while (n &lt;= canvasH) &#123; heightArr.push(n) n += canvasH * .15 &#125; widthArr.forEach(function(item) &#123; heightArr.forEach(function(it) &#123; ctx.fillText(str, item, it) item !== -item &amp;&amp; ctx.fillText(str, -item, it) &#125;) &#125;) watermarkImage = canvas.toDataURL("image/png") &#125; function setWatermark(id) &#123; watermarkImage &amp;&amp; $(id).style.background = `url($&#123;watermarkImage&#125;) no-repeat fixed` &#125; //返回调用函数 return function(canvasId = 'canvas', containerId = 'body', waterText = 'I am default') &#123; let canvas = $(canvasId) // 动态获取容器宽高 getContainerSize(canvas, containerId) //生成canvs图片 getCanvasImg(canvas, waterText) // 设置canvas图片作为背景图 setWatermark(containerId) &#125;&#125;)() step three: 窗口监听这里对窗口大小的缩放进行监听并动态修改背景图片大小，考虑到窗口大小缩放频率比较高，因此采用防抖函数节省性能支出。123456789101112//窗口监听window.onresize = function() &#123; debounce(() =&gt; &#123; getWaterMark('#canvas', '#container', 'zhangbinglin666') &#125;)&#125;//防抖函数let debounce = (function() &#123; let timer = null return function(fn, delay = 300) &#123; clearTimeout(timer) timer = setTimeout(fn, delay) &#125;&#125;)() step final: 效果最后的展示效果如下，源码地址这里]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈new的实例化过程]]></title>
    <url>%2F2018%2F03%2F22%2F%E8%B0%88%E8%B0%88new%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浏览器实现new实例化的过程我们都知道有三个步骤，分别是创建一个空的实例化对象this、将this的原型（__proto__属性）指向构造函数的prototype（实例原型）、执行构造函数并最终默认返回this。现假设业务开发中提出这么3点需求，需要代码层面进行实现，本文将尝试通过自定义一个方法模拟实现该业务的功能需求。 new的栗子首先看一下实际应用中new的使用，实例对象包括浏览器内置的Object、Array、Date等及自定义构造函数，其中构造函数内部的返回值如果没写或者返回的不是基本类型的值，则默认返回this。而对于构造函数原型上的方法默认返回值为undefined，因此如果需要支持链式调用，则需要显性返回一个this，即实例对象。如果使用ES6新定义的class关键字，则类的书写结构更加清晰，但要知道这只是语法糖，背后的实现还是通过构造函数的方式实现。12345678910111213141516171819202122232425262728//创建一个JQ构造函数，并支持链式调用function JQ(el) &#123; this.el = el return this //默认返回值，可以不写&#125;JQ.prototype.on = function(type, fn) &#123; this.el.addEventListener(type, fn) return this&#125;//使用方式var jq = new JQ(document.getElementById('id'))jq.on('mouseover', function() &#123; console.log('mouseover')&#125;).on('mouseleave', function() &#123; console.log('mouseleave')&#125;)// 使用ES6 class关键字的方式创建的类class JQ &#123; constructor(el) &#123; this.el = el &#125; on(type, fn) &#123; this.el.addEventListener(type, fn) return this &#125;&#125; 初步实现由于new是js的关键字，无法像浏览器内置函数如bind、forEach等直接覆盖，所以这里的模拟通过封装一个函数进行模拟，函数支持1个以上参数，第一个参数即为构造函数，剩下参数为该构造函数的参数，使用方式如下：var jq = myNew(JQ, el)。基本思路： 创建一个新的空对象，并获取构造函数 将构造函数的prototype赋给实例对象的原型，实现继承 实例对象通过call的方式调用构造函数 返回实例化对象1234567function myNew() &#123; var Constructor = [].shift.call(arguments) var obj = &#123;&#125; obj.__proto__ = Constructor.prototype Constructor.call(obj, arguments) return obj&#125; 优化版本以上版本整体思路是对的，但中间有几个点需要注意： 构造函数的prototype直接等于实例对象的__proto__，这种实现继承方式有2个问题，一个会导致原型可被实例对象轻易修改，一个是__proto__不兼容； 直接返回实例化对象，即默认返回this，没有考虑到构造函数返回其他类型值的可能。以下版本对上面2点进行优化：1234567891011121314151617181920212223242526function myNew() &#123; //第一步：获取构造函数 var Constructor = [].shift.call(arguments) //第二步：创建一个空的新对象并将原型指向构造函数的prototype属性 var obj = Object.create(Constructor.prototype) //第三步：传入参数执行构造函数，这里要保证调用对象为上面创建的对象，确保this的指向 var result = Constructor.apply(obj, arguments) //第四步：判断构造函数的返回值决定return内容，这里需要注意返回值为null的情况 return (result &amp;&amp; typeof result === 'object') ? result : obj&#125;// 使用方式var jq = myNew(JQ, document.getElementById('id'))jq.on('mouseover', function() &#123; console.log('mouseover')&#125;).on('mouseleave', function() &#123; console.log('mouseleave')&#125;)//关于Object.create的兼容Object.prototype.create = Object.prototype.create || function(obj) &#123; var F = function() &#123;&#125; F.prototype = obj return new F()&#125; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于防抖节流函数的实现与优化]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%85%B3%E4%BA%8E%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端开发中，对于大多数的事件监听都会导致页面的高频触发重渲染，诸如滚动事件、窗口缩放、鼠标事件等，而浏览器最常见的页面渲染的帧频为60fps，即每秒刷新帧数为60，约1000/16=16.7ms刷新一帧，因此任何低于高频率的操作皆无法及时的放映到页面上，消费无用功且极大消耗CPU性能。因此对于大多数高频执行考虑通过延迟执行的方式进行优化，类似的有防抖、节流等处理，详见本文。 防抖函数防抖函数的思路是通过屏蔽事件监听的过程，忽略其他阶段，只考虑执行最后一次事件处理函数。下面的方法默认最后一个事件处理的延迟执行操作时间为300毫秒，可以很好的屏蔽大部分的高频操作事件，达到提升性能的作用，且延迟执行时间可自由配置。栗子中设置了延迟时间为1000毫秒，假设用户持续操作窗口缩放的时间为2000毫秒，那么防抖函数将在2000毫秒之后+1000毫秒延迟时间，共3000毫秒之后执行处理函数。因此，该方式只适合时效性要求不是很高的事件处理上，不适合图片懒加载等要求及时的应用上面。12345678910111213141516//窗口监听事件window.onresize = function() &#123; debounce(doSth, 1000)&#125;//防抖函数let debounce = (function() &#123; let timer = null return function(fn, delay = 300) &#123; timer &amp;&amp; clearTimeout(timer) timer = setTimeout(fn, delay) &#125;&#125;)()//业务处理函数function doSth() &#123; console.log('well, some action here...')&#125; 节流函数节流函数的思路是通过类似轮询的方式，根据设置的定时间隔，每隔固定时长执行一次事件处理函数，相对于防抖函数具有更高的时效性。栗子中设置了延迟时间为1000毫秒，假设用户持续操作窗口缩放的时间为3000毫秒，那么节流函数将每隔1000毫秒执行一次处理函数，整个过程总共执行3次。但假如用户持续操作窗口缩放的时间比延迟时间短，只有500毫秒，则将退回防抖函数的处理方式。123456789101112131415161718192021222324252627//窗口监听事件window.onresize = function() &#123; throttle(doSth, 1000)&#125;//节流函数let throttle = (function() &#123; let timer = null, prev = null, now = null return function(fn, delay = 1000) &#123; now = new Date() if(!prev) &#123; fn() //当首次调用时立即执行 prev = new Date() return &#125; timer &amp;&amp; clearTimeout(timer) if(now - prev &lt;= delay) &#123; timer = setTimeout(fn, delay) //退回防抖方式 &#125; else &#123; fn() //当窗口缩放结束，第二次重新开启缩放时立即执行 prev = now &#125; &#125;&#125;)()//业务处理函数function doSth() &#123; console.log('well, some action here...')&#125; 一种更优化的思路这种方式与以上2种有以下几点不同： 通过一个标志位控制业务函数的执行； 事件触发立即执行业务函数，而不是延迟执行，且之后每隔所设置的延迟时间间隔后再次执行； 假设两种场景，一种是用户缩放窗口时间比所设置延迟时间小，则该方法立即执行了一次业务函数，之后延迟时间到达后标志位恢复；另外一种是用户缩放窗口时间比所设置延迟时间长，则该方法立即执行一次之后，每隔相同的延迟时间后标志位恢复循环执行。 结合以上几点，个人感觉这种方式比以上2种更优，如有不同意见，欢迎探讨。123456789101112131415161718192021222324252627//防抖节流函数class Optimistic &#123; constructor(fn, delay) &#123; this.method = this.method.bind(this) this.flag = true this.fn = fn this.delay = delay this.timer = null &#125; method() &#123; if (this.flag) &#123; this.timer &amp;&amp; clearTimeout(this.timer) this.flag = false this.fn() this.timer = setTimeout(() =&gt; &#123; this.flag = true &#125;, this.delay) &#125; &#125;&#125;const optimistic = new Optimistic(doSth, 1000).method// 窗口监听事件window.onresize = function() &#123; optimistic() &#125;//业务处理函数function doSth() &#123; console.log('well, some action here...')&#125; 方案源码这里]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发项目的一些规范]]></title>
    <url>%2F2018%2F01%2F11%2Fvue%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[总结利用vue开发几个项目过程中应用到的几条规范，规范对于多人团队开发极为重要，这里只针对vue框架的一个规范，js与css部分未加入，后续将继续总结维护更新。 vue规范1、所有命名必须具有语义化，不允许直接后缀加上1,2,3，js代码使用驼峰命名法，css代码使用-或者_连接符，组件首字符大写。2、关键代码需要注释说明，公用组件需要说明调用方式以及入参、响应参数。3、代码必须格式化，console.log以及注释之类的代码在调试完成后全部删除。4、组件书写顺序按照统一结构排版：&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;。5、组件template最外层标签添加唯一className，组件的name属性名于此相同，书写样式时最外层加上统一加上改className。6、生命周期书写顺序一般按照name、mixins、components、props、data、computed、watch、created、mounted、methods排序。7、提取公共css样式库，解耦css代码，提高className复用性。可参考css库8、公用组件放置components文件夹下，且对于常用的公用组件，将其注册为全局组件使用，非公用组件放置views相关模块文件夹下，所有组件必须首字母大写。9、一个组件逻辑代码部分总行数尽量不超过400行，如果超过考虑进行组件拆分，拆分有2种方式，一种是通过vue提供的mixins功能，一种是直接引入js文件方式，但需要注意作用域问题。同理methods里面尽量编写纯函数，函数解耦，函数功能单一化等。10、所有api的url路径统一提取到一个文件进行维护，可写为常量的形式。11、views文件目录按照功能模块的router层级设置，且最好每个功能模块有个index入口文件，方便快捷根据路由地址找到相关代码。12、vue项目文件目录中不允许存在中文字符，否则热加载失败。13、assets文件夹中尽量按照css、font、images、js文件夹进行区分，非静态资源尽量不要放置在static文件夹。14、所有路由采用按需懒加载方式，ES7的写法是: const ladyLoading = ulr =&gt; () =&gt; import(url)。15、若项目在main.js中引入第三方UI库，需要确保引入的UI库顺序在import App.vue之前，且样式覆盖表也在此之后，这样才能在webpack将css打包成一个文件的时候按序打包，否则可能出现样式错乱。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人类简史阅记]]></title>
    <url>%2F2018%2F01%2F01%2F%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E9%98%85%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近看人类简史，里面提到一个挺有意思的点，人类从采集者身份走向农业时代是一个史上最大的骗局… 人类以为自己驯化了粮食植物，但其实是稻米小麦驯化了我们。 小麦不喜欢石头，人类扛起锄子捡石头，一番腰酸背疼；小麦喜欢独享空间、光线、水分，聪明的人类烈日炎炎锄禾日当午；小麦生病，人类饭饮不思，驱虫把脉；小麦口渴，人类砸壁垦荒，引泉止渴；小麦饥饿，人类筐箧中物，似粪滋肥；…… 明智人类作为麦田守望者，无畏一生，兢兢业业，折脊沉腰，俯首甘为孺子牛，如斯也。 俄后营养充沛，荷尔蒙上亢，养儿弄孙，激增的嗷嗷饥口要求更多肥沃之土壤，更高效高能之孵出。结局反而是量保质不再，不得初心，适得其反。 作者问聪慧人类为何会陷入这般致命误判？回答是：因为我们无法真正了解各种决定最后的结果。我们总以为工作努力辛苦一些，生活就能过得更好一点。 回归当代社会，似乎还是停留在一万年前祖先们的陷阱里，没得进化逃脱。如今我们陷身于欲望与焦虑、房奴与车奴，一味梦想还是要有的，一味明天总会更好的……一边不断熬夜达旦、辘辘肥肠，一边凑齐六味地黄丸搭着枸杞茶慰藉肾气。吸更多霾为下一代除害，赚更多钱为明天看更好医院吸更好氧气奋斗。 挺有意思的点子与感想，与君分勉，不要骂我…]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue递归组件的使用]]></title>
    <url>%2F2017%2F12%2F14%2Fvue%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vue、react等MVVM框架其中一个最大特点是充分利用了组件化可复用性的特点，这个优点体现在管理系统层级菜单的生成中。当层级菜单未知层级或者由后台动态生成时，此时便需要对组件进行递归渲染，vue中称之为递归组件。本文将通过展示一个demo说明使用递归组件时需要注意的几个点，以供参考。 简单聊聊递归递归至少有以下2个特点，一个是调用自己，一个是有结束条件。针对普通的递归函数，如果是具名函数，则可以通过直接使用函数名的方式调用自己，如果是匿名函数，则通过arguments提供的callee进行调用。而对于vue组件，若要调用自己，则需要先给组件赋名，通过设置name属性之后进行调用。至于结束条件是必备条件，满足条件则结束递归，否则将陷入死循环导致堆栈溢出，因此写递归的时候最重要的就是要考虑递归的边界条件。12345678910111213141516171819202122232425262728293031323334353637383940//普通递归函数写法function getMenus(arr = [], menus = []) &#123; arr.forEach(item =&gt; &#123; if (item.path) &#123; routes.push(item) &#125; if (!item.component) &#123; //条件判断 getMenus(item.children, menus) //调用自己 &#125; &#125;) return menus&#125;//递归组件写法&lt;template&gt; &lt;ul&gt; &lt;li v-for="(item, index) in data" :key='index'&gt; &lt;span @click="toggle(item, index)"&gt;&lt;/span&gt; &lt;treeMenu :data="item.children" v-if="scope[index]" /&gt; //v-if是关键 &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'treeMenu', //关键 props: &#123; data: &#123; type: Array, default: [] &#125; &#125;, data() &#123; return &#123; scope: &#123;&#125; &#125; &#125;, methods: &#123; toggle(item, index) &#123; if (item.children &amp;&amp; item.children.length) &#123; this.$set(this.scope, index, !this.scope[index]) &#125; &#125; &#125;&#125;&lt;/script&gt; 说说几个要点1、组件需要设置name属性，命名规则与组件引用相似。2、组件设计的时候需要考虑外部传递参数的形式，比如数组或map对象，需要统一约定好。3、由于需要生成多级菜单，因此会在li标签中嵌套递归自身组件，但每个组件之间没有太多关联，彼此之间数据独立，生命周期独立，因此设计组件的时候需要充分考虑组件的周期，避免不必要或者不合适钩子出现。4、通过引入scope对象，用于单独存储每个组件自身的状态，记录点击的item序号，结合v-if控制组件的显示隐藏，并相应切换icon。最终实现效果如图示，源码地址这里 可能存在的问题1、点击一级icon展开后，再点击二级icon展开，当一级icon收回之后，再展开时先前二级展开的状态丢失，这是由于使用了v-if的原因，可通过v-show替换，但因此也可能带来渲染性能上的问题。2、递归组件继承相同的样式，导致无法针对性设置样式，除非通过数据项进行判断覆盖渲染。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道js基础算法题引发的]]></title>
    <url>%2F2017%2F11%2F21%2F%E4%B8%80%E9%81%93js%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%2F</url>
    <content type="text"><![CDATA[最近工作中遇到一个需求如下：需要将不确定长度的数组[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]转换为JSON对象{&#39;a&#39;:{&#39;b&#39;:{&#39;c&#39;:{&#39;d&#39;:&#39;e&#39;}}}},由此探讨了几种可能性,并尝试反之由{a:{b:{c:{d:e}}}} =&gt; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]的实现方案，一并记录如下。 [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] =&gt; {a:{b:{c:{d:e}}}}几种实现方案第一种方法特点：简单粗暴,基本没有什么逻辑。123456789101112131415161718function arr2Obj(arr, str = '') &#123; let len = arr.length if (len &lt; 2) &#123; return &#125; for (var i = 0; i &lt; len; i++) &#123; if (i &lt; len - 1) &#123; str += `&#123;"$&#123;arr[i]&#125;":` &#125; else &#123; str += `"$&#123;arr[i]&#125;"` &#125; &#125; for (var j = 0; j &lt; len - 1; j++) &#123; str += '&#125;' &#125; return JSON.parse(str) // 或 return eval('(' + str + ')')&#125; 第二种方法特点：采用由里及外逆向扒开循环。1234567891011121314function arr2Obj2(arr) &#123; if (arr.length &lt; 2) &#123; return &#125; let obj = &#123;&#125;, len = arr.length obj[arr[len - 2]] = arr[len - 1] for (let i = len - 3; i &gt;= 0; i--) &#123; let objTemp = &#123;&#125; objTemp[arr[i]] = obj obj = objTemp &#125; return obj&#125; 第三种方法特点：采用递归循环,看时容易写时难。123456789101112131415function arr2Obj3(arrs, obj = &#123;&#125;) &#123; let el = arrs[0] if (arrs.length &gt; 2) &#123; if (!obj.hasOwnProperty(el)) &#123; obj[el] = &#123;&#125; &#125; arrs.splice(0, 1) arr2Obj3(arrs, obj[el]) return obj //注意此处的return位置以及return值很关键 &#125; if (arrs.length === 2) &#123; obj[el] = arrs[1] &#125;&#125; 递归方式实现{a:{b:{c:{d:e}}}} =&gt; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]1234567891011function obj2Arr(obj, arr = []) &#123; for (var prop in obj) &#123; arr.push(prop) if (typeof(obj[prop]) === 'object') &#123; return obj2Arr(obj[prop], arr) &#125; else &#123; arr.push(obj[prop]) return arr &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的一些常用指令]]></title>
    <url>%2F2017%2F11%2F11%2Fgit%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[总结项目常用到的几个git指令，特别当项目内网环境下开发，通过gitLab搭建本地git服务器，常常需要fork一个项目到自己远程仓库或者在远程仓库新增自己的分支，且需要与原仓库项目保持同步等。 常用git指令1、git remote -v 查看已添加的远程仓库详情2、git remote add storeName storeNamePath 添加远程仓库3、git remote rm storeName 删除远程仓库4、git push storeName master:zbl 将本地master分支提交到远程storeName仓库zbl分支上，如果远程storeName仓库中没有zbl分支，则默认创建zbl分支5、git push storeName –delete(或者-d) zbl 删除远程storeName的zbl分支6、git fetch storeName zbl 拉取远程storeName仓库zbl分支代码7、git merge storeName/zbl 将当前本地分支与拉取下来的storeName/zbl分支合并8、git pull storeName zbl 将远程storeName仓库zbl分支吓到本地并同时合并，是6与7的结合9、git branch -a 查看本地及关联远程仓库下的所有分支10、 git status 时时查看修改状态]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数封装库]]></title>
    <url>%2F2017%2F10%2F10%2F%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E5%BA%93%2F</url>
    <content type="text"><![CDATA[集合一些常用的函数封装，持续更新。 通过系统获取时间数据1234567891011121314151617181920function getDays(beginDay = '2017-9-28', endDay = '2017-10-15') &#123; let beginArr = beginDay.split('-') let endArr = endDay.split('-') beginArr[1] = parseInt(beginArr[1]) - 1 + '' //月份减1,系统才能按正确日期排列 endArr[1] = parseInt(endArr[1]) - 1 + '' let begin = new Date(...beginArr) //将日期格式转换为标准格式 let end = new Date(...endArr) let days = [] while ((end.getTime() - begin.getTime()) &gt;= 0) &#123; let year = begin.getFullYear() //获取起始日期的年月日 let month = (begin.getMonth() + 1).toString() //月份重新加1输出 if (month.length === 1) month = '0' + month let day = begin.getDate().toString() if (day.length === 1) day = '0' + day days.push(year + '-' + month + '-' + day) begin.setDate(begin.getDate() + 1) //setDate()方法是将当前日期的日设置为指定的1~31，同理有setMonth、setYear等方法 &#125; return days&#125; vue中利用axios封装Promise请求对象12345678910function requestLoginon(params) &#123; let instance = axios.create(&#123; headers: &#123; "X-Service-Id": "", "X-Service-Method": "", "Content-Type": "application/json" &#125; &#125;) return instance.post(`$&#123;base&#125;/pcn-core/login`, params).then(res =&gt; res.data)&#125; 通过身份证获取生日1234567891011121314function getBirthdayByIdNo(idNo) &#123; iIdNo = idNo.trim() let tmpStr = "" if (iIdNo.length === 15) &#123; tmpStr = iIdNo.substring(6, 12) tmpStr = "19" + tmpStr tmpStr = tmpStr.substring(0, 4) + "-" + tmpStr.substring(4, 6) + "-" + tmpStr.substring(6) &#125; if (iIdNo.length === 18) &#123; tmpStr = iIdNo.substring(6, 14) tmpStr = tmpStr.substring(0, 4) + "-" + tmpStr.substring(4, 6) + "-" + tmpStr.substring(6) &#125; return tmpStr&#125; 通过身份证获取性别123456789101112function getSexCodeByIdNo(idNo) &#123; iIdNo = idNo.trim() let tmpStr = "" if (iIdNo.length === 15) &#123; tmpStr = iIdNo.substring(14) &#125; if (iIdNo.length === 18) &#123; tmpStr = iIdNo.substring(16, 17) &#125; if (tmpStr) return return parseInt(tmpStr) % 2 === 0 ? 2 : 1&#125; 时间格式化12345678910function formatDate(timestamp) &#123; let d = timestamp ? new Date(timestamp) : new Date() let year = d.getFullYear() let month = d.getMonth() + 1 let date = d.getDate() let hour = d.getHours() let minute = d.getMinutes() let second = d.getSeconds() return year + "-" + (month &lt; 10 ? '0' + month : month) + "-" + (date &lt; 10 ? '0' + date : date)&#125; 移动端获取当前操作系统及浏览器信息跳转下载app地址1234567891011121314151617181920212223242526function appDownload(appleUrl, androidUrl) &#123; let ua = navigator.userAgent let browserInfo = function() &#123; //获取移动终端浏览器版本信息 return &#123; trident: ua.indexOf('Trident') &gt; -1, //IE内核 presto: ua.indexOf('Presto') &gt; -1, //opera内核 webKit: ua.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: ua.indexOf('Gecko') &gt; -1 &amp;&amp; ua.indexOf('KHTML') == -1, //火狐内核 mobile: !!ua.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!ua.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: ua.indexOf('Android') &gt; -1 || ua.indexOf('Linux') &gt; -1, //android终端或uc浏览器 iPhone: ua.indexOf('iPhone') &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: ua.indexOf('iPad') &gt; -1, //是否iPad webApp: ua.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125; &#125;() if (ua.toLowerCase().match(/MicroMessenger/i) == "micromessenger") &#123; document.write("&lt;img src='../../static/download_default.png' alt='点击右上角打开默认浏览器下载' width='100%'/&gt;") &#125; else if (browserInfo.ios || browserInfo.iPhone || browserInfo.iPad) &#123; window.location.href = appleUrl //跳转苹果市场 &#125; else &#123; window.location.href = androidUrl //跳转安卓市场 &#125; return&#125; 产生随机长度字符串12345678910111213141516171819202122232425// 第一种方式function randomStr(length) &#123; length = parseInt(length, 10) || 6 if (length &lt;= 6) &#123; return Math.random().toString(36).slice(2, length + 2) &#125; else &#123; let str = '' for (let i = 0; i &lt; Math.ceil(length / 6); i++) &#123; str += Math.random().toString(36).slice(2, 8) &#125; return str.slice(0, length) &#125;&#125;// 第二种常规方式function randomStr2(len) &#123; len = parseInt(len, 10) || 32 let chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678' /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ let str = '' for (i = 0; i &lt; len; i++) &#123; str += chars[Math.floor(Math.random() * chars.length]) &#125; return str&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由传参加密]]></title>
    <url>%2F2017%2F09%2F22%2Fvue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[vue单页面应用 + vue-router的特性，以及组件间的通讯需求，造就前端路由传参这一可期性。但路由传参由于参数的低安全性容易被随意篡改，从而轻易暴露用户隐私，因此对参数进行适当加密且不影响性能就成了另一个需求。本文列出一种对称加密算法对路由传参进行序列化加密供参考。 第一步 第二步 第三步 第四步 最后路由传参有个优势在于如果安卓或者ios端需要调用页面的时候可以入参，并且路由传参的页面强制刷新不会造成页面数据丢失，后期如果有这种需求可以考虑采用路由传参。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全]]></title>
    <url>%2F2017%2F08%2F11%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[常见的前端安全问题有XSS、CSRF、cookies、点击劫持、SQL注入、流量攻击等，以下简单的记录学习过程中的笔记与要点。 一、XSSxss跨站攻击类型有：反射型：URL参数直接注入(可通过短网址等方式进行url转换，从而更加隐秘)存储型：存储数据到DB时读取注入，危害更大 xss攻击注入点：1、html节点内容(即利用了innerHTML插入执行的脚本)2、html属性(利用src属性，或者图片的onerror属性)3、javascript代码4、富文本的本质就是一段复杂的html代码，这样才得以保留富文本的格式。当富文本保存到DB时保存的即该html代码。当存在html时会存在xss攻击风险。 防御措施：1、浏览器自带防御(针对反射型，且只能防御html节点内容及属性，针对JavaScript代码无法防御) 2、针对html节点内容，转义&lt;&gt;1234let escapeHtml = function(str) &#123; str = str.replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;') return str&#125; 3、针对html属性，转义””1234567let escapeHtmlProperty = function(str) &#123;if(!str) return ''str = str.replace(/"/g,'&amp;quto;')str = str.replace(/'/g,'&amp;#39;')str = str.replace(/ /g,'&amp;#32;')return str&#125; 以上两个函数合并成一个：123456789let escapeHtml = function(str) &#123; if(!str) return '' str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g,'&amp;quto;') str = str.replace(/'/g,'&amp;#39;') //str = str.replace(/ /g,'&amp;#32;') 按html标准书写代码，该处可以不对空格进行转义 return str&#125; 4、针对js的转义(注意html转义与js代码转义不一样)123456let escapeForjs = function(str) &#123; if(!str) return '' str = str.replace(/\\/g,'\\\\') str = str.replace(/"/g,'\\"') return str&#125; 上面的转义函数可以防御大部分js代码注入，但还不是很安全，最保险的方式是直接将用户输入的代码用JSON.stringify格式化，再原封返回即可。 5、富文本的输入一般在输入数据库之前进行过滤5.1、黑名单过滤的方式(比较繁琐)1234567let xssFilter = function(html) &#123; if(!html) return '' html = html.replace(/&lt;\s*\/?script\s*&gt;/g,'') html.replace(/javascript:[^'"]*/g,'') ... return html&#125; 5.2、白名单过滤的方式(只保留部分标签与属性，比较保险)介绍一个cheerio库进行解析dom还可以直接利用第三方库–js-xss6、CSP(content-security-policy设置，可查看MDN) 二、CSRFCSRF跨站请求伪造原理：1.用户登录A网站2.A网站确认身份信息3.B网站页面向A网站发起请求(带A网站身份信息)…特征：B网站向A网站发起请求带A网站的cookies不访问A网站的前端referer指向B网站…危害：利用了用户登录态用户不知情完成业务请求防御：1.在服务器返回的cookies中将samesite属性设置为strict，这样只有同域网站才能获取到cookies(但是该属性目前只有在谷歌浏览器中支持)2.向服务器提交信息的时候需要前端A网站的验证信息，比如验证码，token等(nodejs中ccp插件用于提供图形验证码)3.利用前后端匹配token值(前端可以通过在input输入框中隐藏直接提交或者通过将token值保存到meta标签中)，从而判断是否来自正规的A网站的请求4.验证referer，禁止第三方网站请求1/^https?:\/\/localhost/.test(request.header.referer) 三、cookies特性1、只能使用自己域名下的cookies2、有效期3、设置URL上的层级有效4、http-only只允许请求或者接受的时候读取，不允许document.cookie读取5、secure只允许在https中获取6、sameSite7、删除的方式只能通过设置有效期为过去式cookies作用1.存储个性化设置2.存储未登录时用户的唯一标识3.存储已经登录的用户凭证4.存储其他业务数据cookies-登录用户凭证的使用方式：1.用户ID + 后台签名(服务器通过sha2等方式对用户ID进行算法加密之后连着用户ID及签名字符串一块通过cookies返回到前端，当前端提交请求时将该cookies一并提交，后台再计算用户ID进行校验)2.sessionId(用户初次登录成功的时候服务器根据用户ID匹配生成一个sessionId返回给到前端cookies中，之后前端每次请求将带着该sessionId与后台服务器缓存或者数据库中进行匹配获取到对应的用户信息)cookis的安全策略有：1.使用签名防止篡改2.对用户ID进行加密(避免明文显示)3.设置http-only(防止XSS盗用cookies)4.设置secure(只允许https获取cookies)5.设置same-site(防止CSRF利用用户的登录态) 四、点击劫持用户不知情情况下亲手点击(将实际真实的A网站通过iframe嵌入到B网站中，并设置opacity为0，在用户看不到的情况下诱导用户点击B网站上的信息，实则已点击了透明的A网站)防御方法：1.通过JavaScript脚本禁止内嵌(通过判断top.location == window.location)2.X-FRAME-OPTIONS禁止内嵌(通过在相应头header中设置X-Frame-Options属性值为DENY即可禁止该网站被内嵌)，该方法各浏览器兼容很好，推荐使用 五、httpshttp传输窃听篡改(traceroute/window下tracert可以查看网站访问背后的链路节点(各种代理转发)，任何一个节点都可以查看http的明文内容)https原理在浏览器端用SSL(也叫TLS)进行加密之后在链路节点间用密文传输，到达服务器之后再按规则进行明文转换 六、密码-哈希算法1.明文-密文 == 一一对应2.雪崩效应，只要明文有一个差异，整个密文都会不一样3.密文-明文无法反推4.密文固定长度常用的哈希算法：md5、sha1、sha256等单向变换可以通过彩虹表(彩虹表罗列多种密码组合，然后通过查询密文获取对应的明文)进行查询，如果要对抗彩虹表防止密码轻易在彩虹表中被查询到，可以增加密码长度及复杂度，甚至通过多重md5加密，如md5(md5(codecodecode…))，md5(sha1(codecodecode…))等帮用户密码加盐 七、SQL注入防御1.关闭错误输出2.入参时检查数据类型3.对入参数据进行转义4.使用参数化查询(更有保障)5.使用ORM(对象关系映射) 八、流量攻击服务器大规模流量攻击(很难防御)1.TCP半连接2.Http连接3.DNS(解析域名服务器)4.大规模DDOS攻击防御1.防火墙2.交换机、路由器3.流量清洗4.高防IP(云服务厂商重指向到高防IP进行流量清洗)预防1.避免重逻辑业务2.快速失败快速返回3.防雪崩机制4.有损服务5.CDN(静态请求,减轻服务器压力) 九、总结1.简述XSS原理来自用户输入的数据被当做脚本程序被执行，主要包括2.简述XSS防御方法浏览器内置方法对数据进行适当转义&lt;&gt;”‘&amp;对富文本设置白名单CSP指定哪些内容可以被执行哪些不被执行3.XSS防御需要注意的点转义的时候需要注意使用的场景与范围4.CSRF的原理盗用用户登录态，携带cookies对目标网站发起请求5.CSRF危害在用户不知情情况下盗用用户身份6.如何防御same-site规定只允许指定网站访问带验证码或token判断referer7.cookies的作用浏览器存储数据，用户个性化设置、登录标识、身份识别8.cookies与localStorage最大区别是cookies在范围网站时可以自动携带，而storage不可以9.cookies与session关系：服务端产生sessionId通过cookies存在到浏览器中10.cookies具有：无法跨域、存在path层级、有效期、http-only无法通过js读取、secure、same-site等特性，cookies只能通过设置过期时间才能进行删除]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常开发笔记]]></title>
    <url>%2F2017%2F07%2F14%2F%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[收集整理日常开发中的雷区以及可汲取之处，以期日后回望，并不定期更新。 1. npm build的时候需在配置路由中添加”/“根路由，这样在打开index.html的时候默认才是在根路由下。 2. 通过绝对位置进行定位的元素设置垂直居中的方法： 1234position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%); 3. arrow小箭头纯css代码： 1234567891011position: absolute; border: 2.5px solid #fff; border-top: 0; border-left: 0; content: " "; top: 50%; right: -15px; width: .1rem; height: .1rem; -webkit-transform: translateY(-50%) rotate(45deg); transform: translateY(-50%) rotate(45deg); 4. index.html页面中引入html/body两个元素的media query样式，用于适配不同屏幕下元素大小，之后在以其为根元素在其页面内使用rem单位进行样式设置,或者可以通过动态在mounted钩子中设置html元素的font-size。 5. vue组件中可定制图片体积大小上限，从而决定是否将其转换为base64格式文件直接保存在js代码中，从而减少网络请求。 6. 对于v-for渲染出来的列表，可以对其id属性绑定传值，通过e.target.id或者e.currentTarget.id(两个区别在于前者识别的是点击元素，后者识别的是绑定点击事件的元素)获取到该值。 7. 常见的图标类可以通过icomoon在线转换为字体图标，通过引入css及font字体即可在相关标签中加入className，对className设置font-size属性及color属性可对改变其大小与颜色。 8. mint-ui引入之后，在组件中如果设置了scoped，则在该组件的局部样式中无法对UI组件进行修改，解决方案可以通过对vue组件最外层div设置class或者id，然后通过该唯一class或者id包裹组件内部元素的样式。 9. v-show与v-if区别在v-show不满足条件的情况下还会渲染相应的内容但不显示，而v-if如果不满足条件即不渲染且隐藏。 10. vue文件夹不允许使用中文命名，否则无法进行热重载。 11. css写点击选中打钩样式： 12345678910111213141516171819202122232425262728293031323334.icon &#123; display: inline-block; background-color: #fff; border-radius: 100%; border: 1px solid #ccc; position: relative; width: 20px; height: 20px; vertical-align: middle;&#125;.icon:after &#123; border: 2px solid transparent; border-left: 0; border-top: 0; content: " "; top: 3px; left: 6px; position: absolute; width: 4px; height: 8px; -webkit-transform: rotate(45deg) scale(0); transform: rotate(45deg) scale(0); -webkit-transition: -webkit-transform .2s; transition: -webkit-transform .2s; transition: transform .2s; transition: transform .2s,-webkit-transform .2s; border-color: #fff; -webkit-transform: rotate(45deg) scale(1); transform: rotate(45deg) scale(1);&#125; .icon.checked &#123; //点击之后添加上checked类名即可 background-color: #26a2ff; border-color: #26a2ff;&#125; 12. 空对象（包括数组）无法直接判断是否为假值！可通过Object.keys(obj).length或者JSON.stringify(obj) === ‘{}’进行判断。 13. 当ref在标准标签中时代表获取该DOM元素，当ref在子组件时，则代表获取该组件，包括了该组件的id、class以及方法等。可以通过this.$refs.refName.method调用子组件的方法。但是当ref与v-for结合使用时，this.$refs.refName获取到的是一个数组，此时可通过制定数组元素调用指定子组件的方法。 14. nextTick方法主要是针对vue的虚拟DOM异步执行更新的方式创造的，虚拟DOM具有缓冲作用，不会时时更新，只有当一个函数执行完毕之后再统一进行DOM更新。因此，在数据更新之后使用nextTick回调函数可以在DOM统一更新之后调用执行。 15. 背景图全撑开样式设置： 12345.bg &#123; background: url('../../assets/img/zbl_ceshibg.png') no-repeat; background-size: 100% 100%; height: 4.7rem;&#125; 16. input元素的focus、blur事件无法进行代理执行，只能在目标元素上进行响应。(委托代理无法实现) 17. 小程序中bindtap与catchtap两种点击事件的区别:bindtap事件发生过程通过捕获阶段进入到目标阶段获取目标target元素，之后执行从里往外冒泡，从而有机会在冒泡阶段执行到父节点绑定的事件，绑定事件的元素可通过currentTarget获得。catchtap事件发生过程只经历了捕获阶段到目标阶段target元素，阻止了冒泡行为。 18. 小程序中navigateTo方法缓存当前页面（不关闭）并打开新的页面，redirectTo方法关闭当前页面并打开新的页面，navigateBack方法直接跳转回未关闭的页面，可多级进行跳转，但该方法没办法进行路由传参。 19. 字符串的slice、substring、substr三个方法区别：slice(a,b)截取两个参数从小到大之间的字段，可传负数(负数加上字符串长度即为截取的索引，也可以直接从尾倒数回来，-1代表最后一位，以此类推)；substring(a,b)截取两个参数从小到大之间的字段，但传入的负数将被强行转换为0；substr(a,n)第一位参数表示截取开始的索引(可为负数)，第二位参数表示截取的字符串长度(负数将转换为0)。 1234567var stringValue = “hello world”;alert(stringValue.slice(-3)); //"rld"alert(stringValue.substring(-3)); //"hello world"alert(stringValue.substr(-3)); //"rld"alert(stringValue.slice(3,-4)); //"lo w"alert(stringValue.substring(3,-4)); //"hel"alert(stringValue.substr(3,-4)); //""(空字符串) 20. 区别：双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了,多了1个div，少用大致4个css属性（圣杯布局中间div的padding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4），双飞翼由此相对简洁一些。现在主要以flex进行布局。 21. 项目可优化部分有：下拉刷新、页面切换过渡效果、禁用微信浏览器访问页面存在下拉漏出黑色区域、多请求并发优化问题。 22. vue组件传值的几种方式：1.props down event up的父子组件通信2.路由传参(关键参数需要加密)3.vuex状态管理4.event bus注册全局事件5.sessionStorage存储 23. 产生随机长度字符串：12345678910111213141516171819202122232425// 第一种方式let randomStr = (length) =&gt; &#123; length = parseInt(length, 10) || 6 if (length &lt;= 6) &#123; return Math.random().toString(36).slice(2, length + 2) &#125; else &#123; let str = '' for (let i = 0; i &lt; Math.ceil(length / 6); i++) &#123; str += Math.random().toString(36).slice(2, 8) &#125; return str.slice(0, length) &#125; &#125; let len = Math.random() * 100 randomStr(len)// 第二种常规方式let randomStr2 = (len) =&gt; &#123; len = parseInt(len, 10) || 32 let chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678' /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ let str = '' for (i = 0; i &lt; len; i++) &#123; str += chars[Math.floor(Math.random() * chars.length]) &#125; return str&#125; 24. 清空一个数组的方式：12341、let one = [1,3,5]one.length = 0 //one =&gt; []2、let two = [2,4,6]two.splice(0) //two =&gt; []，利用了splice会改变原数组的方法，splice方法返回被删除元素组成的一个新数组 25. ES6中的let关键字本质上是对闭包的一个封装，从而影响其作用域。 26. 产生当前毫秒的时间戳的方法：new Date().getTime() === new Date().valueOf() //true 27. babel-runtime: es语法做转义； fastclick: 解决移动端点击300毫秒延时问题； babel-polyfill：主要针对es6的promise等补丁。 28. 父元素清除浮动坍塌12345678910111213 .clearfix:after &#123; content: ' '; display: block; height: 0; visibility: hidden; clear: both;&#125;=&gt;等价于 (BFC的原理).clearfix:after &#123; content: ' '; display: table; clear: both;&#125; 29. 多个li元素设置为inline-block之后，元素之间会存在几个px的间隙，通过在其ul元素上设置font-size: 0可以解决这个问题。 30. box-sizing: border-box的作用是将padding的值往设定好的元素高度内部挤，而不会往外延伸影响到元素整体高度的计算。 31. rem不兼容IE8及以下浏览器，flex不兼容IE9及以下浏览器。 32. 一个原型及原型链的栗子1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;原型链栗子&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="aaa"&gt;aaa&lt;/div&gt; &lt;div id='bbb'&gt;bbb&lt;/div&gt;&lt;/body&gt;&lt;script&gt; function $(classOrId) &#123; this.Ele = document.querySelector(classOrId) &#125; $.prototype.html = function(value) &#123; let ele = this.Ele if (!value) &#123; return ele.innerHTML &#125; else &#123; ele.innerHTML = value return this &#125; &#125; $.prototype.on = function(type, fn) &#123; let ele = this.Ele ele.addEventListener(type, fn) return this &#125; let elementa = new $('.aaa') elementa.on('click', () =&gt; &#123; console.log(this) //window &#125;) let elementb = new $('#bbb') elementb.on('mouseover', function() &#123; console.log('mouseover') &#125;).html('666')&lt;/script&gt;&lt;/html&gt; 33. https 34. vue路由跳转间的登录态判断 35. 预设式的响应式设置1234&lt;img src='img/480.png' srcset='img/480.png 480w, img/800.png 800w, img/1200.png, 1200w' size='(min-width:800px) calc(100vw - 2rem), 100vw'/&gt; //size默认值是不带查询条件的100vw，如果存在多个查询条件，可以通过逗号隔开 //浏览器从小尺寸变为大尺寸时会依据带宽、dpi值、像素比等综合因素自动切换图片大小，当浏览器从大尺寸变回小尺寸时图片将仍然保留大尺寸时的图片，因为此时该图片已缓存。12345678//多组条件响应图片，目前IE浏览器均不支持，高级浏览器才支持，可通过引入picturefill第三方补丁库进行打补支持。&lt;picture&gt; &lt;source media='(max-width: 800px)' srcset='img/a.png 600w' /&gt; &lt;source srcset='img/a-default.png 1200w' /&gt; &lt;source type='image/svg+xml' srcset='logo.svg 480w' /&gt; &lt;source type='image/webp' srcset='logo.webp 480w, logo-m.webp 800w, logo-l.webp 1200w' /&gt; &lt;img src='img/a.png' /&gt; //默认显示&lt;/picture&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的2种跨域请求方式]]></title>
    <url>%2F2017%2F06%2F10%2Fjsonp%E7%9A%842%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JSON和JSONP虽然只有一个字母的差别，但其实两者根本不是一回事：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。本文主要介绍下常用的jsonp跨域请求方式传输JSON格式数据以及jsonp与ajax的区别。 先解释下JSONP的由来： 1、因为浏览器的安全机制，只要请求资源与当前页面地址的域名或端口号不一致，那么ajax发送的数据请求皆会存在跨域无权限访问的问题，不管是静态页面、动态网页、web服务资源，都访问不了。 2、我们都知道凡带有”src”属性的标签都拥有跨域的能力，常见的标签如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;，加上Web页面上只要能获取js脚本文件即可调用或执行，不受跨域影响。 3、于是，推演出了一种称作JSONP的非正式传输协议，该协议的要点就是允许用户传递一个callback参数给服务端，然后服务端通过该callback参数作为函数名包装JSON数据，然后返回数据给到客户端，客户端提供一个自定义回调函数进行数据处理。 4、这种获取远程数据的方式看起来很像ajax，但ajax和jsonp两者本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签调用服务器提供的js脚本。ajax与jsonp的区别并不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。所以两者最大的区别还是在于获取服务器数据的行为方式上的不一样。 基于以上几点，本文介绍jsonp跨域发送数据请求常用的2种方法，虽然写法上不同，但实质上都是一致的，只是jq在ajax中对其进行了封装，但注意ajax与jsonp没有实质关系。 本文以百度搜索提供的一个支持JSONP请求的API接口进行发送请求，地址为：http://suggestion.baidu.com/su?wd=#content#&amp;cb=callback (#content#为搜索关键词) 一、原生js实现12345678910111213141516171819// 定义一个数组，发送多次请求 let arr = ['苹果', 'apple', 'fruit', '我爱苹果'], headEle = document.querySelector('head'), resultArr = [] arr.forEach(val =&gt; &#123; let scriptEle = document.createElement('script') let url = `http://suggestion.baidu.com/su?wd=$&#123;val&#125;&amp;cb=callback` // ES6的反引号写法 // 注意！上面的`cb`为百度定义的格式，不可以更改！！！ scriptEle.src = encodeURI(url) // encodeURI为js原生的中文url编码方法 headEle.appendChild(scriptEle) headEle.removeChild(headEle.querySelector('script')) // 先添加再移除 &#125;) function callback(data) &#123; // 回调函数调用接受响应数据 resultArr.push(data.s) // 's'属性是返回json数据中的属性 if (resultArr.length === arr.length) console.log(resultArr) // 输出包含4个数组元素的一个数组 &#125; 二、使用JQuery封装实现12345678910111213141516171819202122&lt;script src='http://code.jquery.com/jquery-latest.js'&gt;&lt;/script&gt; let arr = ['苹果', 'apple', 'fruit', '我爱苹果'], resultArr = [] arr.forEach(val =&gt; &#123; let url = `http://suggestion.baidu.com/su?wd=$&#123;val&#125;` $.ajax(&#123; type: 'get', url: encodeURI(url), // 指定此请求为jsonp请求，响应返回的数据格式即为jsonp格式 dataType: 'jsonp', jsonp: 'cb', success: function(data) &#123; resultArr.push(data.s) if (resultArr.length === arr.length) console.log(resultArr) &#125;, error: function(err) &#123; console.log(err) &#125; &#125;) &#125;) 注意点： json格式的数据结构长这样: {‘a’:’apple’,’b’:’banana’}，而jsonp格式的数据结构长这样: callback({‘a’:’apple’,’b’:’banana’})，由上面的定义知道，发送jsonp请求需要服务器返回一个callback参数作为函数名包装的JSON数据，所以如果服务器没有设定允许返回jsonp格式的数据，那么我们是无法完成jsonp跨域请求的，哪怕强制在url地址上加了”&amp;callback=handleCallbackFunction”,服务器返回的数据还是json数据，无法被客户端定义的回调函数获取，下面这个url地址就无法进行jsonp请求，有兴趣的可以将上面代码中的url换成这个试一试。替换url：1`http://api.tmkoo.com/search.php?keyword=$&#123;val&#125;&amp;apiKey=4399320012393234&amp;apiPassword=331nd3342d&amp;pageSize=30&amp;pageNo=1` 解决方案由后端发起http跨域请求，以nodejs为例，引入request模块，关键代码如下：1234567891011121314const express = require('express')const request = require('request')const app = express()let url = `http://api.tmkoo.com/search.php?keyword=$&#123;val&#125;&amp;apiKey=4399320012393234&amp;apiPassword=331nd3342d&amp;pageSize=30&amp;pageNo=1`request(encodeURI(url), (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body) //body中即可获得返回的json数据 &#125;&#125;)app.listen(8888, () =&gt; &#123; console.log('started...')&#125;)]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回到原点]]></title>
    <url>%2F2017%2F06%2F07%2F%E5%9B%9E%E5%88%B0%E5%8E%9F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[今天全国高考，回想2011年我的高考作文命题——回到原点，思绪有些复杂。今天我再一次高考，交上这篇800字文章，谨记过往，不忘原点，从心出发。 2011年6月7号早上9点01分，我拿到语文卷的命题作文——回到原点。跟大多数人一样，夹杂着紧张与惊喜，我当时脑子里的第一反应就是诸如“最初的梦想”，“不忘初心，砥砺前行”，“又回到最初的起点，记忆中你青涩的脸…”这样的关键词，其实这跟“回到原点”还是有些差别。 回到原点，其实讲的是田径场上一圈下来由起点回到原点的意思，放远点讲就是一个由土生向尘亡的轮回归属。古希腊赫拉克利特说，“一双脚永远不可能踏进同一条河流”，因为时间会韶逝，空间会易转，你永远也找不到两片同样的树叶。花开复花落，潮涨既潮退，云卷亦云舒。一个圆规画圆，两只脚由始再到原，转到的那个原点永远不会是同一个点，那我们为什么还要回到原点？ 回想一下，我们是否经常耳荡“如果让我再年轻十年”,“如果再给我一个大学”，“如果再给我一个机会”…种种如果，皆为原点，皆为重塑。我们常说梦想还是要有的，万一实现了，可梦想何来？真的是某天白日做梦想想就来，还是跋山涉水之后醍醐灌顶，东风自然来？没错，回到原点，就是要重新审视最初的梦想与现实历经之间的矛盾，也是重整旗鼓韬光养晦的契约。一次踏进冰河并不可怕，但如果两次三次踏进“同一条”河流，那么这个原点将越描越黑。 回到原点，其实就是在面对各种洗礼之后重新面临选择。生命之流汩汩，总有九十九式的桥需要去回眸，有青葱绿石的，有古典端庄的，有陆离斑驳的…走一遭，到东吴，择一桥，回西蜀。不管择与否，主动的随流的，浪淘尽之后，回归原点，还得再次选择。当然，只要有选择总是有机会成本的，成本公式就是πr²。走的时间越远路子越长，圆饼就越大，当再次回到圆点面临选择时，能易志甚至舍弃的代价就越高。所以生命洪流，需要时时省思脚下船，船到桥头虽直，可怕一条暗道直流到黑，适时需要登桥眺望，择善流行。 2017年2月6号，依昔记得是大年初八，一个背包的独行客，走到起点般的原点。昨日6月6号，刚好满四月。四个月的朝七晚九，四个月的独往孤来，四个月的点滴获取，四个月的日行一小时，满满当当。如今重赴原点，从心出发。 好了，匆匆一瞥，已然神游，开卷啦，原点常在，期待大家都能给各自生活交上一份满意的答卷。 林龙儿2017/06/07•广州]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2 开发"饿了么"项目的一些总结]]></title>
    <url>%2F2017%2F06%2F01%2Fvue2%E5%BC%80%E5%8F%91%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近一段时间探索着运用vue2开发一个饿了么的开源项目，纵观网上大部分资料只介绍了前端单页面的开发过程，并没有涉及到后端及数据库部分。本项目以前端SPA的开发为主，并针对前端到后端服务器的逻辑层进行编写。css部分直接引用了网上开源的代码，未重点关注。本文记录开发过程中踩过的坑以及一些注意点，供大家参考。 本项目开发过程中使用到的技术栈 vue-cli + vue-router + axios + vue2 + vuex + Express + MongoDB + mongoose + webpack2 + ES6 使用vue-cli脚手架快速搭建项目结构通过vue自带的vue-cli工具，可以快速的创建一个项目结构，我们只需在src中进行源码编写即可，其他大部分工作cli工具都已经帮我们生成。本项目的目录结构说明如下： 使用vue-router实现SPAvue-router的基本思想是在主页面中引入标签，然后定义路由，通过&lt;router-link&gt;&lt;/router-link&gt;把router挂在到app上，并把各个子页面渲染到&lt;router-view&gt;&lt;/router-view&gt;里面。通过vue-router创建一个实例对象并进行路径配置，即可轻易实现前端路由的切换，本项目主要实现在一个单页面上进行3个子页面间的切换动作，图示红色区域即为典型的单页面路由功能。 使用axios进行后台数据请求运用axios插件的优势在于支持ES6的Promise特性，通过.then() .catch()的方式很方便的对响应结果进行处理。在引入axios的时候需要注意一点，要么可以直接将axios挂载到全局Vue的prototype原型链上，这样所有的vue实例均可直接通过this.$axios.get()…调用，要么通过import方法在需要使用axios的地方引入，然后直接axios.get()…调用，但注意这里并不需要加上vue.use(axios)，因为axios就是一个纯粹的第三方插件，引入之后即可直接使用。axios的使用方法如下：123456this.$axios.get('/api/seller').then(res =&gt; &#123; //this.$axios的用法前提是将axios挂载到Vue的原型上，否则需要使用import引入axios的方法 this.seller = JSON.parse(JSON.stringify(res.data)) &#125;).catch(err =&gt; &#123; console.log(err) &#125;) 另外还需要注意一点，这里因为涉及到前后端服务器不同端口号的跨域请求问题，需要在vue-cli生成的目录中找到config文件夹下的index.js文件，在proxyTable属性中添加上如下代码，从而在本地重新启动一个新的服务器进行代理。12345678910proxyTable: &#123; //配置跨域请求参数 '/api': &#123; target: 'http://localhost:3000/', //本地'localhost:8080/api'的地址将被代理为'http://localhost:3000/' changeOrigin: true, pathRewrite: &#123; '/api': '' // '/api'将被替换为''(空) &#125; &#125; &#125; 基于vue2搭建前端架构Vue.set()开发商品数量模块的时候，使用了一个Vue.set()或者vm.$set()方法，该方法可响应式的给对象添加一个属性，并触发view视图更新。如果只是简单的使用 Object.assign() 或 extend() 添加属性,无法响应视图更新。在该模块中通过给一个商品动态附上一个数量属性还有一个明显的优势，就是该属性在任意的父组件或子组件间进行值的更改之后，其他的引用组件都会响应更改，”一动而牵全身”，因为他们引用的是同一片内存地址。本项目中共有3个地方引用到该属性，分别是商品显示页、商品详情页、购物车详情页。12345678addCart(event) &#123; if (!this.food.count) &#123; Vue.set(this.food, 'count', 1) //强制赋予food一个新的属性，并监听该数据 &#125; else &#123; this.food.count++ &#125;&#125; better-scroll项目中要实现移动端滑动，所以引入了一个”better-scroll”插件，该插件虽然简单的几个配置之后即可达到滑动效果，但是它的创建时机相当重要，因为它的创建需要依据滚动元素的css布局进行计算，所以如果在数据尚未取得并渲染之后创建，最终将得不到滑动效果。基于这一点，推荐结合vue提供的nextTick()方法(nextTick是vue中一个类似setTimeout的方法)，在下一次DOM更新之后进行计算，并且在每次数据更新(DOM结构树发生变动)之后调用refresh()方法重计算，必要时可通过watch属性监听变动数据实时refresh，否则将会出现滚动误差。该插件的引入一般在mounted钩子函数中引入,但是如果是通过axios发送请求，因为请求是异步的，需要等待服务器响应，所以可能会出现数据尚未回来，但mounted已挂载的情况，所以这时候该插件的引入就需要放在axios的回调函数中去执行了。123456789mounted() &#123; this.$nextTick(() =&gt; &#123; //nextTick方法相当于setTimeout定时器，用于处理异步回调问题 this.scroll = new BScroll(this.$refs.ratings, &#123; click: true, bounceTime: 300 &#125;) &#125;)&#125; 子组件的多重引用在设置子组件的时候，需要给子组件绑定多少个变量，多少个方法，这是个宏观问题。可能这个地方引用需要2个变量，另一个地方引用该组件需要4个变量，同时2个地方的引用需要的方法也各不同，那这时候就要考虑该组件的可复用性，重新进行变量和方法设定，或者尽可能减少变量和方法数量的绑定，提高可复用性。这一点在我重写评价筛选方法的时候代码的冗长，难以复用性，就是个很大的坑。 vuex数据统一访问接口在项目中多个地方引用了这行数据classMap: [&#39;decrease&#39;, &#39;discount&#39;, &#39;special&#39;, &#39;invoice&#39;, &#39;guarantee&#39;]，会出现的很大问题是，如果项目中需要对该数据进行增删，那每一个引用的地方都要相应找出来并进行修改，当引用的数量多了之后，那就麻烦大了。好在vue中有一个vuex插件，有个state”中间仓库”概念，它负责保存关键的数据状态，所有的组件只可mapGetter到这个数据并在mutations中操作数据，不可能直接更改，这样如果需要改动数据，只要改动state中的数据，其他引用的组件将跟着发生改变。本项目中将该组数据单独放在state中，共有3个子组件引用了该数据，子组件可通过this.$store.state.classMap方式访问到该数据。注册store的方式如下：123456789import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; classMap: ['decrease', 'discount', 'special', 'invoice', 'guarantee'] &#125;&#125;) export与importES6中export与import 有4种常用的使用方式：1、export的时候将需要导出的变量用一个{}包装起来，然后在import的时候相对应用{}引入该变量；12345let exportVar = 'have a nice day!', fooexport &#123;exportVar,foo&#125; //导出,也可以通过as将foo名字改为bar再导出import &#123;exportVar,foo&#125; from '...' //导入console.log(exportVar) 2、这种方式是直接在export后面定义要导出的函数或变量；123export let foo = () =&gt; &#123;console.log("fnFoo")&#125;, bar = "stringBar" //导出import &#123;foo, bar&#125; from "..." //导入console.log(foo()) 3、这种导出方式不需要知道变量的名字，相当于匿名，直接将开发接口给export，如果一个js模块文件只有一个功能，可以使用export default默认导出，在引入之后可以将default变量名随意更改，这也是本项目中使用最多的一种方式；12export default &#123;&#125; //导出import someName from "..." //导入 4、整体导出导入，导出文件中有多个export；12345678export function getName() &#123; //导出 console.log('name')&#125;export function getAge()&#123; //导出 console.log('age')&#125;import * as someName form '....' //导入console.log(someName.getName()) 使用Express搭建后台服务器这里主要使用node.js中比较优秀的express框架快速搭建一个服务器，释放可访问端口号及暴露的文件路径，并且提供http访问接口，express还可以使用各种中间件对请求及相应前后的数据进行中间操作，可扩展性很强大。本项目以前端为主，express只是简单提供3个请求接口，并对接数据库返回请求资源。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const express = require('express')const path = require('path')const app = express()app.get('/seller', (req, res, next) =&gt; &#123; //多个回调 console.log('访问了seller数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].seller) &#125; &#125;)&#125;)app.get('/ratings', (req, res, next) =&gt; &#123; console.log('访问了ratings数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].ratings) &#125; &#125;)&#125;)app.get('/goods', (req, res, next) =&gt; &#123; console.log('访问了goods数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].goods) &#125; &#125;)&#125;)app.set('port', process.env.PORT || 3000)app.use(express.static(path.join(__dirname, '.'))) //托管静态资源app.listen(app.get('port'), () =&gt; &#123; console.log('Express server listening on port ' + app.get('port'))&#125;) 使用MongoDB数据库储存数据使用MongoDB数据库的原因是因为饿了么开源项目提供的数据为json数据类型，可以直接导入使用，而且MongoDB非SQL型数据库具有更加灵活的操作性。 使用mongoose操作数据库mongoose是一个针对MongoDB操作的第三方插件，该插件封装了很多原生的操作指令，使得通过mongoose的操作更加简洁高效。另外项目中还通过Robomongo这个可视化的数据库GUI进行数据导入，可省去在shell窗口中敲送指令并提供更良好的数据展示。数据库的创建关键代码如下： 123456789101112const mongoose = require('mongoose')mongoose.connect('mongodb://localhost:27017/elemeDB')const schema = mongoose.Schemaconst aModel = new schema(&#123; //定义数据类型 seller: Object, goods: Array, ratings: Array&#125;)const MDL = mongoose.model('elemes', aModel) //创建或连接到指定集合// 本项目只针对数据查询，未涉及insert、update、remove等操作 使用webpack2打包项目webpack主要是在项目完成开发之后，进行的一种代码打包动作，它可以将项目主页中使用到的链接、资源等进行加载注入并进行一定的编码操作。webpack2与webpack1略微不同，webpack2最主要的有以下4个属性： entry：指入口文件的配置项，它可以是一个数组，允许有多个入口点。 如果只有一个入口的话，可以直接使用双引号”./entry.js”；output：配置打包结果，path定义输出的文件夹，filename定义打包结果文件的名称；module：定义对模块的处理逻辑，可以用loaders定义一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。plugins：这个是放置各种第三方插件的属性，使用第三方插件可以完成更多loader不能完成的功能。 本项目在确认开发基本ok之后，通过npm run build，即可完成项目打包上线。 使用ES6新语法编写代码众所周知，ES6是以后的常态化书写趋势，所以在该项目中边学边用，最常用的大概就是解决回调金字塔的Promise属性、箭头函数、反引号、const/let、属性属性值同名简写、export/import等，具体使用方法就不细写了，ES6的主要作用还是起到代码规范化同时更简洁高效的达到以前需要冗长代码才能实现的效果。ES6新特性传送门 最终效果]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Vue</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5新特性--本地dataDaseStorage的运用]]></title>
    <url>%2F2017%2F05%2F24%2FH5%E6%96%B0%E7%89%B9%E6%80%A7--%E6%9C%AC%E5%9C%B0dataDaseStorage%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于HTML5中新增的”SQLite”数据库存储方式，网上的介绍资料比较少，这种存储方式突破往常cookie临时性及存储空间限制，可以将数据永久存储在本地，并且存储空间可扩展至5~10MB，本篇以一个通讯录存储demo进行演示，同时温习下MySQL的相关语法，以供参考。 完整代码及相关注释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;HTML5 dataDaseStorage&lt;/title&gt; &lt;link rel="stylesheet" href="./bootstrap.min.css"&gt; &lt;style&gt; .middle-box &#123; display: table; width: 450px; height: 300px; border: 1px solid lightskyblue; margin: 0 auto; &#125; .middle-inner &#123; display: table-cell; vertical-align: middle; text-align: center; &#125; #list &#123; text-align: center; &#125; .table.table-bordered &#123; width: 50%; margin: 0 auto; &#125; th, td &#123; border: 2px solid green !important; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="middle-box"&gt; &lt;div class="middle-inner"&gt; &lt;form class="form-inline"&gt; &lt;h3&gt;通讯录&lt;/h3&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="userName"&gt;姓名：&lt;/label&gt; &lt;input type="text" id="userName" name="userName" class="form-control text" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="mobilephone"&gt;手机：&lt;/label&gt; &lt;input type="text" id="mobilephone" name="mobilephone" class="form-control" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="company"&gt;公司：&lt;/label&gt; &lt;input type="text" id="company" name="company" class="form-control" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;input type="button" onclick="saveMsg()" value="新增记录" class="btn btn-default btn-info" style="width: 55%;" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;div id="list"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 加载完毕后取出数据 window.onload = function() &#123; loadAll(); &#125; // 创建或打开已有数据库API var db = openDatabase('contactdb', '', 'local database describe', 204800); // 4个参数含义： // databasename: 数据库名字； // version：数据库版本号，选填； // description：数据库描述； // size：给数据库分配的空间大小； //保存数据API function saveMsg() &#123; var userName = document.getElementById("userName").value; var mobilephone = document.getElementById("mobilephone").value; var company = document.getElementById("company").value; var timestamp = parseInt(new Date().getTime()/1000); if (userName &amp;&amp; mobilephone &amp;&amp; company) &#123; db.transaction(function(tx) &#123; //contact为 table name，4个问号分别由后一个参数值替代，后2个参数为回调函数 tx.executeSql('insert into contact values(?,?,?,?)', [userName, mobilephone, company, timestamp], onSuccess, onError); &#125;); &#125; else &#123; alert('请输入完整信息！') &#125; &#125; //删除数据API function deleteMsg(phone) &#123; if (confirm('确定要删除吗？')) &#123; db.transaction(function(tx) &#123; tx.executeSql('delete from contact where phone=?', [String(phone)], onSuccess, onError); &#125;); &#125; &#125; // 两个回调 function onSuccess() &#123; alert("操作成功"); document.getElementById("userName").value = ''; document.getElementById("mobilephone").value = ''; document.getElementById("company").value = ''; loadAll(); &#125; function onError(tx, error) &#123; alert("操作失败" + error.message); &#125; //读取本地sqlLite数据API function loadAll() &#123; var list = document.getElementById("list"); db.transaction(function(tx) &#123; //如果初始数据表不存在，则创建一个空的数据表 tx.executeSql('create table if not exists contact(name text,phone text,company text,createtime INTEGER)', []); tx.executeSql('select * from contact', [], function(tx, rs) &#123; // console.log(rs); if (rs.rows.length) &#123; var tableEle = document.createElement('table'); tableEle.classList.add('table'); tableEle.classList.add('table-bordered'); tableEle.innerHTML = "&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;手机&lt;/th&gt;&lt;th&gt;公司&lt;/th&gt;&lt;th&gt;添加时间&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;"; for (var i = 0; i &lt; rs.rows.length; i++) &#123; var row = rs.rows[i]; tableEle.innerHTML += "&lt;tr&gt;&lt;td&gt;" + (i + 1) + "&lt;/td&gt;&lt;td&gt;" + row.name + "&lt;/td&gt;&lt;td&gt;" + row.phone + "&lt;/td&gt;&lt;td&gt;" + row.company + "&lt;/td&gt;&lt;td&gt;" + TimeChange(row.createtime) + "&lt;/td&gt;&lt;td&gt;&lt;input type='button' value='删除' onclick='deleteMsg(" + row.phone + ")' class='btn btn-danger'/&gt;&lt;/td&gt;&lt;/tr&gt;"; &#125; list.innerHTML = ''; list.appendChild(tableEle); &#125; else &#123; list.innerHTML = "目前通讯录为空，请添加新成员吧"; &#125; &#125;); &#125;); &#125; //根据时间戳生成时间对象 function TimeChange(value) &#123; var d = new Date(value * 1000); return (d.getFullYear()) + "-" + (d.getMonth() + 1) + "-" + (d.getDate()) + " " + (d.getHours()) + ":" + (d.getMinutes()) + ":" + (d.getSeconds()); &#125;&lt;/script&gt;&lt;/html&gt; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-Flex 弹性响应式布局的栗子]]></title>
    <url>%2F2017%2F05%2F21%2FCSS3%20Flex%E5%BC%B9%E6%80%A7%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E6%A0%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[本栗子主要记录如何运用CSS3的flex新特性进行快速的响应式布局，以及区别于以往DIV+CSS繁琐的垂直居中定位方法，通过flex方法方便快捷的实现子元素的垂直居中。 主体body布局如下： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;body&gt; &lt;header&gt;I am header&lt;/header&gt; &lt;div id='main-body'&gt; &lt;nav&gt;&lt;h3&gt;nav&lt;/h3&gt;&lt;/nav&gt; &lt;article&gt;&lt;h3&gt;article&lt;/h3&gt;&lt;/article&gt; &lt;aside&gt;&lt;h3&gt;aside&lt;/h3&gt;&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;I am footer&lt;/footer&gt;&lt;/body&gt;&lt;/head&gt;&lt;/html&gt; CSS样式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768* &#123; margin: 0; padding: 0;&#125;body &#123; font: 24px Arial; min-width: 300px;&#125;/*头尾普通布局*/header, footer &#123; display: block; height: 60px; line-height: 60px; background: lightyellow; text-align: center;&#125;/*内容区使用flex弹性布局*/#main-body &#123; display: flex; display: -webkit-flex; flex-direction: row; -webkit-flex-direction: row; min-height: calc(100vh - 120px); /*保证sticky-footer, 即让footer永远沉底不会浮起来，配合display:flex 使用*/ background: lightgrey;&#125;#main-body&gt;nav &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 1 1 20%; -webkit-flex: 1 1 20%; align-items: center; justify-content: center; background: lightskyblue;&#125;/*3个值，第1个表示窗口拉伸时的该子元素的扩展倍数，第2个表示窗口缩小时的缩小倍数，第3个表示该子元素所占父元素的比例*/#main-body&gt;article &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 2 4 55%; -webkit-flex: 2 4 55%; align-items: center; justify-content: center; background: lightgreen;&#125;#main-body&gt;aside &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 1 2 25%; -webkit-flex: 1 2 25%; align-items: center; justify-content: center; background: #CCCCFF;&#125;#main-body h3 &#123; padding: 5px 40px; border: 1px dashed #FFF;&#125;@media (max-width:768px) &#123; #main-body &#123; flex-direction: column; -webkit-flex-direction: column; &#125; #main-body&gt;article &#123; order: -1; -webkit-order: -1; &#125;&#125; 屏幕宽度大于768px时的效果：（高度保持不变） 屏幕宽度压缩小于等于768px的效果：（高度保持不变） 以下记录下几个设置要点： 1、设置display属性值为flex的元素即成为了父项，其内部包含的子元素即可使用flex属性进行弹性布局，子元素如若继续添加display: flex的属性，则该子元素也将成为其所包含的子元素的父项，以上栗子中设置子元素成为父项目的是让其包含的元素可以进行垂直居中设置。 2、以上两种效果的子元素项目的排序与html中默认的顺序相关，但可通过flex中的order属性进行切换，默认值为0，值设置的越小则更顺序靠前。 3、各个子元素的内容垂直居中效果是利用flex中justify-content 和 align-items两个属性进行调整，前者调整主轴方向上的对齐方式，后者调整交叉轴上的对齐方式，在父项上设置两个属性值均为”center”，则可以让包含的子元素垂直水平居中。 不使用flex属性的情况下实现元素垂直居中的代码，基本兼容所有浏览器： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; /*以下带*号的属性设置是为了兼容IE6、7*/ .middle-box &#123; display: table; /*关键设置*/ width: 300px; height: 200px; border: 1px solid #ff0000; margin: 0 auto; *position: relative; &#125; .middle-inner &#123; display: table-cell; /*关键设置*/ vertical-align: middle; /*关键设置*/ text-align: center; /*关键设置*/ *position: absolute; *top: 50%; *left: 50%; &#125; .middle-inner&gt;p &#123; *position: relative; *top: -50%; *left: -50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="middle-box"&gt; &lt;div class="middle-inner"&gt; &lt;p&gt; &lt;span&gt;Nice to meet YOU !&lt;/span&gt;&lt;/br&gt; &lt;span&gt;Have a nice day !&lt;/span&gt;&lt;/br&gt; &lt;span&gt;See YOU !&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果： 另外，今天学到一个实用的方法，可在不熟悉一个陌生函数的情况下，借助ES6中新增的Array.from方法，获知未知函数的参数个数及类型。顺利mark一下，代码： 1234[1,2,3].filter(function() &#123; console.log(Array.from(arguments)); &#125;)//result: [1, 0, Array(3)] [2, 1, Array(3)] [3, 2, Array(3)]]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DocumentFragment重构页面]]></title>
    <url>%2F2017%2F05%2F17%2FDocumentFragment%E9%87%8D%E6%9E%84%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Javascript里面有这样一个东西: DocumentFragment (中文翻译大概就叫”文档片段”)，很多前端攻城狮可以并不怎么常用或者了解它，它本身并不属于主DOM树的一部分，但它可以将一批子元素附加到自身，然后再将自身附加的所有子元素一次性添加到主DOM树中。这种方式不需要对一个真正的根节点进行操作，DocumentFragment附加子元素的所有操作都在浏览器内存中进行，不影响DOM树，因此将子元素插入到DocumentFragment对象中不会引起页面回流(reflow，即对元素位置和几何上的重新计算)。因此使用DocumentFragment重构页面能很大的优化性能，网上试验的结果显示比直接操作DOM快了70% … 下面举个简单的栗子： 以往的写法： 12345678910&lt;ul id='ul'&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt;const fruit = ['apple', 'cherry', 'banana']for (let i in fruit) &#123; let liEle = document.createElement('li') liEle.innerHTML = fruit[i] document.querySelector('#ul').appendChild(liEle)&#125;&lt;/script&gt; 运行结果： DocumentFragment的写法： 123456789101112&lt;ul id='ul'&gt;&lt;/ul&gt;&lt;script&gt;let docFragment = document.createDocumentFragment() //创建一个新的DocumentFragment对象const fruit = ['apple', 'cherry', 'banana']fruit.forEach(value =&gt; &#123; let liEle = document.createElement('li') liEle.innerHTML = value docFragment.appendChild(liEle)&#125;)document.querySelector('#ul').appendChild(docFragment) //一次性插入DOM树&lt;/script&gt; 第一种方法中每进行一次遍历，appendChild操作会向DOM树请求一次回流，注意是回流不是重绘(回流比重绘耗时更多)，因为append操作改变了ul元素之后的整体结构。第二种方法中DocumentFragment实际上像一个伪DOM父节点，在这个例子中可以把它当成虚拟的UL元素。这种方法代码量虽然稍微多了点，但只在最后进行一次appendChild操作改变DOM模型树，浏览器只进行一次性回流，因此能很好的优化加载性能。 Vue框架中就是大量运用了该方法，不直接针对DOM对象进行操作，而是将需要增删改的对象都先挂载在DocumentFragment这个虚拟的DOM对象上进行操作，最后完成数据处理之后再一次性提交给浏览器进行回流、重绘呈现新的页面。 关于页面的回流与重绘，简单的理解就是： 回流是指页面的重新布局，任何元素的规模尺寸、布局、显示隐藏等操作都会改变BOM树结构，因此每改动一次都需要进行一次重构。每个页面至少需要一次回流，就是在页面第一次加载的时候。 重绘是指当标签元素更新了一些不会影响到页面布局的属性时，浏览器进行的重新绘制。诸如的属性主要是外观风格这些，比如color、background等等。 详细的内容参考点这里]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Express 单页面切换与跨域请求实例]]></title>
    <url>%2F2017%2F05%2F15%2FVue-Express%20%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最近在学习Vue2.0单页面应用，基本想要达到的效果是前端单页面不刷新切换，同时利用Vue-resource插件实现ajax跨域请求数据的功能，本文主要记录下实践过程中觉得是个坑的地方。实现效果如下： 初始化项目// 全局安装 vue-cli $ npm install vue-cli --g // 创建一个基于 webpack 模板的新项目，项目名为`aVueTest` $ vue init webpack aVueTest // 安装package依赖 $ cd aVueTest $ npm install // 启动项目 $ npm run dev 初始化之后浏览器打开并出现Vue的界面，则初始化成功，进行下一步。 创建前端主页面比较简单，主要注意下router-link中不同的路径写法对应不同to的绑定方法，代码如下： 123456789101112131415161718192021222324&lt;template&gt; &lt;div id="app2"&gt; &lt;h1&gt;Have a nice day!&lt;/h1&gt; &lt;button @click="getOne()"&gt;getOne&lt;/button&gt; &lt;button @click="getZero()"&gt;getZero&lt;/button&gt; &lt;p&gt;返回的数据 :&#123;&#123; resResult &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;b&gt;result:&lt;/b&gt; &lt;router-view class='changestyle'&gt;&lt;/router-view&gt; &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to='/' tag="button"&gt;home&lt;/router-link&gt; &lt;!--路径为字符串时，to不需要v-bind绑定，tag属性设置渲染成什么标签--&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link :to='&#123;name: "foo"&#125;' tag="button"&gt;foo&lt;/router-link&gt; &lt;!--绑定一个对象--&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to='/bar' tag="button"&gt;bar&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;span class="icon"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 前端路由功能的实现其中演示只写了Home、Foo、Bar3个基本的路由功能，实现单页面不刷新的状态下进行组件切换，在浏览器中表现为域名后/#/routerPath，这也是与直接跳转刷新地址的一个区别。代码如下： 123456789101112131415161718192021222324252627282930313233import Vue from 'vue'import App from './App.vue'import VueRouter from 'vue-router'import VueResource from 'vue-resource'// import Home from './components/Home/home.vue'// import Foo from './components/Foo/foo.vue'import Bar from './components/Bar/bar.vue' //一次性引入，会影响加载效率const Home = resolve =&gt; require(['./components/Home/home.vue'],resolve) //懒加载引入，当路由指向该路径时再进行加载const Foo = resolve =&gt; require(['./components/Foo/foo.vue'],resolve) //懒加载Vue.config.productionTip = falseVue.use(VueRouter) //必写，告诉Vue以下要使用Router插件Vue.use(VueResource) //必写，告诉Vue以下要使用Resource插件const router = new VueRouter(&#123; routes: [ &#123;path: '/', name:'home', component: Home&#125;, &#123;path: '/foo', name:'foo', component: Foo&#125;, &#123;path: '/bar', name:'bar', component: Bar&#125; ]&#125;)/* eslint-disable no-new */new Vue(&#123; router: router, template: '&lt;Appoo&gt;&lt;/Appoo&gt;', //该template属性与components属性配合使用，该模板文件最终将绑定在#app内 components: &#123; Appoo: App &#125;&#125;).$mount('#app')router.push('/bar') //初始加载时默认选中的地址 Vue-resource发送跨域请求ajax的跨域请求一般都是通过在服务器端设置头部信息接受跨域请求，而Vue-resource的跨域请求方式不同，是通过在本地虚拟一个代理服务器，然后再通过这个代理服务器向目标服务器发送请求信息，之后再原路返回响应信息，因此需要在Vue的config文件夹中对index.js文件中进行代理服务器配置，配置如下： 123456789proxyTable: &#123; //配置跨域请求参数 '/api': &#123; target: 'http://localhost:10086/', //本地'localhost:8080/api'的地址将被代理为'http://localhost:10086/' changeOrigin: true, pathRewrite: &#123; '/api': '' // '/api'将被替换为''(空) &#125; &#125; &#125; 配置完之后，现在回到App.vue文件中，敲写Vue-resource的代码，注意其他的路由组件只要需要进行后台请求，都可以在Vue实例中利用Vue-resource，以下只在App.vue中实现从后端请求返回一个&quot;0&quot;和&quot;1&quot;的数据。代码如下： 12345678910111213141516171819202122232425262728export default &#123; data() &#123; return &#123; //data数据需要用一个函数包装 resResult: '', sendUrl: '/api/getOne', //这里的'/api'在代理服务之后会被rewrite为'' params: &#123;code: '007'&#125; &#125; &#125;, methods: &#123; getOne() &#123; let vm = this //这里的vm===this，申明vm的作用是为了减少后面this对原型链多层查找 vm.$http.post(vm.sendUrl, vm.params).then((res) =&gt; &#123; //这里就是Vue-resource的写法了，使用了ES6 promise的语法 console.log(res.body) vm.resResult = res.body &#125;). catch((err) =&gt; &#123; //捕获错误 console.log(err) &#125;) &#125;, getZero() &#123; this.sendUrl = '/api/getZero' this.params = &#123;code: '008'&#125; this.getOne() this.sendUrl = '/api/getOne' this.params = &#123;code: '007'&#125; &#125; &#125; &#125; 后台服务器的启动基于Node.js的Express框架，简单编写2个路由接口供前端请求，代码如下： 1234567891011121314151617181920212223const express = require('express')const app = express()const path = require('path')const bodyParser = require('body-parser')app.use(bodyParser.json()) //request.body的解析middlewareapp.use(bodyParser.urlencoded(&#123;extended: true&#125;))let routerArray = ["/getZero",'/getOne'] //接受所有的路由apiapp.post(routerArray,(req,res)=&gt; &#123; if (req.body.code == '007') &#123; res.end('1') &#125; else if(req.body.code == '008') &#123; res.end('0') &#125; else &#123; res.end('Not allowed...') &#125;&#125;)app.use(express.static(path.join(__dirname,'.')))app.listen(10086,() =&gt; console.log('started...')) //启动10086端口与前端Vue启动的8080就是通过proxyTable实现互通的 项目文件结构树如下：]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现百度搜索的跨域请求]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[今天在写ajax的时候查了个资料，了解到HTML标签中script标签的src属性是可以进行跨域请求的，而在ajax请求中，默认情况下，浏览器不允许其访问跨域访问资源，只要源地址与请求的域名、端口号不同，则请求失败，当然通过在服务端设置头文件请求等方式也可实现跨域请求(如设置&quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;)。但对于一些特殊的跨域请求可以变相通过script标签去获得，比如本栗子通过调用百度的搜索功能接口，实现百度首页中的搜索联想功能。 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JS跨域搜索&lt;/title&gt; &lt;style&gt; * &#123; margin: 0px; padding: 0px; &#125; img &#123; width: 270px; height: 129px; /*display: block; margin: 0 auto;*/ &#125; .container &#123; width: 100%; text-align: center; &#125; .search &#123; margin-top: 30px; height: 38px; overflow: hidden; &#125; #inputID &#123; width: 540px; height: 36px; border: 1px solid #3385ff; border-right: none; vertical-align: top; text-indent: 6px; &#125; #inputBtn &#123; width: 100px; height: 38px; border: none; background: #3385ff; color: white; cursor: pointer; font-size: 15px; &#125; .content &#123; width: 640px; margin: 0 auto; border: 1px solid lightgrey; display: none; &#125; ul &#123; list-style: none; text-align: left; &#125; li &#123; margin-left: 3px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;img src="bd_logo.png" alt="百度logo"&gt; &lt;div class="search"&gt; &lt;input type="text" id="inputID"/&gt;&lt;input type="button" value="百度一下" id="inputBtn" onclick="location.href = 'http://www.baidu.com/';"&gt; &lt;/div&gt; &lt;ul class="content"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var searchSuggestion = "http://suggestion.baidu.com/su?wd=#content#&amp;cb=callback"; var headEle = document.getElementsByTagName('head')[0]; document.querySelector("#inputID").addEventListener('keyup', function(e) &#123; var scriptMark = document.getElementsByClassName('JSONP')[0]; if (e.keyCode == "13") &#123; //监听enter事件 location.href = 'http://www.baidu.com/'; &#125; else &#123; if (scriptMark) &#123; headEle.removeChild(scriptMark); &#125; var scriptEle = document.createElement('script'); scriptEle.classList.add('JSONP'); scriptEle.src = searchSuggestion.replace("#content#", document.querySelector("#inputID").value); headEle.appendChild(scriptEle); &#125; &#125;) function callback(data) &#123; document.querySelector(".content").innerHTML = ""; if (data['s'].length) &#123; for (let i in data["s"]) &#123; document.querySelector(".content").style.display = "inline-block"; document.querySelector(".content").innerHTML += "&lt;li onclick=handleClk(this)&gt;" + data["s"][i] + "&lt;/li&gt;"; &#125; &#125; else &#123; //如果输入的关键词不存在联想，则将ul框隐藏 document.querySelector(".content").style.display = "none"; &#125; &#125; function handleClk(e) &#123; //处理选中词条 document.querySelector("#inputID").value = e.innerHTML; document.querySelector(".content").style.display = "none"; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组与对象的深复制与浅复制]]></title>
    <url>%2F2017%2F05%2F09%2FJS%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[今天记录一下Javascript语言中数组与对象两种数据结构的深复制与浅复制方法，温故知新常乐也。 对象的浅复制方法有：浅复制, 复制的是该对象的内存地址，任意一个数据变动会导致另一个也变。1obj = &#123;x:1,y:3&#125;; 方法1：1var obj2 = obj; 方法2：1var obj2 = Object.create(obj); //浅复制 对象的深复制方法有：方法1：1var obj2 = JSON.parse(JSON.stringfy(obj)); //深复制，复制的只是数据 方法2： 数组的浅复制与对象类似，这里只写数组深复制的几种方法：注意字符串、数字每次赋值之后都会将一个新的内存地址指向给到新变量。 1var arr = [1,3,5]; 方法1：1var arr2 = arr.slice(); 方法2：1var arr2 = arr.concat(); 方法3：1var arr2 = arr.filter(()=&gt;&#123;return true&#125;); 方法4：1var arr2 = JSON.parse(JSON.stringfy(arr)); 总结： 基本的数据类型都属于深复制，包括数字、字符串、布尔值等，数组与对象不属于基本数据类型，直接赋值的方式属于内存地址（即指针）的赋值，所以实际指向的值会动态变化。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾几道JS基础算法题]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%9B%9E%E9%A1%BE%E5%87%A0%E9%81%93JS%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[士别三日当刮目相看，题隔三月也有了些许新意。最近静下心来，回头去重新看看以前在freeCodeCamp上做过的JS基础算法题，结合最近了解的ES6一些新特性，对同样的题目可能会有不一样的想法了，所以选了几题梳理并记录一下，如果有更好的解题思路或者建议欢迎指教呀。 给定N个字符串,找出其中重复的字符串和它重复的次数主要有两种思路： 简单粗暴的使用2个 for 循环 正则表达式match方法 第1种方法： 1234567891011121314151617181920212223function abc(str) &#123; var obj = &#123;&#125;, flag = 0, resultStr = ''; for (let i = 0 ;i &lt;str.length; i++) &#123; if (str[i] in obj) &#123; obj[str[i]] += 1; //注意此处必须使用[]形式赋值！！！ flag = 1; &#125; else &#123; obj[str[i]] = 1; &#125; &#125; if (flag == 0) &#123; console.log("字符串不存在重复元素！"); //判断不存在重复元素 &#125; else &#123; var max = Math.max.apply(null,Object.values(obj)); for (let i in obj) &#123; if (obj[i] == max) &#123; resultStr += i + ","; &#125; &#125; console.log("结果为：" + resultStr + "出现的次数"+ max); &#125; &#125;abc("广东省广州市广州大学城广东工业大学") 第2种方法： 1234567891011121314151617function abc(str) &#123; var n = 0, newChar; for (var i=0; i&lt;str.length; i++) &#123; var regExp = new RegExp(str.charAt(i),"g"); //注意此处如果匹配的正则表达式是变量值，则必须通过new RegExp构造函数来创建一个正则实例 var arr = str.match(regExp); if (arr.length&gt;n) &#123; //match方法获得匹配到的值并组成一个数组 n = arr.length; newChar = str.charAt(i); &#125; &#125; return newChar + "出现的次数："+ n;&#125;abc("广东省广州市广州大学城广东工业大学")//栗子：//input: "广东省广州市广州大学城广东工业大学".match(/广/g);//output: ["广", "广", "广", "广"] 重复输出一个给定的字符串主要有三种思路： 使用 for 循环 使用递归 使用ES6 repeat() 第1种使用for循环最常规的方法： 12345678function repeatStringNumTimes(string, times) &#123; var repeatedString = ""; for(var i = 0 ; i &lt; times ; i++) &#123; repeatedString += string; &#125; return repeatedString;&#125;repeatStringNumTimes("abc", 3) 第2种通过条件判断和递归的方法：123456function repeatStringNumTimes(string, times) &#123; if(times &lt; 0) return ""; if(times == 1) return string; else &#123; return string + repeatStringNumTimes(string, times - 1); &#125;&#125;repeatStringNumTimes("abc", 3); 第3种使用ES6 repeat() 方法：ES6新特性虽然带来很大的使用便利性，但要多少理解一些底层的原理.1234function repeatStringNumTimes(string, times) &#123; return times &gt; 0 ? string.repeat(times) : ""; //三目运算&#125;repeatStringNumTimes("abc", 3); 数组去重提供以下6种思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var filterArr = [1,2,5,undefined,2,'2',4]//method-1function arrFilter(arr, resArr = []) &#123; for (var i = 0; arr[i]; i++) &#123; if(resArr.indexOf(arr[i]) === -1) resArr.push(arr[i]) &#125; return resArr&#125;arrFilter(filterArr)//method-2,原理与上面类似resArr = filterArr.filter((value, index, arr) =&gt; arr.indexOf(value) === index)//method-3resArr = [...new Set(filterArr)]//method-4function arrFilter(arr, resArr = [], i = 0) &#123; while (arr[i]) &#123; if(arr.indexOf(arr[i], i + 1) === -1) resArr.push(arr[i]) i++ &#125; return resArr&#125;arrFilter(filterArr)//method-5function arrFilter(arr) &#123; return arr.reduce((prev, next) =&gt; &#123; if(prev.indexOf(next) === -1) prev.push(next) return prev &#125;, [])&#125;//method-6function arrFilter(arr) &#123; var newArr = [arr[0]] arr.sort() //聚合 for(var i = 1, len = arr.length; i &lt; len; i++) &#123; if(arr[i] !== arr[i - 1])&#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让博客加载速度快一些]]></title>
    <url>%2F2017%2F05%2F05%2F%E8%AE%A9%E5%8D%9A%E5%AE%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%BF%AB%E4%B8%80%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[每每打开自己的博客时，发现加载速度真的要好久好久，体验感实在有点差，最近实在看不下去了，想着到底是啥原因导致的，有什么办法可以提高那么一点点的加载速度也行。网上查看了一些资料，知道GitHub的服务器是在美国GitHub公司，我又刚好是把代码托管在GitHub上，所以每次访问自己的GitHub Pages都需要爬山涉水往美国所在地的服务器取数据啊，加上访问的带宽也很一般，加载缓慢也在所难免了，这真是个悲伤的故事 … 不过还好，国内也有一个“高仿”GitHub的代管仓库Coding码市，Coding最近也提供了免费的Coding Pages以及自定义域名。所以我们的想法是通过将代码托管在两个仓库上，然后当输入同一个域名时，DNS可以通过解析IP让国外的IP地址访问到GitHub上的Pages，让国内的IP地址访问国内的Coding服务器上的托管Pages，这样不仅国内访客访问速度可以快一些，还能实现国内外分流，大概有了这个简单的想法，于是以下结合网上一些资料进行了一番尝试。 第一步注册创建一个Coding账号，新建一个repo仓库，基本与GitHub类似，不同的一点就是Coding上可以免费创建私有仓库。创建完成之后进入该仓库的代码菜单中，选中Pages服务，在该页面中分别设置以下几个参数： 第二步完成Coding的配置之后，进行DNS解析，因为我用的是万网的域名，万网自带DNS云解析，所以这里演示的是万网的域名解析配置，但是都大同小异，配置如下： 第三步完成以上配置后，接下来就是让Hexo每次deploy代码的时候往GitHub和Coding仓库都push一份，这就需要在Hexo的_config.yml 配置文件中修改deploy路径，具体如下： 12345deploy: ##发布的仓库地址 type: git repo: github: https://github.com/binglinzhang/binglinzhang.github.io.git,master coding: https://git.coding.net/zhangbinglin/myBlog.git,master 配置完之后以后每次hexo generate和hexo deploy都会往这两个仓库一起push，中间可能需要输入账号密码，可通过在电脑跟仓库上添加公钥，之后在本机电脑push就不需要再输入密码了。 最后以上所有配置完成之后，在浏览器再次输入域名访问，发现国内IP加载速度确实快了一点。在cmd中ping一下域名发现IP地址有2个，一个显示是美国一个是香港，而之前域名只配置GitHub仓库的时候，每次ping出来的IP地址都在美国，这可能也是用Coding Pages访问比较快一些的原因吧。当然网页加载速度慢还跟其他很多因素相关，比如跟外部资源加载，音乐图片链接等息息相关，这就涉及到前端性能优化的大范畴了。以上只从服务器距离写点自己个人的愚见，如果有不对的地方还请指正，感激感激。。。]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恰同学少年，谁主沉浮]]></title>
    <url>%2F2017%2F05%2F04%2F%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4%EF%BC%8C%E8%B0%81%E4%B8%BB%E6%B2%89%E6%B5%AE%2F</url>
    <content type="text"><![CDATA[红日初升，其道大光；河出伏流，一泻汪洋；潜龙腾渊，鳞爪飞扬；乳虎啸谷，百兽震惶；鹰隼试翼，风尘翕张；奇花初胎，矞矞皇皇；干将发硎，有作其芒；天戴其苍，地履其黄；纵有千古，横有八荒，前途似海，来日方长。美哉，我少年中国，与天不老；壮哉，我中国少年，与国无疆！]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5 webWorkers的异步多线程]]></title>
    <url>%2F2017%2F05%2F03%2FH5%20webWorkers%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[假如有这样一个需求：在浏览器页面上输出1~99999之间的所有质数，要求有较好的用户体验，且不借助setTimeout()，setInterval()或调用XMLHttpRequest，该如何设计？ 第一种方法 完整代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1~99999之间的质数有：&lt;p id="result"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; for (let i = 2; i&lt;= 99999; i++) &#123; //求质数方法 let j = 2; while (i%j != 0) &#123; j++ ; &#125; if ( j == i ) &#123; document.getElementById("result").innerHTML += i + ", "; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 以上方法的优点是代码少，且只需要一个文件，不存在跨文件传输数据问题，但缺点也很明显，只有当浏览器JS引擎全部处理完所有的数据之后才会通过DOM把数据添加到HTML页面上，那么当处理99999内质数的时候浏览器大概需要歇菜5秒钟，此时用户只能干瞪着浏览器无法继续操作，如果99999之后再加上一个9，那需要等待的时间还得翻几倍，这就是JS单线程处理存在的一个问题。 那么有没有可能让浏览器优先把页面展示出来，然后后台一边处理数据，一边把处理好的数据先返回回来，再通过DOM动态添加到页面上？最近学习到web Workers，它是运行在后台的 JavaScript，独立于其他脚本，不影响页面性能。用户可以继续点击、选取页面内容等，而此时 web worker 在后台继续运行，多线程并行，上代码。 第二种方法 前端完整代码如下：其中worker.js为另一个js文件，用于处理业务，之后通过postMessage接口与worker进行通信，这也是跨源通信（cross-origin messaging）的一种方式。postMessage接口除了可以向worker传递私有数据类型，还支持JSON数据结构的传递。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1~99999之间的质数有：&lt;p id="result"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var worker = new Worker("worker.js"); //new Worker()构造函数引进一个js文件 worker.onmessage = function(e) &#123; //监听message事件 document.getElementById("result").innerHTML += e.data + ", " ; &#125;&lt;/script&gt;&lt;/html&gt; worker.js文件的代码如下： 123456789for (let i = 2; i&lt;= 99999; i++) &#123; let j = 2; while (i%j != 0) &#123; j++ ; &#125; if ( j == i ) &#123; postMessage(i) ; //postMessage()方法对应前端onmessage监听事件，发送数据的接口 &#125; &#125; 那么还有一个问题，因为onmessage该监听事件是一个回调函数，存在异步问题，如果单个js文件需要处理的业务逻辑太多，需要分成多个js文件去处理，且下一个js文件的执行需要得到上一个js文件处理的结果，这时候就会想到用ES6中的promise方法，于是模拟代码如下： 123456789101112131415new Promise(function(resolve,reject) &#123; resolve(); &#125;).then(function() &#123; var worker = new Worker("worker.js"); worker.onmessage = function(e) &#123; //监听获取worker返回的数据 document.getElementById("result").innerHTML += e.data + ", " ; &#125; &#125;).then(function() &#123; var worker2 = new Worker("worker2.js"); worker2.onmessage = function(e) &#123; //监听获取worker2返回的数据 document.getElementById("result").innerHTML += e.data + ", " ; &#125; &#125;).then(null,function(err) &#123; console.log(err); &#125;) 假设两个js文件postMessage回来的数据是”aaa”和”bbb”，这时候在浏览器运行多次之后会出现2种不同的结果，原因请大家想想。不甘心的我在没有其他更好的方法的情况下又重回了“回调金字塔”，能勉强实现功能的代码如下： 12345678910var worker = new Worker("worker.js"); worker.onmessage = function(e) &#123; document.getElementById("result").innerHTML += e.data + ", " ; var worker2 = new Worker("worker2.js"); worker2.onmessage = function(e) &#123; document.getElementById("result").innerHTML += e.data + ", " ; worker2.close(); //worker属于系统层面的线程,占用资源密集。因此，在完成任务之后及时终止进程 &#125; worker.close(); &#125; 以上是我在学习这个知识点的时候的一些尝试与想法，如果你有更好的办法呢，希望指教，O(∩_∩)O。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入URL到页面加载发生了什么]]></title>
    <url>%2F2017%2F05%2F01%2F%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[最近网上看到这样一个问答题，先前从没想到过有这么深入复杂的各种逻辑，涉及到计算机网络、域名服务器、浏览器性能优化等等，今天参考网上的一些说法大概写几点简单的理解，以待闲暇之余继续逐个深入了解探讨。 1、浏览器查找域名对应的IP地址 这一步包括DNS具体的解析查找过程以及DNS的优化，包括DNS多级缓存，由近及远有：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;域名服务器缓存…，还有就是DNS负载均衡，具体知识点需要google更多。 2、浏览器向web服务器发送一个HTTP请求 服务器的永久重定向响应（从http://example.com 到 http://www.example.com），关于为什么要重定向，其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://example.com/和http://www.example.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。所以要把带www的和不带www的地址归到同一个网站排名下。 还有一个原因是用不同的地址会造成缓存友好性变差。 3、浏览器跟踪重定向地址，发起GET请求 该过程浏览器向远程服务器请求该IP地址对应存放的HTML页面。 4、服务器”处理”请求，向浏览器发回一个HTML响应 该过程服务器响应请求并返回一个静态的HTML页面给到浏览器解析。 5、浏览器解析显示HTML 浏览器解析HTML页面结构构建DOM树，同时找出需要继续向外加载的请求。 6、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 浏览器再次发送网络请求，获取页面上所需的图片、音视频、外部资源等。 7、浏览器发送异步请求（ajax请求等） 浏览器处理script标签中的JS代码，如果存在局部ajax请求则继续发送网络请求。 更详细的参考资料]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《滚蛋吧，肿瘤君》有点感]]></title>
    <url>%2F2017%2F04%2F29%2F%E3%80%8A%E6%BB%9A%E8%9B%8B%E5%90%A7%E8%82%BF%E7%98%A4%E5%90%9B%E8%A7%82%E6%84%9F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今晚忙里偷闲，看了个电影，名字叫《滚蛋吧，肿瘤君》。感触颇多，记录下此刻内心的一点想法。 生活品性虽不忠，却不影响对才华的仰慕，斯者如超级丹。 主演白百合确实演的细腻入微，几番哽咽。 故事主要分3条线索，一个是孤身港湾之外，幸之如艾米、老郑之辈的水手护帆， 时常惊喜，时而轻狂，三言两语陪你理尽光头，处理“生前生后事”的娃娃亲们。 一个是伶仃远洋憋屈无助时候一句“妈，我要回港湾”的谷底暖阳。 最后一个也是倾注更多帧数的话题， 般若艾米追逐事业无视身体加班加点优秀上进的生活， 般若熊顿率性欢颜敢梦敢为有你有我有色有味的人生。 无谓好坏，都是生活态度的一种抉择。 生活本不止于脚下的非黑即白，心往远阳的人多了，生活也就多了更多炫彩。 但笑傲江湖讲，气剑归宗葵花宝典，身体就是生活的葵花宝典。 逐事业也好，戏人生也罢，坐井底也可，游江左也堪，总归一“本”字到头。 活着，你才有所有，有所无，非命无情，一无所有，夫复何求？]]></content>
      <categories>
        <category>生活呀</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创业是一种生活态度]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%88%9B%E4%B8%9A%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%9F%E6%B4%BB%E6%80%81%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[如果你问一个二十出头的年轻人，是想要被催促着买车买房结婚生子的生活，还是谈论着梦想改变世界、让自己一辈子不白活的生活，大多数人会想要后者，却最终选择前者。这就像苹果和微软一样，大多数人都喜欢苹果，但他们都在用Windows操作系统。那些谈论的人还在谈论，而那些梦想改变世界的人，才是真的没有白活。你能想象十几年前睡在硅谷Univ Ave（大学街）165号地板上那几个20出头的小伙儿，后来分别创办了视频网站YouTube、社交网站Linkedin和点评网站Yelp么？ 创业就像走在一条长长的道路上，你看不见尽头，望不到边。有人忍受不了孤独而走上众人的通途，有人受不了困苦沿着脚印一步步退后，只有一种人可以看到豁然开朗的景色：他们从不畏孤独、险途，他们始终与梦想相伴，他们记得为什么出发，所以他们始终都能到达。 你为什么要创业？以下罗列3个参考意见： 1、创业是一种态度冯大辉（丁香园首席技术官）所理解的“创业”，是一种对待工作的态度。 不是说自己一定要单干，比如注册个公司，当个说一不二的老板，才是在创业。想明白工作是为了自己，而不是感觉在为别人打工，这就是创业。 创业，就是一个更为积极、更为明确的工作态度。“我不在创业，就在去创业的路上。”这是我刚加入阿里巴巴那段时间的签名。 罗云登（电商创业者）同样认为创业和态度有关。 如果明天是世界末日，我还会选择创业，这是一种人生态度。 小时候想创业，那是因为受到家人的影响，让人感到一种成就感；中学时候想创业，是为了能住上自己喜欢的房子，开上自己喜欢的车子，去梦想的地方旅行；高中时候开始做网店，找货源，搞宣传，明白赚钱不易。创业是为了让父母过上好的生活，能帮助到自己身边困难的亲人朋友，不仅仅是为了自己要成就什么；大学后开始尝试做不一样的事情，慢慢知道自己要干什么样的事情，并为之努力，未曾放弃，坚持至今。 随着时间的推移，创业观、世界观、互联网观逐渐成熟，明白了创业最大的乐趣是，当你知道你正在做的事情改善了许多人的生活，你慢慢意识到这是一件多么有价值的事情啊！然后继续下去，乐此不疲。其实我们兜售的不是产品，而是梦想。 2、改变自己老杨（懒汉互联网站创始人）刚刚步入创业的行列，这个问题是他不可逾越、但又总想躲避的一个问题。 好好的办公室坐着不舒服吗？ 非得花3个小时的路程只为见客户5分钟，而且一路上又是地铁、公交、步行，又不熟悉见面地点，空气也不好。这是为什么？ 每个月有稳定的收入不舒服吗？ 非得冒着付出远大于回报，甚至是没有回报还倒贴的风险去做事情。这是为什么？ 轻松的工作不舒服吗？ 非得出去苦口婆心地介绍自己及自己的产品，既充当开发者、又当美工、编辑、市场、销售，还要充当财务。这是为什么？ 朝九晚五的工作不舒服吗？ 非得比别人起得早、干得晚，周末毫无怨言地加班，没时间陪家人，没有假期。这是为什么？ …… 我不想等自己老去的时候，回想起过去却是一片空白，一点值得回忆的事情都没有。我不想后悔和叹息，自己尝试了，不管是对还是错，努力过后就无怨无悔。我只是不想虚度光阴。充实和富有挑战，才是自己骨子里最本质的东西。我不期望自己能改变别人的世界，但愿能改变自己的世界。 3、实现人生目标林培中（知乎控，无业游民）认为，要回答为什么创业，有个前提是弄清楚我们的人生目标是什么？ 这个问题，因人而异，没有标准答案。 第一种人希望自己成为一个比降临人世之初更好的人，例如稻盛和夫。这种人往往希望每天都能过得更充实，能把每一分每一秒都用在提高自己、实现自己的人生价值上。 第二种人，希望能好好地享受生活。只要自己和身边的人能够幸福快乐，就已经足够了。 这两种人，并没有优劣之分。克里斯托弗·莫利有一句话说得很好：“只有一种成功——能以你自己的生活方式度过你的一生。” 还有第三种人，他们认为人生就是一场灾难，只希望人生能早早结束。但第三种人没有明确的创业动机，可以忽略。 在了解了不同的人有不同的人生目标后，我们就可以分别讨论他们创业的目标了。 在第一种人中，选择了创业的人也可以分为两类： 一类是有着明确目标的人，第二类是没有明确目标的人（这里假设他们都能承担责任）。胜间和代说过：“我们的人生设计应该是，尽量做自己擅长的事，把赚来的钱请别人做自己不擅长的事。”然而在日常工作中，作为员工的我们往往从事着老板安排的工作，而这些有可能对我们本身价值并不大，或是我们并不愿意做的。从事这样的工作，会让我们对自己产生深深的违和感。 “这就是我想要的生活？”“我这么辛苦到底为了什么？”（正在从事自己感兴趣的工作或是只想得过且过的人除外。）每个人都希望从事自己喜欢的职业，每天做自己想做的事，然而现实是，并非每个人都能如愿以偿。 于是，在第一种人中，第一类人不甘这样下去，有着自己明确的目标，而且有勇气去承担责任的人，选择了创业。对于他们而言，创业是为了充分利用时间，提高自我，实现自己的价值。而第二类人则只是认为与其为别人工作，不如为自己工作。他们创业的目的只是渴望随心所欲的自由，或是认为只有为自己工作，才能实现人生价值。他们只是单纯地在逃避生活。 第二种人创业的目的很简单。创业就是他们享受生活的方式。就像有人会选择骑着自行车环游世界，而有人则会选择坐飞机环游世界一样，是创业还是为他人工作，只是个人享受生活的方式不同罢了。 最后，请让我引用最近微博上很流行的一句话为这个回答终结。 一个不成熟男人的标志是他愿意为某种事业英勇地死去，一个成熟男人的标志是他愿意为某种事业卑贱地活着。——《麦田守望者》 本文内容是我在读《创业时，我们在知乎聊什么》P6~12的文摘，我手中在读是第116899本，欢迎借阅分享。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express + Formidable 实现拖拽文件上传服务器]]></title>
    <url>%2F2017%2F04%2F23%2FExpress%20%2B%20Formidable%20%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%8B%96%E6%8B%BD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[功能需求：以往通过设置“input”标签的type类型为“file”可进行文件选择上传，但该方法效率较低，用户交互体验不是很好，因此通过H5新增的拖放API进行多个文件选择上传，并能在服务端保存成功。 前端页面简单代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;style media="screen"&gt; #target &#123; border: medium double black; width: 200px; height: 80px; text-align: center; line-height: 75px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="target"&gt;Drop files here&lt;/div&gt; &lt;div id="data"&gt;&lt;/div&gt; &lt;br&gt; &lt;input type="submit" value="提交" onclick="handleCLK()"&gt;&lt;/body&gt;&lt;/html&gt; 前端通过Ajax发送上传数据请求，关键代码如下： 其中关键点在于通过FormData对象包装得到一个“文件对象”，从而满足Ajax数据发送要求。 12345678910111213141516171819202122232425262728293031323334353637&lt;script type="text/javascript" src="jquery-1.12.4.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var target = document.getElementById("target");target.ondragenter = handleDrag;target.ondragover = handleDrag;function handleDrag(e) &#123; e.preventDefault();&#125;var fd = new FormData(); //实例化一个FormData对象target.ondrop = function (e) &#123; var files = e.dataTransfer.files; //存储上传的所有文件 var divP = document.getElementById("data"); for (var i = 0; i &lt; files.length; i++) &#123; divP.innerHTML += "文件名：" + files[i].name + "文件大小：" + files[i].size + "&lt;br&gt;"; fd.append("file" + i, files[i]); //将上传的文件丢给FormData实例对象，才能传输给后端，否则需要使用form表单形式提交 &#125; e.preventDefault();&#125;function handleCLK() &#123; $.ajax(&#123; type: "POST", url: "/upload", data: fd, //该对象即为上面FormData实例化之后append到的数据文件 processData: false, //此两行必须添加，否则会与jQuery库冲突报错 contentType: false, //此两行必须添加，否则会与jQuery库冲突报错 success: function (data) &#123; if (data == "1") &#123; console.log("success..."); &#125; else &#123; console.log("something wrong..."); &#125; &#125; &#125;)&#125;&lt;/script&gt; 后端处理响应并返回响应值给前端请求，关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637var express = require("express") //引入Express模块var app = express()var formidable = require('formidable') //引入formidable模块var fs = require("fs")app.post("/upload", function (req, res) &#123;var form = new formidable.IncomingForm();form.parse(req, function (err, fields, files) &#123; for (let i in files) &#123; //此处必须使用let定义i，否则会出现异步问题，具体可参考setTimeout(function()&#123;&#125;,0)的含义 var n = 0; var stream = fs.createReadStream(files[i].path); //创建一个读数据流 stream.on("data", function (chunk) &#123; fs.writeFile(require("path").join(__dirname, files[i].name), chunk, &#123;flag: "a"&#125;, function (err) &#123; //将上传的内容从磁盘读取并写入当前文件夹 if (err) &#123; console.log(err); res.end("0"); &#125; &#125;) &#125;) stream.on("end", function () &#123; n++; if (n == Object.keys(files).length) &#123; //获取对象属性数量生成一个数组，通过数组length得知对象属性个数 console.log("end"); res.end("1"); //当同时上传多个文件时需要对n进行判断，只有当全部上传完成之后才返回响应值 &#125; &#125;) &#125;&#125;);&#125;)app.use(express.static(require("path").join(__dirname, "."))); //暴露文件app.listen(8080, function () &#123;console.log("started..");&#125;) 其中关键点在于”formidable”模块实例一个对象之后对数据流的写入保存，而且需要考虑如果同时上传多个文件使用for…in的遍历方法时，需要考虑let块级作用域结合回调函数异步处理的相互影响。另外如何获取一个对象的属性数量？ 以上代码只是作为演示，具体项目中还有很多可以优化，比如如果用户拖拽文件之后，又重新拖拽几个文件，点击上传，这样在前端代码块中的files会出现问题。另外formidable模块会将数据直接写入磁盘，而且不会擦除，时间久了会很占用空间，关于后端接收数据是否有更优解，比如express中间件multer?等等 …]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习过程中积累的笔记]]></title>
    <url>%2F2017%2F04%2F21%2FJavascript%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A7%AF%E7%B4%AF%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近整理先前作为初学者积累的Javascript学习笔记，回过头来看还是觉得基础很重要啊，虽然随着积累的知识越多，经验越丰富，但基本的知识点万变不离宗，还是要回过头时常翻看下，想起了当年我高考的语文作文：“回到原点”，多恰当哈哈 … 解释型语言：可直接在浏览器或者操作系统执行的文件编译型语言：源代码通过编译器编译生成二进制可执行文件（特点：运行速度快，执行效率高） 局部变量只能在本变量声明的函数内部调用，跳出该函数体之后即无法调用。全局变量在整个代码中都可以进行调用。栗子： 123456789var i = "bling"; //通过var定义了全局之后在控制台中输出i跟输出window.i效果一样function myName() &#123; var i = "Bryn"; // 注意此处通过var定义变量之后，i变为局部变量，如果把var关键字去掉,则变成了给i重新赋值，i还是挂载在window下的全局变量，返回输出的结果即为“Bryn"&#125; myName(); function myLikes() &#123; alert(i);&#125;myLikes(); //返回结果为"bling" 在for语句或者switch选择语句中有以下2个关键语句：continue:执行该语句后即停止当前循环，进入下一次循环；break:执行该语句后立马跳出循环体，不再执行后面动作。 A+=10等效于A=A+10A-=10等效于A=A-10同理还有A=10；A/=10*栗子： 12345var a=10, b=20 , c=30;++a; //立马执行，a即为11a++; //再次调用时执行，此时a还是11e=++a+(++b)+(c++)+a++; //e = 13 + 21 + 30 + 13alert(e); //弹出提示对话框：77 形参即形式，实参即内容，形参只充当占位符，实参决定形参真正的值。函数内的局部变量优先级高于全局变量。 全等运算符（===）：只有当数值大小与数值类型一样才能返回true。&amp;&amp;表示与逻辑运算符，只有当多个参数同时满足条件才执行；||表示或逻辑运算符，只要有任一参数满足条件即执行； JavaScript Object Notation 简称 JSON，它使用JavaScript对象的格式来存储数据。JSON是灵活的，因为它允许数据结构是字符串，数字，布尔值，字符串，和对象的任意组合。 12345678Math.random(); //生成一个[0,1)之间的随机数Math.round(); //把一个数字四舍五入为最接近的整数,算法为Math.floor(x+0.5)，将原来的数字加上0.5后再向下取整，所以Math.round(11.5)结果为12，Math.round(-11.5)结果为-11Math.floor(); //向下取整，如floor(8.9)=8Math.ceil(); //向上取整,如ceil(8.1)=9parseInt(); //字符串取整，如parseInt("15.49")=15,parseInt(1.5)=1Math.max.apply(null,arr); //取任意长度数组中的最大值Math.min.apply(null.arr); //取任意长度数组中的最小值 正则表达式支持的通配符：. 通配任何字符中的一个字符；\d 通配数字中的一个字符,[0,9]；\D 不是数字的字符；\s 空白字符（空白字符有5个，空格” “、换行\n、回车\r、制表符\t、换页符\f）；\S 非空白字符；\w 通配所有的单词字符，包括数字、大小写字母、下划线（63个字符）；\W 通配非单词字符；[a-z]、[A-Z]、[0-9]、[A-Za-z]（包含大小写英文字符）、[a-z0-9]；栗子： [afg]==(a|f|g)；[a\-fg]==(a|-|f|g) ;^ 以什么开始；$ 以什么结束；？ 出现0次或者1次（用于修饰前面的通配字符，不可单独使用，下面同理）；* 出现0次或者多次，即可匹配任意长度 ;+ 出现1次或者多次；{m,n} 出现m到n次；\b 不会消耗任何字符只匹配一个位置，常用于匹配单词边界；栗子：从字符串中”This is Regex”匹配单独的单词 “is” 正则表达式为：\bis\b；\b 不匹配”is”两边的字符，只识别两边是否为单词的边界；栗子：/^[a-z].$/ 表示以小写字母开头的任意2个字符,如a7；p8/^[a-z].？$/ aaa错误/^[a-z].*$/ aaa正确/^[a-z].+$/ aaa正确/^[a-z].{1,3}$/ aaaa正确/^[a-z].{3}$/ 只有aaaa正确 /\d/ 只匹配包含一个数字的字符，如2，5；/\d+/ +用于修饰d，所以匹配到包含一个或者多个的数字组合，如50,123；/\d/g 匹配全局包含一个数字的字符，如25匹配得到[“2”,”5”]；/\d+/g 如25,123匹配得到[“25”,”123”]；/\d+/gi 不分大小写匹配；([ab]+)\1：\1是对前面括号内容的引用次数，因此该匹配只会匹配多个重复a或重复b； 以下这些正则表达式中”^”表示字符类的否定：[^a]表示“匹配除了a的任意字符”;[^a-zA-Z0-9]表示”找到一个非字母也非数字的字符”;[\^abc]表示”找到一个插入符^或者a或者b或者c”;[^\^]表示”找到除了插入符^外的任意字符”;经过对比，发现只要是”^”这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头，也就是说”[]”代表的是一个字符集，”^”只有在字符集中才是反向字符集的意思。 字符串与数组一些常用的内置函数：1234567891011121314151617181920212223242526var regExp=new RegExp() //创建正则表达式；new RegExp().test(string) //测试字符串是否包含表达式，返回值为true or false；string.replace(new RegExp(),and) //用and把字符串中的所有.替换成and；string.match(new RegExp()) //输出匹配到的数组结果，最长匹配原则；string.search(new RegExp()) //输出匹配到的值的首个索引号；var myArr=new Array() //数组创建的其他方式 ;Arr.push() //往最后一个元素后添加数组元素，返回数组长度，更改原数组；Arr.pop() //移除数组最后一个元素,并返回该元素的值,更改原数组的长度；Arr.shift() //移除数组第一个元素，并返回该元素的值,更改原数组的长度；Arr.unshift() //添加元素作为数组的第一个元素，返回值为数组长度；//以上4个方法作用效果相反，push(),pop(),shift(),unshift();string.split(//) //split后面可以加正则表达式按最长匹配原则进行分割；string.slice() //截断字符串，左边括号部分包括，右边括号部分不包括，不改变原数组；string.substr() //返回字符串中从指定位置开始到指定长度的子字符串；string.charCodeAt() //字符串转ASCII码；String.fromCharCode() //ASCII码转字符串；array.reverse() //就地反转数组顺序，改变原数组；array.join() //数组连成字符串；array.toString() //数组转换为字符串；array.slice() //截断数组，左边括号部分包括，右边括号部分不包括；array.slice(n,array.length) //返回一个数组被截断n个元素之后还剩余的元素；array.map(function()&#123;&#125;) //mapmap函数对每一个数组元素进行计算，如+3，-50，*4a等；array.reduce(function()&#123;&#125;,0) //reduce函数对数组内部元素间进行操作，如前后相加相减等；array.filter(function()&#123;&#125;) //filter过滤函数，不改变原数组；array.sort(function(a,b)&#123;return a-b;&#125;) //sort实现重新排序数组大小，升降序通过reverse()改变；array.splice() //增加或减少数组内元素，返回值为被删除元素组成的数组，该函数改变原数组； 不会改变原数组的函数操作有： filter();concat();map();slice();replace();改变原数组的函数操作有： push();shift();unshift();splice();reverse();sort();]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo +Markdown 搭建个人博客关键步骤]]></title>
    <url>%2F2017%2F04%2F15%2FGitHub%20%2B%20Hexo%20%2BMarkdown%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[前人摘树，后人乘凉。小的我喝了茶乘了凉，总不能一下就人走茶凉吧，因此也记录下自己在搭建本blog过程中认为比较重要的几点，如果能助人一二，那敢情甚好，不若自己遗忘时回望回望也是极好的，O(∩_∩)O …环境要求：本文基于win7编写，电脑上需安装node.js及git. 一、创建gitHub特定托管仓库登录个人gitHub账号（没有注册的请自行百度注册），点击右上角+图标，选中“New repository”新建一个仓库. 建仓填写仓库相关信息，如图所示，仓库“Repository name”的命名必须遵循如下规则：“Owner”中的用户名+.github.io，该地址具有唯一性. 图中因为我已经创建过该用户名仓库，所以限制不允许重复创建. 其中仓库描述为选填，仓库默认为“Public”公共仓库，“Private”私人仓库需要付费购买，这里用公共仓库进行演示。初始化仓库也可选可不选，这里不选，后面直接git push自己需要的文件上去，点击“Create Repository”完成创建. 完成创建后，返回该仓库，进入“Settings”中，找到GitHub Pages 可见到“binglinzhang.github.io”显示已经发布，此时即可通过访该地址进行访问. 访问该地址默认会查找仓库根目录下的index.html文件，由于现在我们的仓库为空，需要在本地建仓并push文件到自己的GitHub上，具体的git操作功能不详细说明（常用的git clone，git add –all，git commit -m “…”，git push，git status必须会啊），不明白的可以参考廖雪峰大神的git教程，此处push一个index.html文件到自己的远程仓库上，通过访问自己的仓库即可看到刚刚上传的index.html页面的内容. 图片地址栏中显示的是域名，具体设置参考以下. 想要绑定自己的域名，则需对自己已注册过的域名进行解析(没有注册的可以通过万网注册，需要RMB)，我使用的是阿里云的万网域名解析，按图示进行设置，其中192.30.252.153和192.30.252.154为github提供的两个服务器IP地址，CNAME记录值为上面我们创建的github博客地址. 设置完成之后放回上面提到的“Settings”，在Custom domain下填入自己的域名，保存即可. 二、Hexo的安装与配置下载安装hexo，打开cmd命令行，输入： npm install -g hexo-cli 该安装为全局安装，完成之后在桌面创建一个文件夹，随意命名为”myBlog”, 在命令行中cd到该文件夹中，输入： hexo init 通过以上命令，Hexo帮我们初始化了一个博客项目，内容包括如下： 如果没有.deploy_git文件夹，则需cd到myBlog文件夹下输入： npm install hexo-deployer-git --save 以上文件中_config.yml为主要的配置文件，我们主要修改的内容为以下几项： · 修改网站相关信息123456title: yourblogsubtitle: your subtitledescription: your describeauthor: XXXlanguage: zh-CNtimezone: Asia/Shanghai 注意： 每一项的填写，其:后面都必须保留一个空格，下同。 · 配置个人域名url: http://zhangbinglin.cn · 配置部署1234deploy:type: gitrepo: https://github.com/binglinzhang/binglinzhang.github.io.gitbranch: master 其中repo项为上面创建的Github仓库地址，通过如下图方式copy，注意不要漏掉最后的.git. 此时，在cmd命令行中输入hexo server即可启动本地服务器，默认端口号是4000，因此在游览器中输入http://localhost:4000/ 即可进行访问. 如果希望别人也能访问到我们的文件，此时则需要将本地的文件push到GitHub上，具体指令如下： hexo generate hexo deploy 此时即可通过binglinzhang.github.io或者我们解析后的域名zhangbinglin.cn进行访问. 具体的主题、模板、插件等可访问官网进行优化设置：Hexo文档 三、Markdown书写Markdown是一门简便轻量级的高效率的标记语言，有自己的语法，不多也不难，网上看几个例子即能领会，这里不细讲，推荐一款MarkdownPad2软件，可实现基本的日常写作，看图，百度云盘传送门：密码：fg0v 以上内容只是写了关键的几个步骤，最关键的是要有清晰的思路，比如GitHub在这里起到什么作用，Hexo是怎么跟GitHub结合的，为什么要用Markdown，Markdown如何更高效的插入大量图片，在线存储自己的图片有哪些途径，GitHub仓库地址解析为自己的域名后如何通过自己的域名让别人访问到更多资源等等.]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>