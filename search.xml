<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于node爬取地图瓦片及应用]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%9F%BA%E4%BA%8Enode%E7%88%AC%E5%8F%96%E5%9C%B0%E5%9B%BE%E7%93%A6%E7%89%87%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文主要讲解从爬取地图瓦片到实现瓦片应用的过程，具体的地图相关理论不表。 指定经纬度及层级范围生成瓦片路径开源与成熟商业的瓦片地图服务基本遵循如下切割瓦片编号规则： x = (2 &lt;&lt; (z - 1)) * (λ / 180 + 1) y = (2 &lt;&lt; (z - 1)) * (1 - Math.log(Math.tan(Math.PI * φ / 180) + 1 / Math.cos(Math.PI * φ / 180)) / Math.PI)其中z代表层级，范围0-18，该值不同地图供应商确定的初始值不同，可能存在一定的差值(如天地图中是z-2)，可根据实际瓦片链接反推计算，λ代表经度，φ代表纬度。计算所得z/x/y值对应瓦片地址中的层级/经度/纬度三级目录，纬度y一般作为瓦片名称，对应如下node脚本中的天地图瓦片l/x/y路径。12345678910111213141516171819202122232425262728293031323334353637383940/*** 计算指定边界及层级范围内的瓦片或矢量数据* @param &#123;bound&#125; 数组，指定计算边界经纬度* @param &#123;begin&#125; 整数，指定计算最小层级* @param &#123;end&#125; 整数，指定计算最大层级* @param &#123;arr&#125; 数组，容器*/function getUrls(bound, begin = 11, end = 15, arr = []) &#123; const serverUrl = `http://t0.tianditu.gov.cn/DataServer?T=vec_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;l&#125;&amp;tk=$&#123;key&#125;` const PI = Math.PI function getXYBound (bound, k) &#123; const beginX = Math.floor(calcX(bound[0], k)) const endX = Math.floor(calcX(bound[2], k)) const beginY = Math.floor(calcY(bound[3], k)) const endY = Math.ceil(calcY(bound[1], k)) return [beginX, endX, beginY, endY] &#125; function calcX (x, k) &#123; return (2 &lt;&lt; (k - 2)) * (x / 180 + 1) &#125; function calcY (y, k) &#123; return (2 &lt;&lt; (k - 2)) * (1 - Math.log(Math.tan(PI * y / 180) + 1 / Math.cos(PI * y / 180)) / PI) &#125; for (let k = begin; k &lt;= end; k++) &#123; const geo = getXYBound(bound, k) for (let i = geo[0]; i &lt;= geo[1]; i++) &#123; for (let j = geo[2]; j &lt;= geo[3]; j++) &#123; const url = serverUrl .replace(/&#123;l&#125;/g, k) .replace(/&#123;x&#125;/g, i) .replace(/&#123;y&#125;/g, j) arr.push(&#123; url, dirStr: `$&#123;k&#125;/$&#123;i&#125;/$&#123;j&#125;` &#125;) &#125; &#125; &#125; return arr&#125; 根据生成路径下载瓦片 借助request库实现以流的方式读取下载文件，其中要特别注意的一点是在发起请求前需要添加请求错误的监听，以及读流过程错误的捕获，否则可能会导致请求无法终止，导致Promise.all无法继续执行。 由于地图层级数值越大，所需加载的瓦片数量更多，所以需要适当减少并发避免出现服务器响应问题。 有些情况下地图服务器对服务端发起的请求响应403错误，如天地图，这是因为服务端发起的请求默认没有User-Agent该字段，因此需要手动添加从而模拟客户端环境。 node中文件夹的创建只能一级一级创建，因此多目录递归时需要一级一级判断是否已存在该目录。12345678910111213141516171819202122232425262728293031323334function download(urls) &#123; return Promise.all(urls.map((&#123; url, dirStr &#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; mkrFile(`$&#123;baseDirection&#125;/$&#123;dirStr&#125;`) const stream = fs.createWriteStream(path.join(__dirname, baseDirection, dirStr + '.png')) request(url, &#123; // 防止反爬虫 headers: &#123; 'User-Agent': getRandomValue(userAgents) &#125; &#125;) .on('error', () =&gt; &#123; reject() stream.end() &#125;) .on('response', (res) =&gt; &#123; console.log(res.statusCode) &#125;) .pipe(stream) .on('finish', () =&gt; &#123; resolve() stream.end() &#125;) .on('close', () =&gt; &#123; resolve() stream.end() &#125;) .on('error', () =&gt; &#123; reject() stream.end() &#125;) &#125;) &#125;))&#125; 爬取的瓦片数据应用maptalks是一个专门提供操作地图api应用层的库，该库可根据需要加载不同地图坐标体系的瓦片数据，然后根据加载的瓦片渲染成一个canvas画布，提供的api可以在该画布上进行各种交互操作。这里我们将爬取下来的瓦片开启一个本地服务供访问，并将路径提供给maptalks实例访问，打开html可以正常访问。代码如下：12345678910111213141516const map = new maptalks.Map('map', &#123; center: [114.136107, 22.581285], zoom: 12, minZoom: 8, maxZoom: 15, baseLayer: new maptalks.TileLayer('base', &#123; // 基础瓦片 urlTemplate: 'http://127.0.0.1:3343/download/vec_w/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png' // 本地瓦片服务地址 &#125;), layers: [ new maptalks.TileLayer('text', &#123; // 文字瓦片 urlTemplate:'http://127.0.0.1:3343/download/cva_c/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png' &#125;) ]&#125;) node脚本完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121const fs = require("fs")const path = require("path")const request = require("request")// 下载根目录const baseDirection = 'download/cva_w'// 并行下载数量const asyncParallelNumber = 10// 秘钥const key = '2ce94f67e58faa24beb7cb8a09780552'// 服务地址const serverUrl = `http://&#123;t&#125;.tianditu.gov.cn/DataServer?T=vec_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;l&#125;&amp;tk=$&#123;key&#125;`// const serverUrl = `http://&#123;t&#125;.tianditu.gov.cn/DataServer?T=cva_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;l&#125;&amp;tk=$&#123;key&#125;`// 多台服务器子域const TS = ['t0', 't1', 't2', 't3', 't4']// 模拟客户端代理const userAgents = [ 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36', 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Mobile Safari/537.36']// 获取请求路径const urls = getUrls([113.75726, 22.443499, 114.637837, 22.861701], 9, 9)/*** 计算指定边界范围内的瓦片或矢量数据* @param &#123;bound&#125; 数组，指定计算边界经纬度* @param &#123;begin&#125; 整数，指定计算最小层级* @param &#123;end&#125; 整数，指定计算最大层级* @param &#123;arr&#125; 数组，容器*/function getUrls(bound, begin = 11, end = 17, arr = []) &#123; const PI = Math.PI function getXYBound (bound, k) &#123; const beginX = Math.floor(calcX(bound[0], k)) const endX = Math.floor(calcX(bound[2], k)) const beginY = Math.floor(calcY(bound[3], k)) const endY = Math.ceil(calcY(bound[1], k)) return [beginX, endX, beginY, endY] &#125; function calcX (x, k) &#123; return (2 &lt;&lt; (k - 2)) * (x / 180 + 1) &#125; function calcY (y, k) &#123; return (2 &lt;&lt; (k - 2)) * (1 - Math.log(Math.tan(PI * y / 180) + 1 / Math.cos(PI * y / 180)) / PI) &#125; for (let k = begin; k &lt;= end; k++) &#123; const geo = getXYBound(bound, k) for (let i = geo[0]; i &lt;= geo[1]; i++) &#123; for (let j = geo[2]; j &lt;= geo[3]; j++) &#123; const url = serverUrl .replace(/&#123;l&#125;/g, k) .replace(/&#123;x&#125;/g, i) .replace(/&#123;y&#125;/g, j) .replace(/&#123;t&#125;/g, getRandomValue(TS)) arr.push(&#123; url, dirStr: `$&#123;k&#125;/$&#123;i&#125;/$&#123;j&#125;` &#125;) &#125; &#125; &#125; return arr&#125;// 'baseDirection/k/i/j'，根据路径判断文件夹是否存在，不存在则创建function mkrFile(dirStr, i = 0) &#123; i = dirStr.indexOf('/', i) if(i === -1) return const dir = path.join(__dirname, dirStr.slice(0, i++)) !fs.existsSync(dir) &amp;&amp; fs.mkdirSync(dir) mkrFile(dirStr, i)&#125;// 获取数组随机值function getRandomValue(arr = [], len = arr.length) &#123; return arr[Math.floor(Math.random() * len)]&#125;// 根据给定数量的路径开启下载function download(urls) &#123; return Promise.all(urls.map((&#123; url, dirStr &#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; mkrFile(`$&#123;baseDirection&#125;/$&#123;dirStr&#125;`) const stream = fs.createWriteStream(path.join(__dirname, baseDirection, dirStr + '.png')) request(url, &#123; // 防止反爬虫 headers: &#123; 'User-Agent': getRandomValue(userAgents) &#125; &#125;) .on('error', () =&gt; &#123; reject() stream.end() &#125;) .on('response', (res) =&gt; &#123; console.log(res.statusCode) &#125;) .pipe(stream) .on('finish', () =&gt; &#123; resolve() stream.end() &#125;) .on('close', () =&gt; &#123; resolve() stream.end() &#125;) .on('error', () =&gt; &#123; reject() stream.end() &#125;) &#125;) &#125;))&#125;// 根据实际被访问服务高并发情况设置并发下载数量，默认10个function next(index = 0, len = urls.length) &#123; if(index &gt;= len) return console.log(`download done! 共下载$&#123;len&#125;个文件`) download(urls.slice(index, index += asyncParallelNumber)).then(() =&gt; &#123; console.log(`已下载$&#123;urls.slice(0, index).length&#125;个 ==============================`) next(index) &#125;, () =&gt; &#123; // 处理大量异常报错情况，避免直接退出 next(index) &#125;)&#125;next() end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之实现一个打包功能]]></title>
    <url>%2F2019%2F04%2F07%2Fwebpack%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%89%93%E5%8C%85%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[基于ast及Tapable实现一个简单的weback分析依赖打包模块的基础功能，并抛砖引玉编写一个简单loader实现less文件处理，及简单的plugin插件实现机制。在次基础上，可加上splitChunk等功能。 Webpack几个核心概念 Module：理论上一个被引用文件就是一个模块 Chunk: 一个entry或一个按需加载路由就是一个chunk Loader: 一个用于格式化处理指定文件内容的函数 Plugin: 一个在构建过程各生命周期触发不同钩子的类 webpack.config.js配置文件12345678910111213141516171819202122232425const path = require('path')const ZPlugin = require('./plugins/ZPlugin')module.exports = &#123; mode: 'development', entry: './src/main.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, resolveLoader: &#123; modules: [path.resolve(__dirname, 'loaders')] &#125;, module: &#123; rules: [ &#123; test: /\.less$/, loader: ['z-style-loader', 'z-less-loader'] &#125; ] &#125;, plugins: [ new ZPlugin() ]&#125; 程序执行主入口123456const path = require('path')const cwd = process.cwd()const config = require(path.join(cwd, 'webpack.config.js'))const Compiler = require('./lib/Compiler.js')const compiler = new Compiler(config)// compiler.run() 关键Compiler代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138const fs = require('fs')const path = require('path')const &#123; parse, traverse, transformFromAst &#125; = require('@babel/core')const &#123; SyncHook &#125; = require('tapable')class Compiler &#123; constructor(config) &#123; this.config = config this.hooks = &#123; entryOption: new SyncHook(['entryOption']), afterPlugins: new SyncHook(), beforeRun: new SyncHook(), run: new SyncHook(), beforeCompile: new SyncHook(), compile: new SyncHook(), afterCompile: new SyncHook(), emit: new SyncHook([]), done: new SyncHook() &#125; this.modules = &#123;&#125; this.template = '' // 注册插件 this.registerPlugins() this.hooks.entryOption.call(config) this.hooks.afterPlugins.call() // 触发执行 this.hooks.beforeRun.call() this.run() &#125; registerPlugins() &#123; const &#123; plugins = [] &#125; = this.config plugins.forEach((plugin) =&gt; &#123; plugin.apply(this) &#125;) &#125; run() &#123; this.hooks.run.call() const &#123; entry &#125; = this.config this.hooks.beforeCompile.call() this.parseModules(entry) this.hooks.afterCompile.call() this.renderTemplate() this.writeFile() this.hooks.done.call() &#125; parseModules(moduleId) &#123; this.hooks.compile.call() // 有缓存直接返回 if(this.modules[moduleId]) return this.modules[moduleId] const dependencies = [] // 读取文件内容 const sourceCode = this.readFileSync(moduleId) // 将代码解析成ast树 const ast = parse(sourceCode) // 遍历ast语法树获取import声明与require引用 traverse(ast, &#123; // 处理import方式导入 ImportDeclaration(p) &#123; const dirname = path.dirname(moduleId) const absolutePath = './' + path.posix.join(dirname, p.node.source.value) p.node.source.value = absolutePath dependencies.push(absolutePath) &#125;, // 处理require方式导入 CallExpression(p) &#123; if(p.node.callee.name !== 'require') return const dirname = path.dirname(moduleId) const absolutePath = './' + path.posix.join(dirname, p.node.arguments[0].value) p.node.arguments[0].value = absolutePath dependencies.push(absolutePath) &#125; &#125;) // 将修改后的ast再次转换为可执行代码，并同时将es6语法转为es5 const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: ['@babel/preset-env'] &#125;) // 存储模块路径与引用关系 this.modules[moduleId] = &#123; code, dependencies &#125; // 递归分析文件多层依赖 dependencies.forEach(dependency =&gt; &#123; this.parseModules(dependency) &#125;) &#125; readFileSync(moduleId) &#123; let content = fs.readFileSync(moduleId, 'utf-8') content = this.handleLoader(moduleId, content) return content &#125; handleLoader(moduleId, content) &#123; const &#123; resolveLoader: &#123; modules: &#123; 0: loaderDirctory &#125; &#125;, module: &#123; rules = [] &#125; &#125; = this.config rules.forEach((&#123; test, loader = [] &#125;) =&gt; &#123; if(test.test(moduleId) &amp;&amp; loader.length) &#123; let item = null while(item = loader.pop()) &#123; const loaderFunc = require(path.join(loaderDirctory, item)) content = loaderFunc(content) &#125; &#125; &#125;) return content &#125; renderTemplate() &#123; const &#123; entry &#125; = this.config const modules = [] for (const module in this.modules) &#123; modules.push(` '$&#123;module&#125;': function (module, exports, require) &#123; eval($&#123;JSON.stringify(this.modules[module].code)&#125;) &#125; `) &#125; this.template = ` (function (modules) &#123; var installedModules = &#123;&#125; function require(moduleName) &#123; if (installedModules[moduleName]) &#123; return installedModules[moduleName].exports &#125; var module = installedModules[moduleName] = &#123; exports: &#123;&#125; &#125; modules[moduleName](module, module.exports, require) return module.exports &#125; return require('$&#123;entry&#125;') &#125;)(&#123;$&#123;modules.join(',')&#125;&#125;) ` &#125; writeFile() &#123; this.hooks.emit.call() const &#123; output: &#123; filename, path: dist &#125; &#125; = this.config fs.writeFile(path.resolve(dist, filename), this.template, (err) =&gt; &#123; if (err) throw err console.log('编译完成') &#125;) &#125;&#125;module.exports = Compiler z-less-loader编译less123456789101112const less = require('less')module.exports = function(source) &#123; // this.async() // const cb = this.callback let result = '' less.render(source, (err, output) =&gt; &#123; if (err) throw Error(err) result = output.css &#125;) return result&#125; z-style-loader插入css样式1234567891011// 该插件用于获取loader的options配置参数const loaderUtils = require('loader-utils')module.exports = function(source) &#123; const result = ` const style = document.createElement('style') style.innerText = $&#123;JSON.stringify(source)&#125; document.head.appendChild(style) ` return result&#125; ZPlugin插件注意webpack3.0与4.0版本的插件注册机制不太一致。 123456789101112131415161718192021222324252627282930313233class ZPlugin &#123; apply(compiler) &#123; compiler.hooks.entryOption.tap('ZPlugin', (entry) =&gt; &#123; console.log('===entryOption===\n', entry) &#125;) compiler.hooks.afterPlugins.tap('ZPlugin', () =&gt; &#123; console.log('===afterPlugins===\n') &#125;) compiler.hooks.beforeRun.tap('ZPlugin', () =&gt; &#123; console.log('===beforeRun===\n') &#125;) compiler.hooks.run.tap('ZPlugin', () =&gt; &#123; console.log('===run===\n') &#125;) compiler.hooks.beforeCompile.tap('ZPlugin', () =&gt; &#123; console.log('===beforeCompile===\n') &#125;) compiler.hooks.compile.tap('ZPlugin', () =&gt; &#123; console.log('===compile===\n') &#125;) compiler.hooks.afterCompile.tap('ZPlugin', () =&gt; &#123; console.log('===afterCompile===\n') &#125;) compiler.hooks.emit.tap('ZPlugin', () =&gt; &#123; console.log('===emit===\n') &#125;) compiler.hooks.done.tap('ZPlugin', () =&gt; &#123; console.log('===done===\n') &#125;) &#125;&#125;module.exports = ZPlugin end]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之Tapable]]></title>
    <url>%2F2019%2F03%2F25%2Fwebpack%E4%B9%8BTapable%2F</url>
    <content type="text"><![CDATA[Webpack本质上是一种事件流机制，利用tapable在不同生命周期注册事件，将各个插件串联起来，并在合适的时机执行，是一种典型的观察者模式（发布/订阅者模式）。官网地址 https://github.com/webpack/tapable 关于TapableTapable包含各种串行、并行以及其他各种组合的一个事件流库，webpack中用于控制事件周期任务，实际项目中也可以进行应用，如数据的监听传递等。以下是各种用法的模拟实现。 SyncHook1234567891011121314151617181920212223242526272829// const &#123; SyncHook &#125; = require('tapable')class SyncHook &#123; constructor() &#123; this.tasks = [] &#125; tap(name, task) &#123; this.tasks.push(task) &#125; call(...args) &#123; this.tasks.forEach(task =&gt; task(...args)) &#125;&#125;const queue = new SyncHook(['name'])queue.tap('0', (name) =&gt; &#123; console.log(name, 1)&#125;)queue.tap('1', (name) =&gt; &#123; console.log(name, 2)&#125;)queue.tap('2', (name) =&gt; &#123; console.log(name, 3)&#125;)queue.call('zbl')// const bus = new Vue()// bus.$on('a', (val) =&gt; console.log('done'))// bus.$emit('a', 'zbl') SyncBailHook12345678910111213141516171819202122232425262728293031// const &#123; SyncBailHook &#125; = require('tapable')class SyncBailHook &#123; constructor() &#123; this.tasks = [] &#125; tap(name, task) &#123; this.tasks.push(task) &#125; call(...args) &#123; // let copyTasks = this.tasks.slice() // let task = copyTasks.shift() // while(task &amp;&amp; !task(...args) === undefined) &#123; // task = copyTasks.shift() // &#125; this.tasks.some(task =&gt; task(...args) !== undefined) &#125;&#125;const queue = new SyncBailHook(['name'])queue.tap('0', (name) =&gt; &#123; console.log(name, 1) return null&#125;)queue.tap('1', (name) =&gt; &#123; console.log(name, 2)&#125;)queue.tap('2', (name) =&gt; &#123; console.log(name, 3)&#125;)queue.call('zbl') SyncWaterfallHook1234567891011121314151617181920212223242526272829// const &#123; SyncWaterfallHook &#125; = require('tapable')class SyncWaterfallHook &#123; constructor() &#123; this.tasks = [] &#125; tap(name, task) &#123; this.tasks.push(task) &#125; call(...args) &#123; this.tasks.reduce((a, b) =&gt; &#123; const result = b(...a) return result === undefined ? args : [result] &#125;, args) &#125;&#125;const queue = new SyncWaterfallHook(['name'])queue.tap('0', (name) =&gt; &#123; console.log(name, 1) return null&#125;)queue.tap('1', (name) =&gt; &#123; console.log(name, 2)&#125;)queue.tap('2', (name) =&gt; &#123; console.log(name, 3)&#125;)queue.call('zbl') SyncLoopHook12345678910111213141516171819202122232425262728293031323334353637383940414243// const &#123; SyncLoopHook &#125; = require('tapable')class SyncLoopHook &#123; constructor() &#123; this.tasks = [] &#125; tap(name, task) &#123; this.tasks.push(task) &#125; call(...args) &#123; // let tasks = this.tasks.slice(0) // let task, result // const next = () =&gt; &#123; // if(!tasks.length) return // if(result === undefined) &#123; // task = tasks.shift() // &#125; // result = task(...args) // next() // &#125; // next() this.tasks.forEach((task) =&gt; &#123; let result do &#123; result = task(...args) &#125; while (result !== undefined) &#125;) &#125;&#125;const queue = new SyncLoopHook(['name'])let count = 0queue.tap('0', (name) =&gt; &#123; console.log(name, 1) return count++ === 2 ? undefined : null&#125;)queue.tap('1', (name) =&gt; &#123; console.log(name, 2)&#125;)queue.tap('2', (name) =&gt; &#123; console.log(name, 3)&#125;)queue.call('zbl') AsyncParallelHook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// const &#123; AsyncParallelHook &#125; = require('tapable')class AsyncParallelHook &#123; constructor() &#123; this.tasks = [] &#125; tapAsync(name, task) &#123; this.tasks.push(task) &#125; callAsync(...args) &#123; const endCallback = args.pop() const len = this.tasks.length // 原理类似Promise.all let index = 0 const next = () =&gt; &#123; if(++index === len) endCallback() &#125; this.tasks.forEach((task) =&gt; task(...args, next)) &#125;&#125;const queue = new AsyncParallelHook(['name'])queue.tapAsync('0', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 1) cb() &#125;, 1000)&#125;)queue.tapAsync('1', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 2) cb() &#125;, 2000)&#125;)queue.tapAsync('2', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 3) cb() &#125;, 3000)&#125;)queue.callAsync('zbl', (err) =&gt; &#123; if(err) throw Error(err) console.log('done')&#125;)// tapPromise版本// class AsyncParallelHook &#123;// constructor() &#123;// this.tasks = []// &#125;// tapPromise(name, task) &#123;// this.tasks.push(task)// &#125;// promise(...args) &#123;// return Promise.all(this.tasks.map(task =&gt; task(...args)))// &#125;// &#125; AsyncParallelBailHook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// const &#123; AsyncParallelBailHook &#125; = require('tapable')// 说明：// AsyncParallelBailHook钩子，无论返回结果是什么，所有任务都会执行// 当任一函数reject真值，最后回调不走then直接走catch，reject空值时则相当于resolve// 该钩子如果处理同步，则和SyncBailHook效果一样// 如果处理tapSync，当遇到return true时，最后的callback将不会执行class AsyncParallelBailHook &#123; constructor() &#123; this.tasks = [] &#125; tapPromise(name, task) &#123; this.tasks.push(task) &#125; promise(...args) &#123; const tasks = this.tasks.map(task =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; task(...args).then(res =&gt; resolve(res)).catch(err =&gt; err ? reject(err) : resolve()) &#125;) &#125;) return Promise.all(tasks) &#125;&#125;const queue = new AsyncParallelBailHook(['name'])queue.tapPromise('0', (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 1) resolve() &#125;, 1000) &#125;)&#125;)queue.tapPromise('1', (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 2) // 不返回true值时reject相当于resolve reject() // reject('error') &#125;, 2000) &#125;)&#125;)queue.tapPromise('2', (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 3) resolve() &#125;, 3000) &#125;)&#125;)queue.promise('zbl').then(() =&gt; &#123; console.log('done')&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) AsyncSeriesHook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// const &#123; AsyncSeriesHook &#125; = require('tapable')class AsyncSeriesHook &#123; constructor() &#123; this.tasks = [] &#125; tapAsync(name, task) &#123; this.tasks.push(task) &#125; callAsync(...args) &#123; const endCallback = args.pop() const len = this.tasks.length let index = 0 const next = (res) =&gt; &#123; if(res || len === index) return endCallback(res) this.tasks[index++](...args, next) &#125; next() // 如果使用promise链式调用 // const tasks = this.tasks.slice(0) // return tasks.reduce((a, b) =&gt; &#123; // return a.then(b.bind(b, ...args)) // &#125;, tasks.shift()(...args)) &#125;&#125;const queue = new AsyncSeriesHook(['name'])queue.tapAsync('0', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 1) cb() &#125;, 1000)&#125;)queue.tapAsync('1', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 2) cb() &#125;, 2000)&#125;)queue.tapAsync('2', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 3) cb() &#125;, 3000)&#125;)queue.callAsync('zbl', (res) =&gt; &#123; console.log(res || 'done')&#125;) AsyncSeriesBailHook1234567891011121314151617181920212223242526272829303132333435363738394041424344// 该钩子与AsyncSeriesHook类似，只是在tap注册的事件里遇到return后将不再继续执行，直接跳到最后的回调// const &#123; AsyncSeriesBailHook &#125; = require('tapable')class AsyncSeriesBailHook &#123; constructor() &#123; this.tasks = [] &#125; tapAsync(name, task) &#123; this.tasks.push(task) &#125; callAsync(...args) &#123; const endCallback = args.pop() const len = this.tasks.length let index = 0 const next = (res) =&gt; &#123; if(res || len === index) return endCallback(res) this.tasks[index++](...args, next) &#125; next() &#125;&#125;const queue = new AsyncSeriesBailHook(['name'])queue.tapAsync('0', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 1) cb() &#125;, 1000)&#125;)queue.tapAsync('1', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 2) cb('wrong') &#125;, 2000)&#125;)queue.tapAsync('2', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 3) cb() &#125;, 3000)&#125;)queue.callAsync('zbl', (res) =&gt; &#123; console.log(res || 'done')&#125;) AsyncSeriesWaterfallHook123456789101112131415161718192021222324252627282930313233343536373839404142434445// const &#123; AsyncSeriesWaterfallHook &#125; = require('tapable')class AsyncSeriesWaterfallHook &#123; constructor() &#123; this.tasks = [] &#125; tapAsync(name, task) &#123; this.tasks.push(task) &#125; callAsync(...args) &#123; const endCallback = args.pop() const len = this.tasks.length let index = 0 const next = (...res) =&gt; &#123; const [error, ...rest] = res if(!rest.length) rest.push(...args) // 当cb无传参时取args参数 if(error || len === index) return endCallback(error) this.tasks[index++](...rest, next) &#125; next(null, ...args) &#125;&#125;const queue = new AsyncSeriesWaterfallHook(['name'])queue.tapAsync('0', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 1) cb() &#125;, 1000)&#125;)queue.tapAsync('1', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 2) cb(null, '3') &#125;, 2000)&#125;)queue.tapAsync('2', (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(name, 3) cb(null, '4') &#125;, 3000)&#125;)queue.callAsync('zbl', (res) =&gt; &#123; console.log(res || 'done')&#125;) 留个小问题有数组[‘a’, ‘b’, ‘c’], 以索引作为延时时长串行输出各个数组元素，即0秒后输出’a’, 1秒后输出’b’, 3秒后输出’c’（不是2秒）。 end]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之ast抽象语法树]]></title>
    <url>%2F2019%2F03%2F12%2Fwebpack%E4%B9%8Bast%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%2F</url>
    <content type="text"><![CDATA[抽象语法树(abstract syntax tree简写AST)，是一种将源代码抽象为一种树状结构的表现形式。js为开发者能更好的完成编程工作设计响应的语法，但这些语法并不适合程序理解，因此实际对语法进行程序分析时需要转化为AST进行应用，浏览器编译器一般会把源码转化为AST完成进一步分析操作应用等。 关于抽象语法树 通过解析器将源码抽象为一种树状结构的表现形式。 这颗树定义了代码的结构，可以精准的定位到声明语句、赋值语句、运算语句等。 可视化分析平台 https://astexplorer.net/ babel官方文档 https://babeljs.io/docs/en/babel-core 有啥用 代码语法检查、错误提示、自动补全 如esLint对代码错误检测 转换代码格式或结构 如babeljs将es6代码转换为es5 webpack替换引用路径代码混淆压缩 UglifyJS2等 常用的JavaScript ParserJavaScript Parser，把js源码转化为抽象语法树的解析器。浏览器会把js源码通过解析器转为抽象语法树，再进一步转化为字节码或直接生成机器码。一般来说每个js引擎都会有自己的抽象语法树格式，Chrome的v8引擎，firefox的SpiderMonkey引擎等等，MDN提供了详细SpiderMonkey AST format的详细说明，算是业界的标准。 babylon esprima traceur acorn shift 抽象语法树一个应用栗子将const a = 2 * 3 * 4; log(a);转换为const a = 2 * 3 * 4; console.log(a);。1234567891011121314151617181920const babel = require('@babel/core')const t = require('@babel/types')const code = `const a = 2 * 3 * 4; log(a);`const visitor = &#123; CallExpression(path) &#123; console.log(path.node) if (path.node.callee.name === 'log') &#123; const callee = t.memberExpression(t.identifier('console'), t.identifier('log')) const args = path.node.arguments path.replaceWith(t.callExpression(callee, args)) &#125; &#125;&#125;const result = babel.transform(code, &#123; plugins: [&#123; visitor &#125;]&#125;)console.log(result.code) astexplorer上的分析结果: end]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于webpack的require.context的自动化配置]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%9F%BA%E4%BA%8Ewebpack%E7%9A%84require.context%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack中提供require.context用于创建自己的（模块）上下文，并在代码构建时进行解析，类似于glob插件提供的glob.sync遍历文件方法，底层均是通过node提供的fs模块进行文件读取。基于该方法可以实现很多自动化配置，从而提高开发效率。 使用方法require.context(directory, useSubdirectories = false, regExp = /^.\//, mode = ‘sync’) 参数说明： directory: 需要搜索的文件夹目录（必传） useSubdirectories: 是否需要搜索它的子孙目录，默认为false regExp: 匹配文件名的正则表达式 mode: 加载模式，默认值sync同步加载，可选lazy、lazy-once、weak等，类似webpack提供的magic comment中的webpackMode返回值为一个函数，函数上挂在有id属性、keys方法，通过传入路径id加载对应组件官网地址： https://webpack.js.org/guides/dependency-management/#require-contextimport或者require里的路径必须是个静态的字符串，不然webpack识别不到，因为webpack打包的时候是静态分析，不是动态执行的，获取不到变量的值 以下列举require.context实现自动化载入组件的几种应用场景 路由自动注册12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @param &#123;*&#125; list 指定需要注册为路由的文件夹名称，不指定则为空数组，将遍历所有文件夹并注册为路由 * 其中require.context第一个参数需要根据不同目录调整，无法作为参数进行传递，webpack无法识别 * 第4个参数mode值，默认值'sync'，如果指定为'lazy'，则将异步加载基础模块，否则组件将直接被打包到入口包 * 该配置中要支持打包后组件重命名需要引入"[request]"动态传参，实参即为路径的动态参数， webpackPrefetch: 0在webpack4.0才支持，表明该组件资源将被预加载。 */// 根据指定目录下自动生成对应路由，暂不支持嵌套路由// 共用index单页下的部分路由const filterOptions = &#123; include: [], exclude: ['test', 'switch']&#125;// index单页路由function genRouters (&#123; include = [], exclude = [] &#125;) &#123; // 获取指定目录下所有文件 const contexts = require.context('page@/index/views/', true, /([\s\S]*)?\/index\.vue$/, 'lazy') // 通过路径匹配文件夹名称 let routers = [] contexts.keys().forEach(dir =&gt; &#123; const matchValue = /\/([\s\S]+)?\/index\.vue/g.exec(dir) if (!matchValue || !matchValue.length) return routers.push(matchValue[1]) &#125;) // 根据过滤条件筛选路由 if (!include.length &amp;&amp; exclude.length) &#123; routers = routers.filter(item =&gt; exclude.indexOf(item) === -1) &#125; if (include.length &amp;&amp; !exclude.length) &#123; routers = routers.filter(item =&gt; include.indexOf(item) &gt; -1) &#125; if (include.length &amp;&amp; exclude.length) &#123; routers = routers.filter(item =&gt; exclude.indexOf(item) === -1 &amp;&amp; include.indexOf(item) &gt; -1) &#125; // 遍历生成动态路由，支持组件命名与按需加载 return routers.map((router) =&gt; (&#123; path: '/' + router, name: router.trim().replace(/^[a-zA-Z]/g, v =&gt; v.toUpperCase()), component: () =&gt; import(/* webpackChunkName: "index-[request]", webpackPrefetch: 0 */ `page@/index/views/$&#123;router&#125;/`) &#125;))&#125;// 调用export default new Router(&#123; routes: [&#123; path: '/', redirect: '/home' &#125;, ...genRouters(filterOptions) ]&#125;) 自动注册全局组件123456789101112131415/** * @param &#123;*&#125; list 指定需要引入的组件名称，不指定则为空数组，将遍历所有组件 * 其中require.context第一个参数需要根据不同目录调整，无法作为参数进行传递，webpack无法识别 * https://cn.vuejs.org/v2/guide/components-registration.html */function registerGlobalComponent(list = []) &#123; const contexts = require.context('@/global', false, /\.vue$/) contexts.keys().forEach((dir) =&gt; &#123; const matchValue = /\/([\s\S]+)?\.vue/g.exec(dir) if (!matchValue || !matchValue.length) return if (list.length &amp;&amp; list.indexOf(matchValue[1]) === -1) return Vue.component(matchValue[1], contexts(dir).default || contexts(dir)) &#125;)&#125; 自动引入组件123456789101112131415161718192021/** * @param &#123;*&#125; list 指定需要引入的组件名称，不指定则为空数组，将遍历所有组件 * 其中require.context第一个参数需要根据不同目录调整，无法作为参数进行传递，webpack无法识别 */function importComponents(list = []) &#123; const components = &#123;&#125; const contexts = require.context('./comps', false, /\.vue$/) contexts.keys().forEach((dir) =&gt; &#123; const matchValue = /\/([\s\S]+)?\.vue/g.exec(dir) if (!matchValue || !matchValue.length) return if (list.length &amp;&amp; list.indexOf(matchValue[1]) === -1) return components[matchValue[1]] = contexts(dir).default || contexts(dir) &#125;) return components&#125;// 调用export default &#123; components: &#123;...getComponents() &#125;&#125; 自动载入分组api模块12345678910111213141516171819202122/** * @param &#123;*&#125; list 指定需要引入的组件名称，不指定则为空数组，将遍历所有组件 * 其中require.context第一个参数需要根据不同目录调整，无法作为参数进行传递，webpack无法识别 */function mergeApi(list = []) &#123; const obj = &#123;&#125; const contexts = require.context('/', false, /\.js$/) contexts.keys().forEach(dir =&gt; &#123; if (/index/g.test(dir)) return const modules = contexts(dir).default || contexts(dir) Object.keys(modules).forEach(key =&gt; &#123; obj[key] = modules[key] &#125;) &#125;) return obj&#125;export default mergeApi()// 调用import api from 'index@/api'api.getData() 自动载入vuex中module模块与上面自动载入分组api模块思路一致。 end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[借助css伪元素实现柱状图进度条]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%80%9F%E5%8A%A9css%E4%BC%AA%E5%85%83%E7%B4%A0%E5%AE%9E%E7%8E%B0%E6%9F%B1%E7%8A%B6%E5%9B%BE%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[编写css的一个基本原则是尽量减少dom元素的使用，借助before、after等伪元素即可达到这个目的。伪元素不是真实的dom元素，浏览器渲染的时候不会进行节点渲染，无法通过js脚本获取，从而可以减少dom层级的生成，从而可以提升性能。此外，借助伪元素可以保证标签的简洁性与可移植性。 啥都不多说，先来个基础的div元素，顺便给个itemclass类名，父元素wrapper包裹多个遍历元素。 123&lt;div class="wrapper"&gt; &lt;div class="item"&gt;&lt;/div&gt;&lt;/div&gt; 编写基础样式如下: 1234567891011121314151617html, body &#123; background: #000; margin: 50px;&#125;.item &#123; width: 300px; height: 40px; position: relative; background-color: rgb(255, 255, 255, .7);&#125;.item::before &#123; content: ''; width: 80%; height: 100%; position: absolute; background-color: red;&#125; 这里借助before伪元素相对定位，设置相对于父元素的width实现进度条占比，基本功能已实现，但考虑到实际开发中往往由数据进行遍历驱动样式，伪元素无法通过style样式进行动态设置，因此往往只能通过添加真实子元素进行动态赋值style。但终归需要多创建冗余的dom元素，影响性能。经过多方查找，借助于css3提供的css变量可以解决这个问题。在父元素上利用style局部设置一个变量名为--before-width的属性(必须以--开头)，然后在css样式中利用var关键字进行获取属性值(var第二个参数为默认值)，这样就可以实现动态传值，且作用域只局限在该父元素内，不影响全局。样式如下： 12345678910111213&lt;div class="item" style="--before-width: 80%"&gt;&lt;/div&gt;&lt;style&gt;.item::before &#123; content: ''; width: var(--before-width, 40%); height: 100%; position: absolute; background-color: red; animation: move 1s linear; transition: width 1s;&#125;&lt;/style&gt; 通过以上设置可以得到动态传值的目的，且一旦属性值发生变动，使用了该属性的任何样式将统一更新。另外还可以通过js脚本修改属性值，方法如下: 12345setTimeout(() =&gt; &#123; const el = document.querySelector('.item') const rate = '25%' el.style.setProperty('--before-width', rate)&#125;, 2000) 此外，刷新页面时进度条没有任何动画，显得太呆板，给加点animation瞧瞧，easy，来个transition: width 1s分分钟搞定。咦，我刷我刷我刷刷刷，怎么一动不动，只有当动态设置width值的时候才会有动作。是的，首次进入的时候transition没鸟用，只有当值发生变化时才能watch到载入动画。transition不行，不怕，还有animation，没有animation搞不定的开场嘛，这里还是需要使用到css变量指定动画目标值，样式设置如下： 12345678@keyframes move &#123; 0% &#123; width: 0; &#125; 100% &#123; width: var(--before-width, 40%); &#125;&#125; 差不多了，这时候产品看了看，咦，这个柱子鼠标移上去怎么一点效果都没有，都不知道选没选中，好吧，再给它加个悬浮选中框框。继续借助after伪元素加上hover属性棒棒哒，但是记得hover要写在前面哦，谁让它是老大，显不显示after得听它的，于是再加样式如下: 12345678910.item:hover::after &#123; content: ''; width: 120%; height: 140%; position: absolute; top: 50%; transform: translateY(-50%); background-color: rgb(255, 255, 255, .3); cursor: pointer;&#125; 欧了，大功告成！等等！我还想在柱子上加个占比数值！这这这，老夫没辙了啊，before用完了after用完了，只能借助于真实dom元素了啊，于是随手甩来一个i元素，分分钟解决。当然这里其实还是可以借助after伪元素的，因为上面只是用了hover后after，非hover状态下其实是可以用来标志占比值滴，当hover之后再进行样式覆盖即可，但使用场景有一定局限性，此处不表。 12345678910111213&lt;div class="wrapper"&gt; &lt;div class="item" style="--before-width: 80%"&gt;&lt;i class="text"&gt;80%&lt;/i&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.text &#123; font-size: 16px; position: absolute; top: 50%; transform: translateY(-50%); right: 0;&#125;&lt;/style&gt; 最后最后，完整代码来一份！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; background: #000; margin: 50px; &#125; .item &#123; width: 300px; height: 40px; position: relative; background-color: rgb(255, 255, 255, .7); &#125; .item::before &#123; content: ''; width: var(--before-width, 40%); height: 100%; position: absolute; background-color: red; animation: move 1s linear; transition: width 1s; &#125; .item:hover::after &#123; content: ''; width: 120%; height: 140%; position: absolute; top: 50%; transform: translateY(-50%); background-color: rgb(255, 255, 255, .3); cursor: pointer; &#125; .text &#123; font-size: 16px; position: absolute; top: 50%; transform: translateY(-50%); right: 0; &#125; @keyframes move &#123; 0% &#123; width: 0; &#125; 100% &#123; width: var(--before-width, 40%); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="item" style="--before-width: 80%"&gt;&lt;i class="text"&gt;80%&lt;/i&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; setTimeout(() =&gt; &#123; const el = document.querySelector('.item') const rate = '25%' el.style.setProperty('--before-width', rate) el.firstChild.innerHTML = rate &#125;, 2000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket客户端维持重连心跳机制]]></title>
    <url>%2F2018%2F12%2F16%2Fwebsocket%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%B4%E6%8C%81%E9%87%8D%E8%BF%9E%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[客户端创建websocket实例与服务端连接，正常情况下可以实时进行通讯，但可能存在几种意外可能，一个是客户端与服务端长时间没有进行数据传输时，服务端处于性能考虑会自动断开连接，一个是服务端部署重启的过程，最后一个是客户端或服务端任一端出现断网的情况。因此需要由客户端维持一个定时心跳来确保连接不会断开，即使断开之后也能重新连接上的一个机制。 通过一个ZWS类进行封装，并对外暴露一个create方法与close方法，有以下几点需要说明： 创建ws连接，连接成功后执行onopen回调，回调内执行心跳函数，心跳函数设定延迟时间后发送ping数据，服务器若响应则进入onmessage回调，继续调用心跳函数；若服务无响应则在延迟时间后执行关闭连接操作并触发onclose回调，执行reconnect定时重连操作，之后进入下一个周期。 客户端断网情况下，由客户端调用close方法，在一定时间后会触发onerror事件执行重连操作，断网环境下重连会触发onerror与onclose事件，联网环境下重连成功，重新进入上面步骤1。注意客户端触发onclose或onerror时机不确定，由客户端自行决定。 由服务端主动关闭连接会触发onclose事件并执行重连操作。 客户端隔一定时间发起心跳需要服务端配合响应message维持连接。 可配置参数：options = { url =&gt; 连接地址, beatTime =&gt; 心跳周期，默认值8000, reconnectTime =&gt; 重连周期，默认值5000, opencb =&gt; 成功连接回调, messagecb =&gt; 接收响应回调, closecb =&gt; 关闭连接回调, errorcb =&gt; 连接出错回调} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class ZWS &#123; constructor(options) &#123; const &#123; url, beatTime = 8000, reconnectTime = 5000, opencb, messagecb, closecb, errorcb &#125; = options this.url = url this.beatTime = beatTime this.reconnectTime = reconnectTime this.wsIns = null this.beatTimer = null this.delayTimer = null this.reconnectTimer = null this.isFinalClose = false this.opencb = opencb this.messagecb = messagecb this.closecb = closecb this.errorcb = errorcb &#125; create() &#123; const &#123; url, opencb, messagecb, closecb, errorcb &#125; = this this.wsIns = new WebSocket(url) this.wsIns.onclose = () =&gt; &#123; if(this.isFinalClose) return closecb &amp;&amp; closecb() this.reconnect() &#125; this.wsIns.onerror = () =&gt; &#123; if(this.isFinalClose) return errorcb &amp;&amp; errorcb() this.reconnect() &#125; this.wsIns.onopen = () =&gt; &#123; //心跳检测重置 opencb &amp;&amp; opencb() this.beat() &#125; this.wsIns.onmessage = () =&gt; &#123; messagecb &amp;&amp; messagecb() this.beat() &#125; &#125; beat() &#123; this.beatTimer &amp;&amp; clearTimeout(this.beatTimer) this.delayTimer &amp;&amp; clearTimeout(this.delayTimer) this.beatTimer = setTimeout(() =&gt; &#123; this.wsIns.send('ping') const _this = this this.delayTimer = setTimeout(() =&gt; &#123; _this.wsIns.close() console.log('do close') &#125;, _this.beatTime) &#125;, this.beatTime) console.log('beat fn') &#125; reconnect() &#123; this.reconnectTimer &amp;&amp; clearTimeout(this.reconnectTimer) this.reconnectTimer = setTimeout(this.create.bind(this), this.reconnectTime) console.log('reconnect fn') &#125; close() &#123; this.beatTimer &amp;&amp; clearTimeout(this.beatTimer) this.delayTimer &amp;&amp; clearTimeout(this.delayTimer) this.reconnectTimer &amp;&amp; clearTimeout(this.reconnectTimer) this.isFinalClose = true this.wsIns.close() &#125; &#125;// 调用 const ws = new ZWS(&#123; url: 'ws://121.40.165.18:8800', opencb: () =&gt; &#123; console.log('open') &#125;, closecb: () =&gt; &#123; console.log('close') &#125;, errorcb: () =&gt; &#123; console.log('error') &#125;, messagecb: () =&gt; &#123; console.log('message') &#125; &#125;) ws.create() end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道await执行顺序引发困惑的面试题]]></title>
    <url>%2F2018%2F11%2F18%2F%E4%B8%80%E9%81%93await%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%BC%95%E5%8F%91%E5%9B%B0%E6%83%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一篇关于宏任务、微任务，Promise与await/async较量的浅文，题目还可以有各种变样。。。 首先来个简单的栗子可以心心念念一下然后打开chrome(以下内容皆只针对chrome，其他浏览器不管不听不信)控制台，比对下心算结果，不管对与不对，坚持不懈往后再看。简单题目如下： 12345678910111213141516171819new Promise(resolve =&gt; &#123; console.log(1) new Promise((resolve2) =&gt; &#123; console.log(1.5) Promise.resolve(2).then(resolve2) &#125;).then(resolve)&#125;).then((res) =&gt; &#123; console.log(3, res)&#125;).then(() =&gt; &#123; console.log(4)&#125;)new Promise(resolve =&gt; &#123; resolve() console.log(11)&#125;).then(() =&gt; &#123; console.log(33)&#125;).then(() =&gt; &#123; console.log(44)&#125;) 接下来进入主题，改造某条后的一道面试题：12345678910111213141516171819202122232425262728293031323334async function fn1() &#123; console.log('a') await fn2() console.log('b')&#125;async function fn2() &#123; new Promise((resolve) =&gt; &#123; resolve() console.log('c') &#125;).then(function then1() &#123; console.log('e') &#125;).then(function then2() &#123; console.log('f') &#125;) Promise.resolve().then(function then3() &#123; console.log('s1') &#125;).then(function then4() &#123; console.log('s2') &#125;).then(function then5() &#123; console.log('s3') &#125;).then(function then6() &#123; console.log('s4') &#125;)&#125;console.log("g")setTimeout(() =&gt; console.log('h'), 0)fn1()new Promise((resolve) =&gt; &#123; console.log("i") resolve()&#125;).then(function then8() &#123; console.log("j")&#125;)console.log("k") 如果还不够刺激，可以试试把async去掉：12345678910111213141516171819202122232425262728293031323334async function fn1() &#123; console.log('a') await fn2() console.log('b')&#125;/* async(我要去掉哦) */ function fn2() &#123; new Promise((resolve) =&gt; &#123; resolve() console.log('c') &#125;).then(function then1() &#123; console.log('e') &#125;).then(function then2() &#123; console.log('f') &#125;) Promise.resolve().then(function then3() &#123; console.log('s1') &#125;).then(function then4() &#123; console.log('s2') &#125;).then(function then5() &#123; console.log('s3') &#125;).then(function then6() &#123; console.log('s4') &#125;)&#125;console.log("g")setTimeout(() =&gt; console.log('h'), 0)fn1()new Promise((resolve) =&gt; &#123; console.log("i") resolve()&#125;).then(function then8() &#123; console.log("j")&#125;)console.log("k") 好了， 3道题都放完了，先上波结论： await一个async函数，则await fn2()等价于以下: 1234567891011121314new Promise(resolve =&gt; &#123; resolve(Promise.resolve(fn2()))&#125;).then(() =&gt; &#123; // await之后所有代码放在该then里 console.log('b')&#125;)// =&gt; 再等价于以下：(基于Typescript中对Promise的定义)new Promise(resolve =&gt; &#123; new Promise(resolve2 =&gt; &#123; Promise.resolve(fn2()).then(resolve2) &#125;).then(resolve)&#125;).then(() =&gt; &#123; console.log('b')&#125;) await一个非async函数，则await fn2()等价于以下: 123456789101112new Promise(resolve =&gt; &#123; resolve(fn2())&#125;).then(() =&gt; &#123; // await之后所有代码放在该then里 console.log('b')&#125;)// =&gt; 再等价于以下：new Promise(resolve =&gt; &#123; Promise.resolve(fn2()).then(resolve)&#125;).then(() =&gt; &#123; console.log('b')&#125;) 接下来总结下第二道题的解析过程： script宏任务遇到console.log(&quot;g&quot;)直接打印g; 遇到setTimeout(() =&gt; console.log(&#39;h&#39;), 0)加入宏任务队列; 遇到fn1()立即打印a; 遇到Promise.resolve(fn2())先进入执行fn2()，打印c并将then1将入微任务队列，将&#39;then3加入微任务队列，fn2执行完毕，返回值默认为undefined; 接上面Promise.resolve(undefined)之后将then9将入微任务队列; 之后继续执行本轮任务中的同步代码，进入另一个Promise打印i并将then8加入微任务队列，打印k; 至此本轮宏任务同步代码全部执行完毕; 查询微任务队列，按加入顺序取出执行，因此依次打印e并将then2加入微任务队尾，打印s1并将then4加入微任务队尾，打印a1并将then10加入微任务队尾，打印j; 继续查询微任务队列，依次打印f，打印s2并将then5加入微任务队尾，打印a2并将then11加入微任务队尾; 继续查询微任务队列，依次打印s3并将then6加入微任务队尾，打印b; 继续查询微任务队列，打印s4，微任务队列清空; 查询宏任务队列，取出上面的定时器执行打印h，队列清空，程序结束。 第一题输出顺序：1 =&gt; 1.5 =&gt; 11 =&gt; 33 =&gt; 44 =&gt; 3 2 =&gt; 4第二题输出顺序：g =&gt; a =&gt; c =&gt; i =&gt; k =&gt; e =&gt; s1 =&gt; j =&gt; f =&gt; s2 =&gt; s3 =&gt; b =&gt; s4 =&gt; h第三题输出顺序：g =&gt; a =&gt; c =&gt; i =&gt; k =&gt; e =&gt; s1 =&gt; b =&gt; j =&gt; f =&gt; s2 =&gt; s3 =&gt; s4 =&gt; h end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态资源本地化缓存方案]]></title>
    <url>%2F2018%2F11%2F10%2F%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[针对第三方库或插件等不常修改的静态资源进行本地化存储，从而减少请求次数，提高加载效率。同时支持同步与异步加载按序加载，并提供加载完成后的回调操作。 本API作用是根据输入静态资源路径，首次将资源缓存至客户端localStorage，之后读取本地缓存加载资源，提高加载效率。静态资源可以是存在上下文依赖的同步方式，也可以是类似script async的异步方式，可根据不同类型进行维护。当前只支持js与css资源的缓存。 使用该方法需要提供2个参数，第一个为需要缓存的静态资源路径，一个是资源全部缓存成功的回调函数。 静态资源通过一个数组集合维护，注意如果存在依赖关系的资源包需要通过一个数组维护，没有依赖关系单独使用对象格式。 每个静态资源路径必填两个变量，一个是url指向访问资源的绝对路径，一个是key为该资源的文件名。url中通过一串日期进行版本控制，资源需要更新时升级日期即可。key的作用是当需要删除指定缓存资源时用于匹配，url留空且在key中指定要删除的缓存资源文件名即可完成删除。 callback参数用于当资源全部加载完成后触发的操作，比如vue项目中加载vue库等依赖之后才能触发vue实例化操作。 简单说下数组中按序异步加载资源的方案，这里借鉴了数组分块技术，每次提取一个数组元素进行操作，首先判断是否要删除该资源缓存，其次判断本地是否存在缓存，最后发起资源请求。当资源响应之后将该资源挂载到window对象上并缓存或更新至localStorage，之后继续提取下一个数组元素递归操作，直到最后一个元素遍历完成之后将该Promise状态置为resolved。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104const baseUrl = 'http://127.0.0.1:8080/'const sourceMap = [ [&#123; url: `$&#123;baseUrl&#125;static/js/maptalks.min.js?v2018082801`, key: 'maptalks.min.js' &#125;, &#123; url: `$&#123;baseUrl&#125;static/js/maptalks.markercluster.min.js?v2018092602`, key: 'maptalks.markercluster.min.js' &#125;, &#123; url: `$&#123;baseUrl&#125;static/js/maptalks.animatemarker.min.js?v2018101501`, key: 'maptalks.animatemarker.min.js' &#125; ], [&#123; url: `$&#123;baseUrl&#125;static/js/echarts4.min.js?v2018082801`, key: 'echarts4.min.js' &#125;, &#123; url: `$&#123;baseUrl&#125;static/js/echarts-liquidfill.min.js?v2018092501`, key: 'echarts-liquidfill.min.js' &#125; ], &#123; url: `$&#123;baseUrl&#125;static/css/maptalks.css?v2018082801`, key: 'maptalks.css' &#125;, &#123; url: `$&#123;baseUrl&#125;static/js/json_shenzhen_area_baidu.js?v2018082801`, key: 'json_shenzhen_area_baidu' &#125;, &#123; url: `$&#123;baseUrl&#125;static/js/json_shenzhen_bianjie_baidu.js?v2018082801`, key: 'json_shenzhen_bianjie_baidu' &#125;, &#123; url: `$&#123;baseUrl&#125;static/js/json_shenzhen_area_and_suo_baidu.js?v2018092601`, key: 'json_shenzhen_area_and_suo_baidu' &#125;]cacheVendor(sourceMap, () =&gt; &#123; console.log('well done!!!') &#125;)function cacheVendor(sourceMap, callback, win = window) &#123; const fetch = win.fetch, obj = win.Object Promise.all(sourceMap.map(item =&gt; &#123; return obj.prototype.toString.call(item) === '[object Array]' ? asyncFetch(item) : syncFetch(item) &#125;)).then(callback).catch((err) =&gt; &#123; alert('加载失败, 请刷新页面试试, ' + err) &#125;) function appendElement(url, content) &#123; const doc = document const type = /\.js/g.test(url) ? 'script' : 'style' const el = doc.createElement(type) el.innerHTML = content doc.querySelector('head').appendChild(el) &#125; function updateStorage(itemKey) &#123; obj.keys(localStorage).forEach(key =&gt; &#123; new RegExp(itemKey, 'g').test(key) &amp;&amp; localStorage.removeItem(key) &#125;) &#125; function syncFetch(item) &#123; return new Promise((resolve, reject) =&gt; &#123; const url = item.url if (!url) return updateStorage(item.key), resolve() const localStorageValue = localStorage[url] if (localStorageValue) return appendElement(url, localStorageValue), resolve() fetch(url).then((res) =&gt; res.text()).then((res) =&gt; &#123; appendElement(url, res) updateStorage(item.key) localStorage[url] = res resolve() &#125;).catch(reject) &#125;) &#125; function asyncFetch(arr) &#123; return new Promise((resolve, reject) =&gt; &#123; function cb() &#123; if (!arr || !arr.length) return resolve() const item = arr.shift() const url = item.url if (!url) return updateStorage(item.key), cb() const localStorageValue = localStorage[url] if (localStorageValue) return appendElement(url, localStorageValue), cb() createRequst(item) &#125; function createRequst(&#123; url, key &#125;) &#123; fetch(url).then(res =&gt; res.text()).then((res) =&gt; &#123; appendElement(url, res) updateStorage(key) localStorage[url] = res cb() &#125;).catch(reject) &#125; cb() &#125;) &#125;&#125; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈项目中首屏渲染的几点优化]]></title>
    <url>%2F2018%2F10%2F01%2F%E6%B5%85%E8%B0%88%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%A6%96%E5%B1%8F%E6%B8%B2%E6%9F%93%E7%9A%84%E5%87%A0%E7%82%B9%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端性能是一大重点模块，本文整理总结实际项目开发中使用到的几种针对首屏加载速度的优化方案，并将不断迭代更新。 v-if结合定时器按需渲染首先页面上存在多个tab切换的功能，且各tab之间相互独立，最开始做法是直接一个路由下通过v-if控制组件的渲染显示与隐藏，但这种方式会导致将所有组件一并打包到app.js文件中，导致包体积太大。后面采用根据业务功能划分层级路由的方式，达到组件按需加载目的，减少app.js文件大小，提升首屏加载与解析性能。另外，通过v-if结合定时器与动画在首屏加载组件时可以按一定顺序加载，突出重点内容并有组件进入动画效果，用户体验更好。 声明式预渲染考虑后面未加载tab被点击访问的可能性较大，因此采用&lt;link rel=&#39;prerender&#39; href=&#39;/example.html&#39;&gt;的方式进行页面预加载预渲染，该技术相当于在后台打开一个隐藏的tab，会下载所有的资源并创建DOM、渲染页面、执行JS等，当用户进入指定链接时，渲染完成的页面直接显示。还可以结合按钮的鼠标悬浮、离开事件等进行预加载与卸载。注意开发模式下不会触发预渲染。另外还可以结合preload预加载指定资源。 客户端本地缓存第三方库通过import、require引入的第三方库在build打包之后会生成一个vendor.js文件，引入的库越多体积越大，每次打包时间以及页面加载时间也就越长，且第三方库修改的可能性比较低，所以会造成一定资源浪费。优化的方式有2种，一种是直接通过script标签引入cdn托管的地址，一种是直接将这些库保存到客户端本地(localStorage)，直接读取不走请求减少加载时间，且可通过版本控制按需更新本地库的版本。一个原则是vendor包的大小gzip后不超过350k。 关键代码(建议在首页html入口中直接引入)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263~function() &#123; function appendExecElem(type, content) &#123; const elem = document.createElement(type) elem.type = type === 'style' ? 'text/css' : 'text/javascript' elem.innerHTML = content document.querySelector('head').appendChild(elem) &#125; function execHandler(url, content) &#123; // 根据不同类型处理 const matchRes = url.match(/\.js/g) appendExecElem(matchRes &amp;&amp; matchRes.length ? 'script' : 'style', content) &#125; function removeStorage(itemKey) &#123; // 删除或更新缓存 const reg = new RegExp(itemKey, 'g') Object.keys(localStorage).forEach(key =&gt; &#123; if(key.match(reg) &amp;&amp; key.match(reg).length) &#123; localStorage.removeItem(key) &#125; &#125;) &#125; function getResource(item) &#123; const url = item.url // 删除指定缓存接口 if (!url) &#123; removeStorage(item.key) return &#125; const localStorageValue = localStorage[url] // 存在缓存直接读取缓存 if(localStorageValue) &#123; execHandler(url, localStorageValue) return &#125; // 不存在缓存发起请求 const xhr = new XMLHttpRequest() xhr.timeout = 30000 xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; let result = xhr.responseText execHandler(url, result) removeStorage(item.key) localStorage[url] = result.toString() &#125; &#125; xhr.onerror = () =&gt; &#123; console.log('资源加载失败，请刷新页面重试') &#125; xhr.open('GET', url) xhr.send(null) &#125; // 静态资源请求列表,每次变更版本只需在url路径中更改日期即可替换原有缓存 // 其中key为查找缓存的关键字,当要删除指定缓存时，url留空，指定key值即可删除 const requestArray = [ &#123; url: `/static/js/echarts4.min.js?v2018082801`, key: 'echarts4.min.js' &#125;, &#123; url: `/static/css/reset.css?v2018082801`, key: 'reset.css' &#125; ] requestArray.forEach(item =&gt; &#123; getResource(item) &#125;)&#125;() 静态资源缓存与压缩打包完的static静态资源包跟后台协商，访问所有静态资源的响应头部信息中加上cache-control: max-age=xxx和last-modified和Etag，因为静态资源一旦上线发包之后基本不再更改，因此尽量走本地强制缓存，当强制缓存过期后走304校验缓存。另外服务端开启gzip压缩，效果谁用谁知道。 动态加载较大体积的工具包对于一些工具方法常常封装在util文件中，但方法越来越多代码量越来越大时，直接打包到app.js文件中显然不合适，本项目中util文件体积达到40+k，因此采用了动态加载的方式进行，借助ES7的import()方法可以拆分并按需加载文件，或者借用webpack提供的require.ensure方法也可异步加载资源，其他相关模块也可以通过这种方式进行动态按需加载，原则就是尽量减少app.js包的大小，为首屏加载渲染压缩时间，提高性能。12345678910// ES7按需加载方式,支持promiseimport(/* webpackChunkName: 'util' */ './util').then((modules) =&gt; &#123; Vue.prototype.$util = modules.myUtil&#125;)// webpack按需加载方式,支持命名require.ensure([], () =&gt; &#123; const modules = require('./util') Vue.prototype.$util = modules.myUtil&#125;, 'util') 开启GPU渲染动画代码层面，如果存在动画或者需要频繁回流重绘的DOM元素，建议单独设置为独立层，这样每次只针对该独立层范围内的回流，减少对页面其他元素的影响。设置为独立层的方式有: transform: translateZ(0)，z-index: 666，will-change: transform等。 webworker并行计算利用webworker子线程处理较长时间的纯逻辑数据处理，例如项目中地图坐标的一些相关计算等，可以充分利用CPU并发进行，但要注意webworker只是一个scope作用域，无法引用到window或document对象，所以也无法进行任何DOM相关的操作，包括从主进程传DOM元素给到子线程也是不被允许的。但window上诸如setTimeout、XHR、indexedDB等方法是可以操作的。谨记主进程与子进程之间的数据传递都是一种深度拷贝，对象之间的传递需要通过JSON.stringify或toString方法处理，这样可能会导致类、函数被过滤。 原生封装替换第三方库对于浏览器兼容要求不高的项目，可以不必引用axios库，该库大部分功能用不到，常用的主要是get与post，因此完成可以自己用原生XHR封装一个，或者直接调用window.fetch方法，该方法支持Promise，去掉axios库至少打包可以减少13k，一定程度上优化首屏渲染效率。fetch方法在webworker中也支持，因此可以结合起来在子线程中发起请求。1234567891011121314importScripts('paths.js') // 注意作用域const urls = Object.values(self.paths)async function getData(url) &#123; const res = await fetch(url, &#123; method: 'GET', headers: &#123; 'accept': 'application/json' &#125; &#125;).then(res =&gt; res.json()) self.postMessage(res)&#125;urls.forEach(url =&gt; &#123; getData(url) &#125;) 组件的DOM缓存利用官网提供的keep-alive全局组件对v-if或者路由跳转组件进行缓存，从而减少重渲染时间，提升用户体验，只在activated周期中更新接口数据以及在deactivated中销毁定时器即可。 客户端本地存储的利用对于SPA项目而言，最耗时的主要还是接口请求这一块，偏偏项目中查询接口数量巨多，因此就得考虑如何缓存接口数据的问题，确保首屏渲染时利用最后一次缓存数据先占位，等待请求接口返回后更新替换。这是个比较大的工程，这里暂时提供几个思路： 一种方案是利用浏览器IndexedDB无体积限制的非关系型数据库缓存最后一次接口请求的数据，当页面再次打开时直接将数据读取到某个变量(该过程为异步过程)，最后请求接口数据返回后重新更新DB库并通知引用变量更新触发页面刷新。 另一种方案是将页面中的接口单独提取出来，与页面渲染并行进行，同时借助webworker开启子进程处理所有请求，以期更快获取到数据，但需要考虑数据分传的问题。 最后一种是充分利用PWA中的serviceWorker缓存技术，可以很好的缓存并自动更新指定的资源，但存在较大的兼容性问题。简单代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// sw.js文件var VERSION = 'v1.0'// 缓存self.addEventListener('install', function(event) &#123; event.waitUntil( caches.open(VERSION).then(function(cache) &#123; return cache.addAll([ './index.html', './static/echarts4.min.js', './static/mm.jpg' ]) &#125;) )&#125;)// 缓存更新self.addEventListener('activate', function(event) &#123; event.waitUntil( caches.keys().then(function(cacheNames) &#123; return Promise.all( cacheNames.map(function(cacheName) &#123; // 如果当前版本和缓存版本不一致 if (cacheName !== VERSION) &#123; return caches.delete(cacheName) &#125; &#125;) ) &#125;) )&#125;)// 捕获请求并返回缓存数据self.addEventListener('fetch', function(event) &#123; event.respondWith(caches.match(event.request).catch(function() &#123; &#125;).then(function(response) &#123; caches.open(VERSION).then(function(cache) &#123; cache.put(event.request, response) &#125;) return response.clone() &#125;).catch(function() &#123; return caches.match('./static/mm.jpg') &#125;))&#125;) css样式的复用不要在每个class类里面写一遍display:flex，这样每次编译加上前缀后至少多出3行代码，更优做法是充分利用共用样式库，保证一个css类的样式单一化，提高css解耦性与复用性，从而减少统一打包后出现很多冗余代码。另外在保证不冲突的情况下不使用局部样式，局部样式的每个类名上都会加上一段哈希值，导致代码冗长。同理减少类的层级也是一个要考虑的问题，原则上尽量不超过3级。 webpack持久化缓存采用webpack持久化缓存方案，主要出发点是通过控制文件的hash实现浏览器本地缓存的作用，可以考虑以下几点： output输出的文件名中使用chunkhash，根据文件内容生成唯一hash值，但当结合ExtractTextPlugin插件提取css样式的时候涉及到异步抽取流程，因此会出现hash异动，此时将hash的生成换成ExtractTextPlugin提供的contenthash规则即可保证只修改变动的文件hash。 使用HashedModuleIdsPlugin插件确保moduleId固化，有点类似vue/react中循环列表时要求提供key值，从而避免重复生成。 使用ModuleConcatenationPlugin插件提升变量作用域，减少冗余闭包使用，提升性能。 单独提取每次打包导致变动的manifest文件，该文件存储了模块的映射关系，因此必须优先引入，之后webpack才知道加载顺序，但由于manifest文件体积很小，大约1k左右，因此可以考虑将其直接内联到index.html入口文件中去。这里使用了ScriptExtHtmlWebpackPlugin插件实现。此外该插件还提供资源的preload/prefetch，可以提前预加载之后需要使用到的资源。 诸如页面适配脚本或者动态创建script加载其他资源的代码块也可以添加到主入口中，此时也可以借助ScriptExtHtmlWebpackPlugin插件将其内敛到页面特定位置，此时就需要在HtmlWebpackPlugin插件中配置文件的插入顺序了，可以通过下面代码按指定顺序注入页面中。 1234567891011121314151617181920new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', title: '/mqs-view/pages/', inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, // necessary to consistently work with multiple chunks via CommonsChunkPlugin =&gt; 'dependency' chunksSortMode: (a, b) =&gt; &#123; const chunksort = ['manifest', 'inlineScript', 'vendor', 'app'] // 指定的注入顺序 let aIndex = chunksort.indexOf(a.names[0]) let bIndex = chunksort.indexOf(b.names[0]) aIndex = aIndex &lt; 0 ? chunksort.length + 1 : aIndex bIndex = bIndex &lt; 0 ? chunksort.length + 1 : bIndex return aIndex - bIndex &#125;&#125;) 生产环境下在UglifyJsPlugin插件中的compress字段里开启drop_debugger``drop_console为true将脚本中的console.log与debugger相关代码删除，减少无效代码执行。 使用骨架屏增加骨架屏提高用户体验，首屏加载时根据不同路由展示不同的骨架屏效果。原理是利用根节点元素如&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;会被覆盖渲染，因此在初始状态时可以再其innerHTML中赋予相应的骨架屏背景图或者其他的脚本交互等。 服务端与预渲染使用预渲染prerender-spa-plugin或者ssr后端渲染vue-server-renderer的方式直接加载渲染完成的html文本，大大提高效率。 预渲染所使用插件prerender-spa-plugin充分利用了Puppeteer页面爬取的功能。Puppeteer是Chrome官方出品的headlessChrome node库，该库提供一系列的API，可以在无UI界面的情况下模拟真实Chrome的功能，适用于爬虫、自动化处理等各种场景。 SPA预渲染方案的原理就是在webpack构建阶段的最后，在本地启动一个Puppeteer的服务，访问所配置的预渲染路由，然后将然后将生成的节点输出到HTML文件中，并建立路由对应目录。改方案最大特点是配置简单，倾入性低，效果较明显，但针对时效性强的数据不太适合。此外，可尝试将生成的预渲染页面结合骨架屏进行使用，从而保证预渲染的静态页面预最后呈现的页面间的自然切换。 该过程依赖的插件prerender-spa-plugin安装完成后会执行一段脚本下载Chromium内核，该下载需要翻墙，压缩包体积100M左右，npm install完成之后在webpack.prod.conf.js文件中引入，并在HtmlWebpackPlugin之后配置如下预渲染选项： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 插件引入部分const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderer// 以下为配置部分new PrerenderSPAPlugin(&#123; // 该路径代表了在`npm run build`之后开启监听的路径，Chromium默认开启`localhost:8000`，可通过字段server配置端口号，如下staticDir配置将会托管dist文件目录 staticDir: path.join(__dirname, '../dist'), // 打包后文件输出路径，默认与staticDir配置相同 // outputDir: path.join(__dirname, '../dist'), // 该部分表示需要预渲染的路由，前提需要将router模式改为history，并且如果部署环境非根目录，而是放在baseDir目录下，则在router中还需配置base或者直接写全路由路径，否则会出现白屏 routes: ['/baseDir/', '/baseDir/page1', '/baseDir/page2'], // 渲染内核配置部分 renderer: new Renderer(&#123; // 以下2个配置在预渲染打开Chromium浏览器时会挂载到window对象上，访问途径`window.__PRERENDER_INJECTED.isPrerenderMode`，该配置很大的作用是用于区分预渲染环境与正式环境，从而指定不同接口基准路径访问测试环境数据与正式环境数据，如`const base = window.__PRERENDER_INJECTED &amp;&amp; window.__PRERENDER_INJECTED.isPrerenderMode ? 'http://localhost:10086/baseDir/' : '/baseDir/'` injectProperty: '__PRERENDER_INJECTED', inject: &#123; isPrerenderMode: true &#125;, // 配置是否在build过程中打开Chromium界面，建议设置为false，方便debugger看到build端口并验证路由地址 headless: false, // 该配置为触发渲染的事件名，在main.js中Vue实例挂载完成之后执行document.dispatchEvent(new Event('render-event'))触发预渲染执行。 renderAfterDocumentEvent: 'render-event' &#125;), // 服务端口配置 server: &#123; port: 8000 &#125;, // 延时执行渲染配置 // renderAfterTime: 5000, // 代码压缩部分配置 minify: &#123; collapseBooleanAttributes: true, collapseWhitespace: true, decodeEntities: true, keepClosingSlash: true, sortAttributes: true &#125;&#125;)// Vue实例化部分new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;', // 触发预渲染 mounted() &#123; document.dispatchEvent(new Event('render-event')) &#125;&#125;) 预渲染效果图： end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keyframes动画的动态生成]]></title>
    <url>%2F2018%2F09%2F18%2Fkeyframes%E5%8A%A8%E7%94%BB%E7%9A%84%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[本文就最近开发的一个婚礼现场弹幕互动小程序中遇到的一个动画需求进行总结，其要点是解决css3中animation涉及到的keyframes字段如何根据不同屏幕宽度进行动态适配设置。 贴两张图看看先效果 第一个问题，弹幕的移动采用js操作dom元素的方案还是使用css3动画控制的方案。 采用定时器动态设置dom元素的transform或者left相对定位属性相对来讲比较灵活，还可以更好的控制速度等，但代价是性能的开销增大，特别是当同时存在较多弹幕的情况下，一者可能由于定时器的机制问题导致卡顿(这个是可以采用requestAnimationFrame去改善)，一者可能由于同时多个高频的dom操作导致卡顿无可避免。采用css3原生动画的方式对于浏览器来讲就顺畅多了，而且不需要有太多的代码操控，但也因此对于速度等的控制就不够灵活。最后考虑到发射弹幕条数较多的情况，实际应用中采用了css3动画的方式进行弹幕的循环移动。 第二个问题，如何根据屏幕适配移动距离的问题。 由于keyframes是针对animation提供一个定义动画帧的入口，只能以显性声明的方式声明需要动画的属性特性。但由于不同客户端屏幕宽度不确定，弹幕从右到左移动屏幕宽度的距离需要根据屏幕宽度设定，因此需要在keyframes中设置的translateX属性值需要动态设置。此时想到了是否可以根据屏幕宽度先动态计算生成keyframes，然后再通过style标签赋值的方式动态插入并生效。于是身体力行的写了如下代码，发现成功生效，内心喜滋滋一般。12345678910111213141516171819~function () &#123; const clientWidth = document.documentElement.clientWidth const style = document.createElement('style') let str = '' for (let i = 0, len = 4; i &lt; len; i++) &#123; str += ` @keyframes move$&#123;i&#125; &#123; from &#123; transform: translateX(100%); &#125; to &#123; transform: translateX(-$&#123;clientWidth&#125;px); &#125; &#125; ` &#125; style.innerHTML = str document.querySelector('head').appendChild(style)&#125;() 第三个问题，切换到小程序大坑，由于小程序无法操作dom元素，以上方案无缚鸡之力，如何救？ 最开始没有好的方案，无奈只想到了通过media query媒介查询的方式进行多个机型宽度的适配，如下样式：1234567891011121314151617181920@media screen and (max-width: 320rpx) &#123; @keyframes move1 &#123; from &#123; transform: translateX(100%); &#125; to &#123; transform: translateX(-320rpx); &#125; &#125;&#125;@media screen and (max-width: 440rpx) &#123; @keyframes move1 &#123; from &#123; transform: translateX(100%); &#125; to &#123; transform: translateX(-440rpx); &#125; &#125;&#125; 后面偶然看到一种css变量的东西，可以在css属性值中引入变量，amizing！于是尝试了如下写法，其中”–client-width”属性的属性值由wx.getSystemInfoSync().windowWidthapi获取并设置为根元素的一对属性与属性值，小程序的兼容性还是很好的，刷新小程序后简值的生效了。当然这种方案也可以应用在pc端上。12345678@keyframes move1 &#123; from &#123; transform: translateX(100%); &#125; to &#123; transform: translateX(- var(--client-width)); &#125;&#125; 最后一个问题，关于轮询弹幕并展示的逻辑 项目中的实际做法是假设页面从上至下展示4行弹幕，那么维护一个二维数组存储每一行的弹幕数据，然后通过循环渲染到页面，并应用上面所列的css3动画。项目中同时也维持了两类定时器，一个是后台数据的轮询(每次轮询的时候带上当前已获得的弹幕条数后台接口即可判断该从哪里继续返回数据，当然也是可以采用websocket的server push)，一个是控制弹幕出现速度的定时器。每次接口获取到的数据将放入一个固定的数组进行维护，另外控制弹幕出现的定时器则每次从该数组中shift一条数据往循环渲染的数组中push，从而页面上响应该条新数据渲染出来。关键代码：123456789function pushList(idx) &#123; resList.length &amp;&amp; danList[idx].push(resList.shift())&#125;function _setInterval(timerName, fn, delay) &#123; fn() timer[timerName] &amp;&amp; clearTimeout(timer[timerName]) timer[timerName] = setTimeout(_setInterval.bind(this, timerName, fn, delay), delay)&#125;_setInterval(`danmuTimer$&#123;i&#125;`, pushList.bind(null, i), delay) end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍并演示几种常见的设计模式]]></title>
    <url>%2F2018%2F08%2F12%2F%E4%BB%8B%E7%BB%8D%E5%B9%B6%E6%BC%94%E7%A4%BA%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文主要介绍并使用代码演示几种常见的设计模式，总体上讲设计是原则是思想，是对模式的指导，而模式是对设计原则的实践与应用。前端领域最主要的两点设计原则是单一职责原则以及开放封闭原则，也是大部分模式实践的集中体现。 工厂模式在对象实例化外层包装一个引用方法，这个方法就是工厂，返回值为该实例化对象。作用是封装new操作，并且在返回实例化对象前可以增加业务处理，隐藏真实类，统一入口，书写简洁。12345678910111213141516171819202122232425class Product &#123; constructor(name) &#123; this.name = name &#125; init() &#123; console.log('init done') &#125;&#125;// 创建一个工厂class Creator &#123; create(name) &#123; // 此处可以增加一些业务逻辑处理... return new Product(name) &#125;&#125;// 调用const creator = new Creator()const p = creator.create('food')p.init()// jquery中的使用window.$ = function(selector) &#123; return new jQuery(selector)&#125; 单例模式将类封装在一个方法内，并通过该方法每次调用都返回一个完全相同的实例。作用是减少多次实例化造成的性能开销，且多次调用返回的对象之间可以共享实例化对象的状态。vuex、redux中使用的也属于单例状态共享模式。 如果上述SingleObject直接暴露在全局环境是无法保证不被直接new操作，因此最好结合工厂模式进行一层封装，或者使用模块化单独只export方法。 12345678910111213141516171819202122232425262728293031323334class SingleObject &#123; constructor() &#123; this.isLogin = false &#125; login() &#123; this.isLogin = true console.log('login success') &#125;&#125;SingleObject.getInstance = (function() &#123; let instance = null return function() &#123; instance = instance || new SingleObject() return instance &#125;&#125;)()// 调用const s1 = SingleObject.getInstance()console.log(s1.isLogin)s1.login()const s2 = SingleObject.getInstance()console.log(s1.isLogin)console.log(s1 === s2) // true// jquery中的使用,当页面中重复引入多个jQuery可以避免产生bug~function() &#123; if(!window.jQuery) &#123; return window.jQuery &#125; else &#123; ... &#125;&#125; 适配器模式新瓶装旧酒的一种模式，主要用于包装提供新的api或者转换历史代码。作用是服从开放封闭原则，尽量减少现有代码修改，包装中还可以添加新的逻辑，也便于维护。vue中的computed与filter也类似于适配器模式，提供一个中间层转换。12345678910111213141516171819202122class Http &#123; constructor() &#123; this.axiosIns = axios.create() &#125; get(url, params = &#123;&#125;) =&gt; &#123; const query = Object.keys(params).map(key =&gt; &#123; return `$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(params[key])&#125;` &#125;).join('&amp;') return query ? this.axiosIns.get(url + '?' + query) : this.axiosIns.get(url) &#125;, post(url, params = &#123;&#125;) =&gt; &#123; return this.axiosIns.post(url, params) &#125;, upload(url, data = &#123;&#125;) =&gt; &#123; let params = new FormData() Object.keys(data).forEach(key =&gt; &#123; params.append(key, data[key]) &#125;) return this.axiosIns(&#123; method: 'post', url, data: params, headers: &#123;'Content-Type': 'multiple/form-data'&#125; &#125;) &#125;&#125;const http = new Http()http.get()http.post() 装饰器模式在不改动现有方法代码的基础上，给现有方法增加中间件从而实现扩能，简单理解就是函数的嵌套调用。作用是各方法可以实现功能单一化，通过装饰器进行融合，从而降低代码耦合度，提高容错率。nodejs中的Koa框架使用中间件的机制就是一种装饰器的模式。第三方库core-decorators提供常见的几种装饰器，如readonly、log、deprecate等。12345678910111213141516171819202122232425262728293031323334353637383940414243class Circle &#123; draw() &#123; console.log('draw a circle') &#125;&#125;class Decorator &#123; constructor(circle) &#123; this.circle = circle &#125; draw() &#123; this.circle.draw() this.setColor() &#125; setColor() &#123; console.log('set a red color') &#125;&#125;// 调用const circle = new Circle()const decorator = new Decorator(circle)decorator.draw()// ES7中引入的装饰器语法: @function() &#123;&#125;，@+函数的形式写在需要装饰的类上const log = &#123; log() &#123; console.log('log...') &#125;&#125;function mixins(...args) &#123; return function(target) &#123; Object.assign(target.prototype, ...args) &#125;&#125;@mixins(log)class Log &#123;&#125;// 调用const a = new Log()a.log() 代理模式将普通对象通过代理模式增加读写权限与响应逻辑，同时将各种修改映射到原普通对象上。作用是提供具备数据权限控制的操作入口，灵活且使数据的读写具备响应式。ES5中的Object.defineProperty与ES6中的new Proxy均为代理模式，vue中响应式原理以及将data属性代理到vm实例都基于该模式。DOM元素中利用冒泡将子元素事件转移到父元素上也是一种典型的代理模式。1234567891011121314151617181920212223242526272829303132333435const vmData = &#123; name: 'zhangsan', age: 25, phone: '13566666666', price: 20000&#125;const proxyData = new Proxy(vmData, &#123; get: function(target, key) &#123; if(key === 'phone') &#123; return '13588888888' &#125; return target[key] &#125;, set: function(target, key, value) &#123; if(key === 'price') &#123; console.log(target, key, value) if(value &gt; 20000) &#123; target[key] = value return true &#125; return false &#125; return false &#125;&#125;)// 调用console.log(proxyData.phone) // 13588888888proxyData.price = 19000console.log(proxyData.price) // 20000proxyData.price = 21000console.log(proxyData.price) // 21000proxyData.age = 18console.log(proxyData.age) // 25 适配器模式、装饰器模式与代理模式的区别适配器模式： 针对原有接口提供一个不同的转换接口装饰器模式： 针对原有接口拓展功能，且保留原有接口功能不变可直接使用代理模式： 针对原有接口提供一个相同的接口，但功能经过权限控制与阉割 观察者模式前端中大量使用的一种模式，特点是一对n的发布与订阅，特别适合于异步程序，被动监听，业务解耦。作用是提供一种与用户交互的响应模式，如点击事件，还可用于解决异步回调，如promise.then，以及自定义数据传递，如vue中全局的Bus事件。使用场景包括DOM元素的事件监听、nodejs中EventEmitter自定义事件、websocket、Promise、jQuery中callBack、vue Bus、vue watch、vue/React生命周期等。1234567891011121314151617181920212223242526272829303132class myEvent &#123; constructor() &#123; this.obj = &#123;&#125; &#125; on(name, handler) &#123; if(!this.obj[name]) &#123; this.obj[name] = [] &#125; this.obj[name].push(handler) &#125; emit(name, ...args) &#123; if(!this.obj[name] || !this.obj[name].length) return this.obj[name].forEach(fn =&gt; &#123; fn(...args) &#125;) &#125; off(name, handler) &#123; if(!this.obj[name] || !this.obj[name].length) return this.obj[name].forEach((fn, index) =&gt; &#123; if(fn === handler) &#123; this.obj[name].splice(index, 1) &#125; &#125;) &#125;&#125;// 使用function handler(...args) &#123; console.log('done', ...args)&#125;const event = new myEvent()event.on('done', handler)event.emit('done', 'success')event.emit('done', 'fail') 迭代器模式一种统一用于遍历有序集合的模式，包括Array、Map、Set、String、arguments、NodeList、TypedArray等，以上所有数据都带有[Symbol.iterator]属性。作用是提供一个针对有序集合统一的遍历接口，并提升迭代性能，任何带有遍历器特性[Symbol.iterator]的数据类型都可以使用该迭代器遍历。ES6中引入的Iterator迭代器正是该模式的实现，且为简化调用过程，提供了for…of语法糖。12345678910111213141516171819202122232425262728293031323334class Iterator &#123; constructor(list) &#123; this.list = list this.index = 0 &#125; next() &#123; return this.list.length === this.index ? &#123;value: this.list[this.index], done: true&#125; : &#123;value: this.list[this.index++], done: false&#125; &#125;&#125;// 调用const iterator = new Iterator([1,6,3,8,1])let result = &#123; done: false &#125;while(!result.done) &#123; result = iterator.next() console.log(result)&#125;// ES6的迭代器Array.prototype[Symbol.iterator] // 输出一个函数Array.prototype[Symbol.iterator]() // 输出一个迭代器Array.prototype[Symbol.iterator]().next() // 输出遍历对象第一个值// 封装一个类似for...of的方法function each(list) &#123; const iterator = list[Symbol.iterator]() let item = &#123; done: false &#125; while(!item.done) &#123; item = iterator.next() !item.done &amp;&amp; console.log(item) &#125;&#125;each(document.querySelectorAll('div')) 状态模式某一个功能状态可以按某种规则进行转换，如关注与取消关注，交通信号灯、Promise的pending、fullfilled、rejected三种有限状态机等等。作用是将状态与业务分离，状态独立进行管理，减少耦合减少if...else逻辑，状态管理中可以根据规则控制状态的转换，如pending -&gt; fullfilled只能单向流动。vuex与redux中单向数据流也是集中状态管理的应用。推荐一个有限状态机的第三方库，javascript-state-machine，可方便的管理各式状态。1234567891011121314151617181920212223242526272829303132333435class State &#123; constructor(state) &#123; this.state = state &#125; setState(context) &#123; if(context.state === 'pending') &#123; context.setState(this.state) &#125; &#125;&#125;class MyPromise &#123; constructor() &#123; this.state = 'pending' &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state &#125;&#125;// 调用const myPromise = new MyPromise()const pending = new State('pending')const fullfilled = new State('fullfilled')const rejected = new State('rejected')console.log(myPromise.getState()) // pendingfullfilled.setState(myPromise)console.log(myPromise.getState()) // fullfilledrejected.setState(myPromise)console.log(myPromise.getState()) // fullfilledpending.setState(myPromise)console.log(myPromise.getState()) // fullfilled 原型模式通过原型继承的方式创建新的对象，并且每个通过该方式创建的对象可以继承共享该原型中的属性与方法。作用是减少重复性方法或属性的声明与内存占用，创建的对象也可以通过自身声明挂载同名方法或属性进行覆盖操作。prototype机制是作为ES6中class的一种底层实现原理，Object.create是原型模式的一种实现。1234567891011121314const prototypeObject = &#123; getName: function() &#123; return this.firstName + ' ' + this.lastName &#125;, age: 25, firstName: 'test', lastName: 'name'&#125;const someone = Object.create(prototypeObject)someone.firstName = 'zhang'someone.lastName = 'three'console.log(someone.getName())someone.age 备忘录模式顾名思义就是提供一种数据缓存备份的模式，可在需要的时候读取还原。作用是提供一种数据缓存的空间，典型的如富文本编辑器的撤销操作就是一种备忘缓存123456789101112131415161718192021222324252627282930313233343536373839class Backup &#123; constructor() &#123; this.containList = [] &#125; get(index) &#123; return this.containList[index] &#125; set(content) &#123; this.containList.push(content) &#125;&#125;class Editor &#123; constructor(backup) &#123; this.backup = backup this.content = '' &#125; setContent(content) &#123; this.content = content &#125; getContentFromBackup(index) &#123; return this.backup.get(index) &#125; setContentToBackup() &#123; this.backup.set(this.content) &#125;&#125;// 调用const backup = new Backup()const editor = new Editor(backup)editor.setContent('111')editor.setContent('222') // 输入值editor.setContentToBackup() // 点击保存editor.setContent('333') // 继续输入值editor.setContentToBackup() // 点击保存editor.setContent('444') // 继续输入值editor.getContentFromBackup(1) // 点击撤销editor.getContentFromBackup(0) // 点击撤销 end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一段mock线上接口脚本]]></title>
    <url>%2F2018%2F08%2F10%2F%E4%B8%80%E6%AE%B5mock%E7%BA%BF%E4%B8%8A%E6%8E%A5%E5%8F%A3%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[最近主要写数据可视化项目，特点是数据查询接口多，前端开发需要依赖后台接口服务比较被动，因此写了个脚本，一键爬取线上接口并输出本地模拟的mock接口。好处是摆脱内网开发环境的限制，只需切换不同代理，即可何时何地任性开发，mock数据还可根据需要任意修改调整。 特点： 第三方依赖express、axios库，其中express在vue-cli中默认安装，axios也为前端常用库，因此不需要安装多余依赖。 只支持不带参的get请求，或者将参数通过queryString方式拼接到url后面，post等带参请求不支持。 使用：给出请求接口数组集，配置好接口ip、输出文件名、mock监听端口、以及涉及需要验证的参数，配置完之后node控制台执行代码即可在当前目录下生成mock文件，默认输出server.js文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const express = require('express')const app = express()const fs = require('fs')const path = require('path')const axios = require('axios')// 请求的地址格式转为数组集let urls = require('../http/paths')urls = Object.values(urls)// 配置项const config = &#123; base: 'http://10.118.141.216:8080', // 接口的ip与端口 outputFilename: 'server.js', // 输出的文件名 serverPort: '10086', // 输出的mock文件监听的端口 authKey: 'Cookie', // 接口如果需要验证的字段 authValue: 'JSESSIONID=aaa666' // 验证值&#125;// 请求配置项const reqConfig = &#123; timeout: 10000, responseType: 'json', headers: &#123; 'Content-Type': 'application/json; charset=utf-8' &#125;&#125;if(Array.isArray(urls) &amp;&amp; !urls.length) &#123; console.log('request urls are required') return&#125;if(!config.base) &#123; console.log('you have to give a request base url first') return&#125;if(config.authKey) &#123; reqConfig.headers[config.authKey] = config.authValue || ''&#125;const request = axios.create(reqConfig)async function getApiData() &#123; const len = urls.length let i = 0, str = '' while(i &lt; len) &#123; const result = await request.get(config.base + urls[i]).then(res =&gt; &#123; if(res.status == 200) &#123; return Promise.resolve(res.data) &#125; &#125;).catch(err =&gt; &#123; console.log(`'$&#123;urls[i]&#125;' 404 -&gt; Not Found`) return Promise.resolve(false) &#125;) if(result) &#123; str += `app.get('$&#123;urls[i]&#125;', (req, res) =&gt; &#123; res.send($&#123;JSON.stringify(result)&#125;) &#125;)\n ` &#125; if(i === len - 1) &#123; return Promise.resolve(str) &#125; i++ &#125;&#125;getApiData().then(res =&gt; &#123; const exportText = ` const express = require('express') const app = express() app.all('*', (req, res, next) =&gt; &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Headers', 'X-Requested-With') res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS') res.header('Content-Type', 'application/json') next() &#125;) $&#123;res&#125; app.listen($&#123;config.serverPort || 3000&#125;, () =&gt; &#123; console.log('local server started @$&#123;config.serverPort || 3000&#125;') &#125;) ` fs.writeFile(`./$&#123;config.outputFilename&#125;`, exportText, 'utf8', err =&gt; &#123; err &amp;&amp; console.log(err) console.log("data saved to " + config.outputFilename) &#125;)&#125;) end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页高度方向上的自适应问题]]></title>
    <url>%2F2018%2F08%2F02%2F%E7%BD%91%E9%A1%B5%E9%AB%98%E5%BA%A6%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[对于要求满屏不能出现滚动条的页面，很多情况下通过rem只做了宽度方向上的适配，但在一些特殊比例的屏幕下可能页面会出现混乱，因此可以利用css3的vh单位做做适配，特别是元素高度及内外边距值。 大多情况下设计稿采用的都是px单位，因此需要通过函数将px转换为vh，由于项目中引入的是less，此处使用less的自定义函数如下： 123.px2vh(@attr, @x, @base: 1080) &#123; @&#123;attr&#125;: @x / @base * 100vh&#125;; 上面函数默认依据1920*1080的设计稿将px单位换算成vh单位，函数中参数作为属性名时需要加上{}，参数默认值用：表示，当然也可以根据需要变换为px2vw，结合rem单位可以很好的完成宽度高度两个方向上的适配。 使用方式:1234.container &#123; .px2vh(height, 1080); .px2vh(margin-top, 108, 2160);&#125; 编译后：1234.container &#123; height: 100vh; margin-top: 5vh;&#125; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种首屏优化方案]]></title>
    <url>%2F2018%2F07%2F29%2F%E4%B8%80%E7%A7%8D%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[随着前端spa单页应用越来越复杂化，页面上往往存在多个tab切换，需求要求首屏渲染显示速度快，同时保障tab切换过程顺畅的用户体验，因此需要在完成首屏渲染之后将其他隐藏的tab页在合适时机也提前完成渲染。本文基于vue父子组件的生命周期，配合v-if控制不同tab组件的渲染顺序实现该需求。 父组件的基本页面结构123456789101112131415161718192021222324252627&lt;template&gt;&lt;div class="body-wrapper"&gt; &lt;transition name='fade' mode="out-in" :duration="&#123; enter: 1000, leave: 500 &#125;"&gt; &lt;compA v-show="tab === 1" /&gt; &lt;/transition&gt; &lt;transition name='fade' mode="out-in" :duration="&#123; enter: 800, leave: 300 &#125;"&gt; &lt;compB v-show="tab === 2" v-if='showIdx.show1' /&gt; &lt;/transition&gt; &lt;transition name='fade' mode="out-in" :duration="&#123; enter: 800, leave: 300 &#125;"&gt; &lt;compC v-show="tab === 3" v-if='showIdx.show2' /&gt; &lt;/transition&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;...mounted() &#123; // 首屏渲染完成之后触发执行隐藏页面的渲染,子组件mounted完成之后才会执行父组件mounted,当然也可以使用定时器 this.$nextTick(() =&gt; &#123; this.showIdx.show1 = true this.showIdx.show2 = true &#125;)&#125;, &lt;/script&gt; 几点说明 根据以上页面结构知道，首屏compA在tab1下将渲染完成并展示，tab2与tab3在v-if的控制下暂不渲染，只有当组件compA渲染完成之后才开始渲染另外两屏，因此我们只要在compA渲染完成之后改变showIdx的状态即可。 而根据父子组件之间的生命周期执行顺序，我们知道顺序是先执行父组件的created完成所有属性挂载，之后进入各个子组件执行created与mounted周期，但根据vue官网说明，各子组件间的created与mounted周期顺序无法保证，只能确保在各子组件执行完mounted周期之后再执行父组件的mounted周期，因此可以利用这个特点在compA子组件完成mounted挂载并进入父组件的mounted周期中将showIdx的状态进行改变，分别渲染另外两个组件并暂时通过v-show隐藏。 执行周期：父组件的created -&gt; compA的created -&gt; compA的mounted -&gt; 父组件的mounted(控制子组件的v-if) -&gt; 另外两个子组件的created与mounted(2子组件哪个先完成mounted无法保证)。 针对首屏compA的渲染也可以通过v-if动态控制各个孙组件的渲染顺序，优先渲染重点突出的内容。 在各组件切换之间添加动画既可以展示切换效果提高用户体验，又可以在该动画周期内完成一些如地图高度、图表高度等依赖元素高度的重渲染操作，因为元素高度隐藏时为0，切换到显示状态下高度发生变动，需要重新resize才能正常显示。 针对一些用户的预行为也可以做一些预渲染，如可以监听切换按钮的鼠标悬停事件，当用户将鼠标移动至切换按钮时，触发该tab下的页面渲染，当用户点击之后可以直接呈现渲染后的页面，从而提高性能与有较好的用户体验。 end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊点http相关的]]></title>
    <url>%2F2018%2F07%2F22%2F%E8%81%8A%E7%82%B9http%E7%9B%B8%E5%85%B3%E7%9A%84%2F</url>
    <content type="text"><![CDATA[广义上讲http可以包括http1.1、http2、https等，本文主要介绍http1.1的长连接及http2的3个特点，以及https的加密过程。 http1.1的keep-Alivehttp属于协议层，底层需要通过tcp传输层进行数据封装传输。每创建一个http请求需要经过客户端与服务端创建一个tcp连接通道并进行三次握手，确保两端传输链路正常之后再发起正式的数据传输。服务器与客户端发起的tcp连接数量是有限制的，如谷歌浏览器最多只能同时发起6个tcp连接，超过部分只能串行等待前面的请求完成响应后才能发起请求，服务器也一样有最多tcp连接数量的限制，同时建立的tcp连接越多越影响开销。在http1.1之前，因为HTTP协议是无状态的，每个请求和应答在客户端与服务器之间通讯都要创建一个tcp连接，并且在该请求数据传输完成之后立即断开连接，这样每次建立一个请求都要经过tcp三次握手过程，极大的浪费开销。因此在http1.1中引入了keep-Alive字段，该字段标识在某个请求结束之后暂不关闭tcp传输通道，之后同域下的请求可以继续复用该通道，不再需要进行三次握手过程，提高应答效率。但同时由于服务端需要较长时间内保持着keep-Alive状态，因此可能会增大服务端开销。http1.1中默认开启了Keep-Alive，且目前大部分浏览器采用的是http1.1协议，因此大部分请求默认都是Keep-Alive的连接请求。可以通过在浏览器控制台network选项下面开启connectionId查看每次发起的http请求占用的tcp通道id。 http2的3个主要特点 信道复用 同域下只需要创建一个tcp连接，之后该域下所有http请求基于该tcp通道进行数据传输，从而减少tcp创建次数，提高效率。该技术还可以减少占用浏览器同时发起6个tcp连接的限制。 分帧传输 http1.1及之前版本的协议都只能在上一个http请求数据响应之后才能继续进行下一个请求的数据传输，假如请求A的数据交互耗时1s，那么请求B只能在1s之后才能开始数据交互，这是一个有序的过程。在http2采用的分帧传输则是在同个通道中同时无序的进行多个请求的数据交互，如A、B请求的数据可以同时在一个tcp通道上传输，B请求的数据传输可能优先于A请求完成，但数据处理的顺序还是按照请求的顺序依次进行，也就是B的数据到达后先被储存，等待A请求数据到达后处理完成再处理B，是一个并行传输的过程。 server push服务端推送 以往的http请求都是单向请求应答的方式，只能由客户端主动发起请求，客户端被动响应。http2中开始支持服务端主动发起推送，结合分帧传输，可以在用户请求网站主页的同时一并将主页中相关脚本链接、样式链接等一并响应给到客户端，或者主动推送股票实时信息等，与websocket类似。 https加密的几个步骤所有http皆不安全，唯有https是安全的。https在http的tcp三次握手基础之上增加了一个SSL协议，需要多一次tcp验证，过程大致如下： 第一步： 客户端向服务端发起tcp连接请求，并带上一个随机字符串做标识，以及客户端支持的所有加密套件(加密套件就是对称加密算法)； 第二步： 服务端响应并返回自身的证书信息，该证书由权威机构通过验证颁发，其中包含了公钥，并且选择客户端发送的加密套件中合适的一种返回； 第三步： 客户端验证服务端返回的证书是否合法、有效，通过验证则产生一个随机字符串发送给服务端去加密，验证服务端是否为私钥持有者且有效； 第四步： 服务端使用私钥加密该随机字符串返回给客户端做校验； 第五步： 客户端通过公钥解密服务端返回的加密字符串，如果解密结果与先前随机数一致，则验证通过，之后客户端再次产生一个随机字符串作为上面服务端选择的对称加密算法中的密钥，用公钥对该密钥进行加密后发送给服务端； 第六步： 服务端获取信息后用私钥解密得到该密钥，之后返回一个随机数给到客户端表示已收到，可以正式传输数据了； 第七步： 客户端与服务端通过选择的对称加密算法与密钥对传输的数据进行加密与解密。 对称加密算法与非对称加密算法的主要区别对称加密算法有且只有一个密钥，只要拥有该密钥结合加密算法即可求解变量或因变量，典型算法有DES、AES。非对称加密算法有两个匹配的密钥，一个私钥一个公钥，公钥可对外公开，私钥加密过的信息只能通过公钥解密，公钥加密过的信息只能通过私钥解密，典型算法有RSA。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[另一种思路的评星组件]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%80%9D%E8%B7%AF%E7%9A%84%E8%AF%84%E6%98%9F%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[主要介绍一种同时支持字体与图标样式的评星方案，且支持带小数点分数的相应显示。基本思路是给背景添加默认灰度星星，之后通过相对位置将点亮星星覆盖灰度星星，并设置点亮星星overflow: hidden使宽度可控，最后对浮层宽度进行动态计算并赋值即可实现按分显示的效果。 针对入参的单位没有做过多的校验，诸如width入参带不带单位的校验问题，目前需要入参提供带单位数值。这里就需要针对入参字符串获取数值单位，单位可能是px，可能是rem，也可能是%，此处使用正则replace(/^\d+/g, &#39;&#39;)替换的方式获取。 另外需要注意针对图标icon的背景图片background-size需要设置为cover模式，这样才能实现剪裁的效果，而不被拉伸变形。 支持的入参字段如下： isIcon // 是否使用iconiconConfig // 使用icon的配置，只有在isIcon为true生效score // 得分，入参需转换为5分标准形式bgColor // 使用字体图标时设置的底色coverColor // 使用字体图标时设置的覆盖色fontSize // 使用字体图标时设置的字体大小fontFamily // 使用字体图标时设置的字体类型，不同字体类型显示的星星样式有差异，默认是serif 使用方式：npm install zrate –save 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;template&gt;&lt;div class="z-rate" :style="rootStyle"&gt; &lt;template v-if='!isIcon'&gt; &lt;span :style='&#123; color: bgColor &#125;'&gt;☆☆☆☆☆&lt;/span&gt; &lt;span class="cover" :style="&#123; width: parseFloat(score) + 'em', color: coverColor &#125;"&gt;★★★★★&lt;/span&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;div class="bg-group"&gt; &lt;div v-for='i in 5' class="img-bg" :key='i' :style="&#123; backgroundImage: 'url(' + iconConfig.offIcon + ')', width: iconConfig.width, height: iconConfig.height &#125;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="cover-group" :style="percentStyle"&gt; &lt;div v-for='i in 5' class="img-cover" :key='i' :style="&#123; backgroundImage: 'url(' + iconConfig.onIcon + ')', width: iconConfig.width, height: iconConfig.height &#125;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'z-rate', props: &#123; // 是否使用icon isIcon: &#123; type: Boolean, default: false &#125;, // 使用icon的配置 iconConfig: &#123; type: Object &#125;, // 得分，入参需转换为5分标准形式 score: &#123; type: [String, Number], default: '2.55' &#125;, // 使用字体图标时设置的底色 bgColor: &#123; type: String, default: '#ccc' &#125;, // 使用字体图标时设置的覆盖色 coverColor: &#123; type: String, default: 'red' &#125;, // 使用字体图标时设置的字体大小 fontSize: &#123; type: String, default: '16px' &#125;, // 使用字体图标时设置的字体类型，不同字体类型显示的星星样式有差异，默认是serif fontFamily: &#123; type: String, default: 'serif' &#125; &#125;, computed: &#123; rootStyle() &#123; return this.isIcon ? '' : &#123; fontSize: this.fontSize, fontFamily: this.fontFamily &#125; &#125;, percentStyle() &#123; // 通过replace正则获取用户设置宽度的单位，可能是px，可能是rem，也可能是% return this.isIcon ? &#123; width: parseFloat(this.score) * parseFloat(this.iconConfig.width) + this.iconConfig.width.replace(/^\d+/g, '') &#125; : '' &#125; &#125;&#125;&lt;/script&gt;&lt;style lang='css' scoped&gt;.z-rate &#123; position: relative;&#125;.z-rate .cover, .z-rate .cover-group &#123; position: absolute; top: 0; left: 0; overflow: hidden; width: 0;&#125;.z-rate .bg-group &#123; display: inline-block;&#125;.z-rate .bg-group .img-bg &#123; display: inline-block; background-size: cover;&#125;.z-rate .cover-group &#123; white-space: nowrap;&#125;.z-rate .cover-group .img-cover &#123; display: inline-block; background-size: cover;&#125;&lt;/style&gt; 引用示例12345678910111213&lt;zRate :isIcon='false' :iconConfig="&#123; // 该配置只有在isIcon为true时生效 offIcon: require('@/assets/images/star-off.png'), onIcon: require('@/assets/images/star-on.png'), // 需要通过require引用 width: '5rem', // 需要带单位 height: '5rem' &#125;" :score='3.7' bgColor='#ddd' coverColor='red' fontSize='50px' fontFamily='Arial' /&gt; 效果 END]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.open这件小事儿]]></title>
    <url>%2F2018%2F06%2F30%2Fwindow.open%E8%BF%99%E4%BB%B6%E5%B0%8F%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[开发中遇到的一个需求，实现用户点击按钮后等待2s下载资源，项目中通过动态创建a标签，利用download属性进行当前页下载实现了该需求，封装方法如下： 123456789function aDownload(url, name) &#123; let a = document.createElement('a') a.setAttribute('href', url) a.setAttribute('download', name || '') a.setAttribute('display', 'none') document.body.appendChild(a) a.click() document.body.removeChild(a)&#125; 但继续追究下去的时候，如果想实现不再当前页下载，而是打开新的窗口进行下载，或者考虑到a标签的download属性有兼容性问题，是否有其他的替代方案？ 现假设有如下代码，预期结果是点击按钮之后跳转到新的页面，或者直接下载资源，但结果是第一个按钮可以如期打开新页面，第二个打开新页面被浏览器拦截。查找资料得知是因为window.open频繁被广告商滥用，严重影响用户体验，大部分现代的浏览器默认开启智能阻止弹窗策略。该策略会根据用户行为判断是否如期执行window.open操作，还是判定为流氓操作予以拦截。 下面代码当延迟1000毫秒执行时，Chrome允许窗口弹出，但是当延迟2000毫秒(或者弹窗的代码在异步ajax内部)执行时被拦截。经多次测试，Chrome浏览器在1000毫秒及之内执行时将允许弹窗，大于等于1001毫秒时候将拦截，其他浏览器拦截策略可能略微不同。 1234567891011&lt;body&gt; &lt;button onclick='handleClick(1)'&gt;1s后打开新标签页&lt;/button&gt; &lt;button onclick='handleClick(2)'&gt;2s后打开新标签页&lt;/button&gt; &lt;script&gt; function handleClick(s) &#123; setTimeout(() =&gt; &#123; window.open('./b.html', 'winName') &#125;, s * 1000) &#125; &lt;/script&gt;&lt;/body&gt; 尝试了以下这么几种方式，通过a标签href属性、通过form标签submit方法、通过location重定向，其中前两种实际使用过程中如果结合了target=_blank与上面栗子中2s延迟的setTimeout，浏览器还是会拦截新窗口的打开，这点没办法突破，但可以应对浏览器莫名的拦截。第三种方式无论是否延迟都可以越过浏览器拦截，但牺牲了一定的用户体验，需要权衡。 123456789101112131415161718192021222324252627282930313233//第一种：通过a标签href属性function aOpen(url, isDownload, name) &#123; let a = document.createElement('a') a.setAttribute('href', url) a.setAttribute('target', '_blank') isDownload &amp;&amp; a.setAttribute('download', name || '') a.setAttribute('display', 'none') document.body.appendChild(a) a.click() document.body.removeChild(a)&#125;//第二种：通过form标签submit方法function formOpen(url) &#123; let form = document.createElement('form') form.setAttribute('action', url) form.setAttribute('target', '_blank') form.setAttribute('method', 'POST') form.setAttribute('display', 'none') document.body.appendChild(form) form.submit() document.body.removeChild(form)&#125;// 以上2种调用方式setTimeout(() =&gt; &#123; aOpen('./b.html') &#125;, 1000) //这种方式可以顺利打开新窗口setTimeout(() =&gt; &#123; aOpen('./b.html') &#125;, 2000) //超过1s的延迟这种方式还是会被拦截//第三种：通过location重定向document.addEventListener('click', function() &#123; let newWin = window.open('./loadingPage.html') ajax().done(function() &#123; newWin.location.href = './targetPage.html' //重定向到目标页面 &#125;)&#125;)]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单介绍fiddler工具的几种用法]]></title>
    <url>%2F2018%2F06%2F25%2F%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8Dfiddler%E5%B7%A5%E5%85%B7%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文主要介绍了Fiddler工具常用的基本的抓包功能、修改请求参数、修改响应数据、重定向替换本地文件、重定向解决跨域、模拟请求等功能。 基本的抓包功能PC端浏览器走的请求会直接被抓取，这里说明移动端的数据抓包设置。 首先保证电脑与手机连接在同一个WiFi网络中(即构建局域网)，并且保证二者在同一个ip网段内。 打开电脑上的Fiddler，分别选中菜单栏Tools - Options - Connections，在该tab下的Fiddler listens on port填入 6666 端口，并将Allow remote computers to connect选中打钩，该步骤允许远程设备使用本机联网。 重启Fiddler并在右上角Online中的找到无线局域网内分配到本机的ip，记住该ip。 掏出手机连接同一wifi，对该wifi设置代理，代理ip就是上面记住的ip，端口就是上面写的6666。 完成以上步骤之后，手机上访问任一网页产生http请求的接口、数据都将被Fiddler拦截，如果没有拦截到可能IP设置有误，或没处同一局域网下，或开启Fiddler上允许远程接入6666端口访问网络。 修改请求参数开发时可以通过拦截修改入参的方式调试接口，并且验证接口的安全性能。前端一切皆可修改，前端一切皆不安全。 单击Fiddler底部控制台下第三个tab按钮，对，就是那个白色看不清的button，单击一次切换到拦截请求功能，再次单击切换到拦截响应功能，再次单击关闭拦截。也可以通过选中菜单Rules - Automatic Breakpoints - Before Requests/After Responses/Disabled，3种状态分别对应上面三种按钮点击。还可通过控制台输入bpu + 拦截的url地址针对性的对该url进行拦截，其他的url可以正常访问，消除断点直接在控制台输入bpu。 ctrl+X清空请求记录，之后调用需要拦截的请求，Fiddler将会闪烁提示，选中该条拦截记录，切换到Inspectors标签下的请求参数区域即可修改入参，修改完之后点击下边绿色按钮Run to Completion完成请求。 查询数据库或调用相关接口，保存成功的参数结果将与浏览器直接发送的参数不同。 修改响应数据开发联调接口时可能后台返回的数据为空或者结构想变动，前端可以通过修改响应数据进行按需调整，方便快捷有效。 第一步与上面修改请求参数一致，只是切换的状态为拦截响应功能。 ctrl+X清空请求记录，之后调用需要拦截的请求，Fiddler将会闪烁提示，选中该条拦截记录，切换到Inspectors标签下的响应参数区域即可修改响应参数，修改完之后点击下边绿色按钮Run to Completion完成响应。注意，这里其实也可以选择本地文件替换响应体内容，与下面介绍的重定向替换本地文件类似。 浏览器打开F12查看请求响应body体已经替换为修改之后的内容。 重定向替换本地文件开发测试环境下一切功能正常，但上线之后就出问题了，这时候如何定位bug问题，比较方便的方式就是找到可能出现问题的脚本或样式文件进行修改或替换。当然，直接通过谷歌浏览器的sources模块也可找到源文件进行修改，但只允许修改js、css等文件。 ctrl+X清空请求记录，之后调用需要重定向的请求。 切换至AutoResponder标签页，将上面的请求记录拖至该标签页区域内，并分别打钩Enable rules及Unmatched requests passthrough，表示遵循默认规则，且如果请求与规则匹配不上，继续完成该请求过程。 AutoResponder标签页的区域中选中该条请求，在下边的Rule Editor选择需要替换的文件，可以选将线上的文件保存到本地做修改后替换，也可以直接重定向到新的url路径，点击save保存，再次调用请求即生效。 重定向解决跨域该功能与重定向替换本地文件类似，只是自动响应的时候不是替换新文件，而且重新定向到新的路径，相当于代理转发，且可以通过正则匹配需要代理转发的请求，功能与nginx类似。 模拟请求右侧切换至Composer标签，选择需要的请求方式及url，选择http协议版本，分别填入请求头部信息与请求参数，或者选择上传文件流，之后点击发送即可模拟一次请求。该功能与postman一样。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支持可拖动模态框的vue组件]]></title>
    <url>%2F2018%2F06%2F18%2F%E6%94%AF%E6%8C%81%E5%8F%AF%E6%8B%96%E5%8A%A8%E6%A8%A1%E6%80%81%E6%A1%86%E7%9A%84vue%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[实际项目开发中大多时候会引用第三方ui库如bootstrap、elementui，第三方库基本都封装有模态框，也基本满足大部分场景需求。但不支持想桌面应用那样的可拖动效果，而实际大屏场景中可能需要移动模态框查看参考其他信息，因此有了拖动模态框的需求。本篇基于vue简单模拟写一个支持可拖动模态框组件，比较粗糙，后期实际应用中再不断完善。 可配置项： 标题 是否显示模态框 是否支持拖动 模态框宽度 – 字符串带单位 距离顶部距离 – 字符串带单位 头部背景色 自定义class body最大高度 单机modalshadow是否关闭 引用方式： 执行npm install zdialog --save按需引入即可，如果要注册为全局组件，可在main.js文件中配置Vue.component(&#39;zdialog&#39;, zdialog)即可在各页面中直接使用。 直接上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241&lt;template&gt; &lt;transition name="z-dialog-fade"&gt; &lt;div class="z-dialog" v-show='visible' @click.self='handleClose(1)'&gt; &lt;div class="z-dialog-container" :style="&#123; width: width, top: top &#125;" :class="[customClass]"&gt; &lt;div class="z-dialog__header" :style="&#123; cursor: draggable ? 'move' : 'default', 'background-color': headerBg &#125;" :class="&#123; 'no-select': draggable &#125;"&gt; &lt;span class="z-dialog__title"&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; &lt;i class="z-dialog__close" @click='handleClose(0)'&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="z-dialog__body" :style="&#123; 'max-height': maxHeight, 'overflow-y': 'auto' &#125;" :class="&#123; 'no-select' : draggable &#125;"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="z-dialog__footer"&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'zdialog', props: &#123; title: &#123; type: String, default: '标题' &#125;, visible: &#123; type: Boolean, default: false &#125;, draggable: &#123; type: Boolean, default: false &#125;, width: &#123; type: String, default: '60%' &#125;, top: &#123; type: String, default: '150px' &#125;, headerBg: &#123; type: String, default: '#4A43C4' &#125;, customClass: &#123; type: String, default: '' &#125;, maxHeight: &#123; type: String, default: '500px' &#125;, modalClose: &#123; type: Boolean, default: true &#125; &#125;, watch: &#123; visible (to) &#123; if (to) &#123; this.container.style.cssText = `left: 50%; top: $&#123;this.top&#125;; -webkit-transform: translateX(-50%); transform: translateX(-50%); width: $&#123;this.width&#125;` if (this.draggable) &#123; this.handleDraggable(0) this.$nextTick(() =&gt; &#123; this.resizeHandler() &#125;) &#125; &#125; else &#123; this.handleDraggable(1) &#125; &#125; &#125;, data () &#123; return &#123; $: null, container: null, header: null, offsetX: '', offsetY: '', clientWidth: '', clientHeight: '', modalWidth: '', modalHeight: '', mousedownHandler: e =&gt; &#123; this.offsetX = e.offsetX this.offsetY = e.offsetY &#125;, mouseupHandler: e =&gt; &#123; this.offsetX = '' this.offsetY = '' &#125;, mousemoveHandler: e =&gt; &#123; if (this.offsetX &amp;&amp; this.offsetY) &#123; let left = e.clientX - this.offsetX let top = e.clientY - this.offsetY if (left &lt;= 0) left = 0 if (top &lt;= 0) top = 0 if (left &gt;= this.clientWidth - this.modalWidth) left = this.clientWidth - this.modalWidth if (top &gt;= this.clientHeight - this.modalHeight) top = this.clientHeight - this.modalHeight this.container.style.cssText = `left: $&#123;left&#125;px; top: $&#123;top&#125;px; -webkit-transform: none; transform: none; width: $&#123;this.width&#125;` &#125; &#125;, resizeHandler: e =&gt; &#123; this.clientWidth = document.documentElement.clientWidth this.clientHeight = document.documentElement.clientHeight this.modalWidth = this.container.clientWidth this.modalHeight = this.container.clientHeight &#125; &#125; &#125;, mounted () &#123; this.$ = document.querySelector.bind(document) this.header = this.$('.z-dialog__header') this.container = this.$('.z-dialog-container') &#125;, methods: &#123; handleDraggable (i) &#123; const types = ['addEventListener', 'removeEventListener'] this.header[types[i]]('mousedown', this.mousedownHandler, false) this.header[types[i]]('mousemove', this.mousemoveHandler, false) this.header[types[i]]('mouseup', this.mouseupHandler, false) this.header[types[i]]('mouseleave', this.mouseupHandler, false) window[types[i]]('resize', this.resizeHandler, false) &#125;, handleClose (type) &#123; if (!this.modalClose &amp;&amp; type) return this.$emit('update:visible', false) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="css" scoped&gt;.z-dialog &#123; position: fixed; left: 0; top: 0; right: 0; bottom: 0; z-index: 10086; background-color: rgba(0, 0, 0, 0.3);&#125;.z-dialog .z-dialog-container &#123; position: relative; left: 50%; -webkit-transform: translateX(-50%); transform: translateX(-50%); background-color: #fff; z-index: 12306;&#125;.z-dialog .z-dialog-container .z-dialog__header &#123; position: relative; width: 100%; height: 60px; line-height: 40px; padding: 10px 15px; font-size: 16px; color: #fff; text-align: left; background-color: #4A43C4; -webkit-box-sizing: border-box; box-sizing: border-box;&#125;.z-dialog .z-dialog-container .z-dialog__close &#123; position: absolute; right: 15px; top: 50%; -webkit-transform: translateY(-50%); transform: translateY(-50%); width: 20px; height: 20px; cursor: pointer;&#125;.z-dialog .z-dialog-container .z-dialog__close::before,.z-dialog .z-dialog-container .z-dialog__close::after &#123; content: ''; position: absolute; height: 2px; width: 100%; top: 50%; left: 0; background: rgba(255, 255, 255, 0.7);&#125;.z-dialog .z-dialog-container .z-dialog__close::before &#123; -webkit-transform: rotate(45deg); transform: rotate(45deg);&#125;.z-dialog .z-dialog-container .z-dialog__close::after &#123; -webkit-transform: rotate(-45deg); transform: rotate(-45deg);&#125;.z-dialog .z-dialog-container .z-dialog__close:hover::before,.z-dialog .z-dialog-container .z-dialog__close:hover::after &#123; background: #1ebcc5;&#125;.z-dialog .z-dialog-container .z-dialog__body &#123; width: 100%; height: auto; padding: 10px 15px; -webkit-box-sizing: border-box; box-sizing: border-box;&#125;.z-dialog .z-dialog-container .z-dialog__footer &#123; width: 100%; padding: 15px 15px 20px 15px; -webkit-box-sizing: border-box; box-sizing: border-box;&#125;.z-dialog .no-select &#123; -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; user-select: none;&#125;.z-dialog-fade-enter-active,.z-dialog-fade-leave-active &#123; -webkit-transition: opacity .5s; transition: opacity .5s;&#125;.z-dialog-fade-enter,.z-dialog-fade-leave-to &#123; opacity: 0;&#125;&lt;/style&gt;&lt;!-- 使用方式 --&gt;&lt;button @click='visible = true'&gt;点我弹出模态框&lt;/button&gt;&lt;zdialog :visible.sync='visible' :draggable='true' top='300px' headerBg='green' title="标题test"&gt; &lt;div class="dialog-body"&gt; &lt;p class="m-b-20"&gt;说明：我是说明我是说明我是说明我是说明&lt;/p&gt; &lt;el-checkbox-group v-model="value"&gt; &lt;el-checkbox :label="item.title" v-for='(item, index) in [1,2,3,4]' :key='index' class="flex-row"&gt;&#123;&#123;item&#125;&#125;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/div&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;el-button type="default" class="" @click='visible = false'&gt;取消&lt;/el-button&gt; &lt;el-button type="primary" class="m-r-10 focus" @click='visible = false'&gt;确定&lt;/el-button&gt; &lt;/span&gt;&lt;/zdialog&gt; 几点说明： 容器最外层增加一层基于fixed设置的背景层，同时作为容器层设置相对位置的参考，容器层的z-index层级需要比背景层高。 点击背景层可隐藏模态框，但由于背景层包裹容器层，因此需要通过判断e.target属性决定是否执行隐藏，vue中通过self修饰符封装。 vue的双向数据绑定修饰符sync是一个props down event up的语法糖： &lt;dialog :visible.sync=&quot;dialogVisible&quot; /&gt; ==&gt; &lt;dialog :visible=&quot;dialogVisible&quot; @update:visible=&quot;newVisible =&gt; dialogVisible = newVisible&quot; /&gt;，事件的触发通过this.$emit(&#39;update:visible&#39;, false)改变。 slot插槽默认插入body，指定插入footer需要加上响应的name值，有需要也可以定制header。 watch中监听属性并执行相关业务，如果涉及到针对dom的操作，最好放在$nextTick里面去执行，否则可能获取不到想要的结果。 组件内所有监听的事件在组件隐藏或者注销之后一定要解绑，否则一旦组件多绑定的事件多，可能会造成冲突并影响性能。 监听窗口事件，一旦窗口改变需要重新获取窗口尺寸及模态框尺寸(如果模态框尺寸进行适配的话)，保证模态框不会移出窗口视野。 mousemove监听事件需要判断是否在header上已经发生点击事件，否则会出现误操作。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vue搭建管理平台开发模板思路]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%9F%BA%E4%BA%8Evue%E6%90%AD%E5%BB%BA%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[整体分析搭建一个完善管理平台的步骤以及需要注意的要点，主要技术栈为vue + axios + elementUI，目的是高效开发一个通用性及维护性较好的平台。 step one: 基于vue-cli快速生成目录结构通过vue-cli下载项目基础模板，其中大部分webpack配置都已经设置好，不需要做过多的调整，需要调整的地方主要有几个地方： run build生成的包文件地址，配置config/index里的assetsRoot属性，以及静态资源assetsSubDirectory文件地址，注意静态文件目录下的资源不会被打包进项目，只会引用。 将config/index里的productionSourceMap属性值改为false，这样不会打包生成map文件，提高打包速度，减少打包时间。生成map文件主要是用于定位错误。 在config/index里可通过proxyTable字段设置反向代理，注意页面中需要走代理的接口需要写成相对路径。 webpack.prod.conf.js文件中new UglifyJsPlugin对象上添加drop_debugger: true, drop_console: true，作用是去除线上代码控制台的输出与debugger。 static文件夹不建议放静态资源，因为开发环境与线上环境static与引用文件的相对路径不一致，可能会导致出错。 创建各views模块文件夹建议按照路由层级进行划分，目标就是可以轻易通过router直接找到文件路径，而不需要去翻route合集。 step two: 入口文件调整可能会出现一种情况，开发过程中各组件css样式以及覆盖ui框架都没什么问题，但通过run build之后出现ui框架样式无法覆盖的问题，导致整体样式布局错乱。这是由于build之后webpack将所有的css默认打包成了一个css文件，这样就会出现后面的样式覆盖前面样式的问题，所以需要考虑一个样式引入的顺序问题。一个原则是框架类的样式提前引入，重置及覆盖类样式延后引入，且将组件入口app文件放到最后再引入，这样组件内的样式在最后被打包，提高优先级。开发阶段没有这个问题。此外，App.vue文件中顶级路由视图渲染加入keep-alive标识，针对有需要缓存的页面提供缓存，默认不缓存，需要缓存页面在meta属性中配置keepAlive为true。 1234567891011121314import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css' //框架样式import '@/assets/css/normalize.css' //重置样式import '@/assets/css/common.less' //通用样式import '@/assets/css/index.less' //覆盖样式import App from './App' //最后引入// 引入keep-alive标识缓存&lt;div id="app"&gt; &lt;keep-alive&gt; &lt;router-view v-if="$route.meta.keepAlive" /&gt; &lt;/keep-alive&gt; &lt;router-view v-if="!$route.meta.keepAlive" /&gt;&lt;/div&gt; step three: 路由与菜单配置路由方面大多情况下需要设置为按需加载，提交资源效率，引入es7的import()方法，封装成方法调用。在router文件目录下引入一个menus.js文件，专用于配置多级菜单的路由，其余的路由诸如登录页、404页等独立写路由。menus.js数组有几个注意点： 每个对象提供一个name属性，表明在菜单中要显示的名称。 对于支持链接的菜单对象提供path及component字段，用于路由跳转，提供children字段表明子级菜单位置。 meta属性中auth字段针对所有用户验证session权限，perm字段针对不同用户验证路由权限，icon提供菜单图标。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const ladyLoading = url =&gt; () =&gt; import(`@/views/$&#123;url&#125;.vue`)const Nav1 = ladyLoading('Nav1/index')const Nav2 = ladyLoading('Nav2/index')const Nav3 = ladyLoading('Nav3/index')const Nav11 = ladyLoading('Nav1/Nav11')const Nav12 = ladyLoading('Nav1/Nav12')const Nav13 = ladyLoading('Nav1/Nav13')const Nav131 = ladyLoading('Nav1/Nav131')const menus = [ &#123; name: 'nav1', meta: &#123; auth: true, icon: 'el-icon-location', perm: 'nav1', alias: '导航一' &#125;, children: [&#123; path: 'nav1/nav11', name: 'nav11', meta: &#123; auth: true, icon: 'el-icon-location-outline', perm: 'nav11', alias: '分组一' &#125;, component: Nav11, &#125;, &#123; path: 'nav1/nav12', name: 'nav12', meta: &#123; auth: true, icon: 'el-icon-phone-outline', perm: 'nav12', alias: '分组二' &#125;, component: Nav12, &#125;, &#123; name: 'nav13', meta: &#123; auth: true, icon: 'el-icon-picture', perm: 'nav13', alias: '分组三' &#125;, children: [&#123; path: 'nav1/nav13/nav131', name: 'nav131', meta: &#123; auth: true, icon: 'el-icon-edit', perm: 'nav131', alias: '选项一' &#125;, component: Nav131 &#125;] &#125;] &#125;, &#123; path: '/nav2', name: 'nav2', meta: &#123; auth: true, icon: 'el-icon-menu', perm: 'nav2', alias: '导航二' &#125;, component: Nav2 &#125;, &#123; path: '/nav3', name: 'nav3', meta: &#123; auth: true, icon: 'el-icon-setting', perm: 'nav3', alias: '导航三' &#125;, component: Nav3 &#125;] 以上菜单数组配置完成之后，接下来将该菜单通过递归生成对应路由，并设置全局路由拦截。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import menus from './menus'const Home = () =&gt; import(`@/views/Home.vue`)const Login = () =&gt; import(`@/views/Login.vue`)// 递归方式const generateRouters = (menus = [], routers = []) =&gt; &#123; menus.forEach(item =&gt; &#123; if(item.path &amp;&amp; item.component) &#123; routers.push(item) &#125; else &#123; generateRouters(item.children, routers) &#125; &#125;) return routers&#125;const router = new Router(&#123; routes: [ &#123; path: '/', name: 'home', meta: &#123; auth: true &#125;, component: Home, children: generateRouters(menus) //生成层级路由 &#125;, &#123; path: '/login', name: 'login', component: Login &#125; ]&#125;)// 全局路由拦截router.beforeEach((to, from, next) =&gt; &#123; if(to.name !== 'login') &#123; //验证session权限 if(to.meta.auth &amp;&amp; !Utils.getLocal('sessionid')) &#123; next(&#123;name: 'login'&#125;) return &#125; //验证路由权限 const perms = Utils.getLocal('perm') || [] if(to.meta.perm &amp;&amp; perms.indexOf(to.meta.perm) &lt; 0) &#123; next(&#123;name: 'login'&#125;) return &#125; &#125; next()&#125;) step four: 生成菜单栏首先在components文件夹下新建一个layout用于存放全局布局样式，主要分为header、menuNav、footer等，并在Home组件中引入各组件，运用css3的calc方法调整好整体的适配。之后也是通过递归生成菜单栏，这里需要关注的一点是由于菜单层级不确定，所以需要使用到组件递归，单独提取一个树状组件，并在template标签上使用v-for进行组件自递归。其中还有一点需要关注的是验证菜单的配置权限，该权限列表根据登录角色由后台维护。步骤是在登录成功之后调用权限接口保存到本地，然后在菜单组件的created事件中进行匹配，当然这里的逻辑是只要父级菜单没有权限，其下所有子级菜单也不会显示。关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Home组件结构&lt;template&gt;&lt;div id="home"&gt; &lt;div class="top-header"&gt; &lt;top-header /&gt; &lt;/div&gt; &lt;div class="main-container"&gt; &lt;menu-nav /&gt; &lt;div class="body-container"&gt; &lt;router-view /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;// 递归组件结构&lt;template&gt;&lt;div class="menu-tree"&gt; &lt;template v-for="item in menuData"&gt; &lt;el-submenu :index="item.name" v-if="item.children"&gt; &lt;template slot="title"&gt; &lt;i :class="item.meta.icon" v-show='item.meta.icon'&gt;&lt;/i&gt; &lt;span slot="title"&gt;&#123;&#123;item.meta.alias&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;menu-tree :menuData="item.children"&gt;&lt;/menu-tree&gt; &lt;/el-submenu&gt; &lt;el-menu-item :index="item.name" v-else @click='handleClick(item)'&gt; &lt;i :class="item.meta.icon" v-show='item.meta.icon'&gt;&lt;/i&gt; &lt;span slot="title"&gt;&#123;&#123;item.meta.alias&#125;&#125;&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/template&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'menuTree', props: &#123; menuData: &#123; type: Array, default: [] &#125; &#125;, methods: &#123; handleClick(item) &#123; if(item.path &amp;&amp; item.name) &#123; this.$router.push(&#123;name: item.name&#125;) &#125; &#125; &#125;&#125;&lt;/script&gt;//验证菜单权限created() &#123; const perms = Utils.getLocal('perm') || [] const filterPerms = menus =&gt; &#123; return menus.filter(item =&gt; &#123; if(item.children) &#123; item.children = filterPerms(item.children) &#125; return perms.indexOf(item.meta.perm) &gt; -1 &#125;) &#125; this.menuData = filterPerms(menus)&#125; step five: 封装请求方法src目录下新增api文件夹存放基于axios实例化的http对象，并配置超时、状态码拦截、错误跳转等。封装两种常见请求方式，常规数据提交与数据流上传。这里考虑到可维护性单独将所有接口地址提取为单独一个文件，并转接为一个常量解耦。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const http = axios.create(&#123; timeout: 30000, responseType: 'json'&#125;)http.interceptors.response.use( res =&gt; &#123; const resData = res.data switch (resData.code) &#123; case '200': Promise.resolve(resData.body) break default: Promise.reject(resData.msg) break &#125; &#125;, error =&gt; &#123; const errData = error.response switch (errData.status) &#123; case 404: router.push(&#123; name: 'notFound' &#125;) break case 500: router.push(&#123; name: 'serverError' &#125;) break case 504: router.push(&#123; name: 'internetError' &#125;) break default: break &#125; &#125;)//普通接口调用export const FetchData = (url, method = 'get', params = &#123;&#125;) =&gt; &#123; const path = paths.hasOwnProperty(url) ? paths[url] : url if (method.toUpperCase() === 'GET') &#123; let query = '?' + Object.keys(params).map(key =&gt; &#123; return `$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(params[key])&#125;` &#125;).join('&amp;') return http.get(path + query) &#125; else &#123; return http.post(path, params) &#125;&#125;// 文件上传接口export const Upload = (url, data) =&gt; &#123; const path = paths.hasOwnProperty(url) ? paths[url] : url let params = new FormData() Object.keys(data).forEach(key =&gt; &#123; params.append(key, data[key]) &#125;) return http(&#123; method: 'post', url: path, data: params, headers: &#123;'Content-Type': 'multiple/form-data'&#125; &#125;)&#125; step six: 引入状态管理src目录下新增一个store文件夹用于存放状态管理vuex涉及到的几个步骤文件，分别为入口文件index.js、异步提交actions.js、同步提交mutations.js以及存储全局状态变量state.js，还可按需引入getters.js文件存放一些全局的字典等常量。12345678910111213141516171819202122232425262728293031323334353637// 入口文件import Vue from 'vue'import Vuex from 'vuex'import state from './state'import actions from './actions'import mutations from './mutations'import getters from './getters'Vue.use(Vuex)export default new Vuex.Store(&#123; state, actions, mutations &#125;)// state.jsexport default &#123; loginStatus: false&#125;// actions.jsexport default &#123; changeLoginStatus: (&#123; commit &#125;, options) =&gt; &#123; commit('changeLoginStatus', options) &#125;&#125;// mutations.jsexport default &#123; changeLoginStatus: (state, options) =&gt; &#123; state.loginStatus = options &#125;&#125;// getters.jsexport default &#123; citys: state =&gt; [ &#123;name: '深圳', code: '4402'&#125;, &#123;name: '广州', code: '4401'&#125; ]&#125; step seven: mock接口与代理转发src目录下新增mock文件，入口文件index.js，基于node框架express与axios库，这两个依赖包已经存在于package.json文件中，因此不需要额外引入其他包。按不同模块划分mock接口文件，之后一并引进入口文件，便于管理。该文件也可同时用于反向代理，配置好代理地址、代理路径，此处需要引入body-parser解析获取请求的body体，之后将前端请求的地址拼接、请求方式，请求体一并转发。1234567891011121314151617181920212223242526272829303132333435363738394041424344const express = require('express')const app = express()// login部分require('./login').api(app)// userInfo部分require('./userInfo').api(app)/* 以下为代理转发 */const axios = require('axios')app.use(require('body-parser').json()) // 用于解析post请求的body体const request = axios.create(&#123; timeout: 30000, responseType: 'json'&#125;)const requestData = (url, method = 'get', params = &#123;&#125;) =&gt; &#123; if (method.toUpperCase() === 'GET') &#123; let query = '?' + Object.keys(params).map(key =&gt; &#123; return `$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(params[key])&#125;` &#125;).join('&amp;') return request.get(url + query) &#125; else &#123; return request.post(url, params) &#125;&#125;const config = &#123; baseUrl: 'http://localhost:10086', redirectPath : '/'&#125;const methods = ['get', 'post']methods.forEach(method =&gt; &#123; app[method](config.redirectPath + '*', (req, res) =&gt; &#123; requestData(config.baseUrl + req.path, req.method, req.body = &#123;&#125;).then(response =&gt; &#123; res.send(response.data) &#125;).catch(err =&gt; &#123; res.send(err) &#125;) &#125;)&#125;)app.listen(10086, () =&gt; &#123; console.log('server started @10086...')&#125;) end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web视频上传的若干问题]]></title>
    <url>%2F2018%2F06%2F08%2Fweb%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[针对视频时长以及首帧缩略图大部分情况下需要后台文件系统进行处理，考虑特殊情况下，web端能否处理拿到上传视频的相关参数，以下简单封装一个较为完整的视频上传方法。 几点说明： 可自定义上传按钮样式，封装原生ajax方法，封装上传类方法，实例化支持配置不同格式、文件大小等。 上传前可播放预览本地视频，并获取视频时长传给后台，但只支持浏览器可播放的mp4文件，无法播放的文件无法上传时长。 上传成功返回的视频列表提供link prefetch资源预加载。 支持获取视频首帧base64缩略图传递给后台，但不建议直接传递base64，体积太大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;web视频上传的若干问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button class="btn"&gt;点我上传&lt;/button&gt; &lt;input type="file" accept="video/*" class="upload-btn" onchange='upload.handleFileChange(event)' style="display:none"&gt; &lt;video src='' controls class="video-duration" oncanplay="upload.onVideoPlay(event)" onerror="upload.onError()" style="display:none"&gt;&lt;/video&gt; &lt;script&gt; const $ = document.querySelector.bind(document) $('.btn').onclick = function() &#123; $('.upload-btn').click() &#125; class Upload &#123; constructor(options) &#123; this.$ = document.querySelector.bind(document) this.params = &#123; id: options.userId, file: &#123;&#125;, duration: '' &#125; if(options.isCaptureImage) &#123; this.handleCaptureImage() &#125; this.options = options &#125; handleFileChange(evt) &#123; const file = evt.target.files[0] const fileType = file.name.slice(file.name.lastIndexOf('.') + 1).toLowerCase() const types = this.options.types || ['mp4', 'ogg'] const maxSize = this.options.maxSize || 30 * 1024 * 1000 if (file.size &gt; maxSize) &#123; alert('文件超过限制大小') return &#125; if (types.indexOf(fileType) === -1) &#123; alert(`只能上传$&#123;types.join('，')&#125;格式`) return &#125; this.options.videoEle.src = URL.createObjectURL(file) //该方法为h5 API,有兼容性问题 this.params.file = file &#125; onVideoPlay(e) &#123; this.params.duration = this.formatTime(e.target.duration) this._submitFile() &#125; onError() &#123; if(!this.params.file.name) return this.params.duration = '' this._submitFile() &#125; _submitFile() &#123; this.uploadFn(this.options.url, this.params) &#125; uploadFn(url, data) &#123; let params = new FormData() Object.keys(data).forEach(key =&gt; &#123; params.append(key, data[key]) &#125;) const xhr = new XMLHttpRequest() xhr.timeout = 30000 xhr.onerror = () =&gt; &#123; alert('服务器异常') &#125; xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; const res = JSON.parse(xhr.responseText) if (res.code === 200) &#123; alert('上传成功') this.prefetch(res.list) // 预加载视频列表资源 &#125; else &#123; alert('上传失败') &#125; &#125; &#125; xhr.open('POST', url, true) // xhr.setRequestHeader('Content-Type', 'multiple/form-data') // 不需要设置该头部，否则上传失败 xhr.send(params) &#125; prefetch(list) &#123; const headEle = this.$('head') const links = this.$('link[rel=prefetch]') || [] links.length &amp;&amp; [...links].forEach(item =&gt; &#123; headEle.removeChild(item) &#125;) let fragment = document.createDocumentFragment() (list || []).forEach(item =&gt; &#123; let link = document.createElement('link') link.setAttribute('rel', 'prefetch') link.setAttribute('href', item.src) fragment.appendChild(link) &#125;) headEle.appendChild(fragment) &#125; handleCaptureImage() &#123; const scale = 0.8 const video = this.options.videoEle video.addEventListener('loadeddata', () =&gt; &#123; let canvas = document.createElement('canvas') canvas.width = video.videoWidth * scale canvas.height = video.videoHeight * scale canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height) this.params.imageSrc = canvas.toDataURL("image/png") // base64格式 &#125;) &#125; formatTime(seconds) &#123; return seconds ? [ parseInt(seconds / 60 / 60), parseInt(seconds / 60 % 60), parseInt(seconds % 60) ].join(':').replace(/\b(\d)\b/g, '0$1') : '' &#125; &#125; const upload = new Upload(&#123; url: '/restful/upload', userId: 007, types: ['mp4'], maxSize: '', isCaptureImage: false, videoEle: $('.video-duration') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再回原点]]></title>
    <url>%2F2018%2F06%2F07%2F%E5%86%8D%E5%9B%9E%E5%8E%9F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[致敬曾经那个上知天文下知地理，廉颇老矣，尚能饭否… 回历史流，仿佛一瞬间眼前轻云蔽日般的空间似曾梦识。东汉末年，三马同槽，开创魏晋风骨，不攻成便成人。马云最大的遗憾就是创立阿里巴巴，回到出发点，继任一名普通而伟大的布教者，或许在某个偏远山区发光发热，或许为此刻在考场外急不可耐。马化腾缺失高交会那场绝地邂逅，或许还是个憨厚程序猿，正为打通某程序二脉而喜色无形，也就没有如今友圈的孤僻焦虑症。马明哲讲自己是一名推销员，回到蛇口当头，踏实兢业当好国企一把手，也就不会有平安三十载不忘初心。马云的蚂蚁金服，马化腾的微信红包，马明哲的金融全套，都是干爹。 回空虚处，百无聊赖当书生，自许书中颜如玉。今夕，智障界两泰斗，南抖音北快手，当愉快的双手快速的在不及七寸的砖头上翻屏时候，是否有那么一刻身体突然瑟瑟发抖，对的，已经凌晨三四点了。 回来时路，难忘离别深情眼眸，荡徜千叮咛万嘱咐，押上青春作赌注。走出半生，归来依旧识家路。 回童真时，回归大雁穿行晚霞，漫山遍野依旧童时草莽。瞧，赤身与裸脚，夏蝉与知了。 回学无涯，为中华复兴，为后世谋福，为己观世相。奋斗的青春最美，唯学的韶华不老。 回晌午后，阳光西斜，光棱透析间洒入杯半茶中，不知是茶黄还是光的影色。半掩的窗台外，涟漪澜波穿棱几条木桅帆船，岸边停留着一辆120救护车，炫彩的警灯闪烁着晕光飞绪……廉颇老矣，尚能饭否。 叶子的飘去，是因为树的尽头，还是风的追求？外婆的去世，不是终点的尽头，而是另一个世界的开头。 林龙儿2018/06/07•深圳]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面不可见状态下的性能优化]]></title>
    <url>%2F2018%2F06%2F03%2Fweb%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近开发过程遇到一个需求，web浏览器tab切换的过程需要对即将显示以及隐藏的页面分别进行预处理，本文介绍H5新增API visibilitychange的使用，该API对提高浏览器内存利用、优化性能等有较大作用，实际开发中可尝试接入使用。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152~function() &#123; var EventUtil = &#123; addEventHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler) &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler) &#125; else &#123; element["on" + type] = handler &#125; &#125;, removeEventHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.removeEventListener(type, handler) &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler) &#125; else &#123; element["on"+type] = null &#125; &#125; &#125; var vcConfig = &#123; hidden: '', visibilityChange: '', handler: function() &#123; if (!document[this.hidden]) &#123; console.log('handle sth here...') &#125; else &#123; console.log('stop some action here...') &#125; &#125; &#125; if (typeof document.hidden !== 'undefined') &#123; vcConfig.hidden = 'hidden' vcConfig.visibilityChange = 'visibilitychange' &#125; else if (typeof document.msHidden !== 'undefined') &#123; vcConfig.hidden = 'msHidden' vcConfig.visibilityChange = 'msvisibilitychange' &#125; else if (typeof document.webkitHidden !== 'undefined') &#123; vcConfig.hidden = 'webkitHidden' vcConfig.visibilityChange = 'webkitvisibilitychange' &#125; EventUtil.addEventHandler(window, 'load', function() &#123; EventUtil.addEventHandler(document, vcConfig.visibilityChange, vcConfig.handler) &#125;) EventUtil.addEventHandler(window, 'unload', function() &#123; EventUtil.removeEventHandler(document, vcConfig.visibilityChange, vcConfig.handler) &#125;)&#125;() 1、handler执行的条件包括tab页切换以及窗口最小化后打开。2、针对定时轮询的页面特别有优势，在页面不可见时停止轮询动作，可极大的减少服务端不必要的开销。3、对于音视频的缓冲、循环播放等，在页面隐藏状态下停止操作，减少不必要带宽支出。4、页面中涉及到图片轮播、动画特效、定时操作等，页面不可见时减少浏览器内存开销，这一点有点类似requestAnimationFrame，在处于不可见状态时将停止定时动作。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些js方法的人工babel]]></title>
    <url>%2F2018%2F05%2F20%2F%E4%B8%80%E4%BA%9Bjs%E6%96%B9%E6%B3%95%E7%9A%84%E4%BA%BA%E5%B7%A5babel%2F</url>
    <content type="text"><![CDATA[浏览器内置的原生方法诸如bind、apply、forEach、create，甚至ES6的解构、let、promise等，不止于会使用，如果能用原生代码模拟实现其相关功能，对于更深入理解及正确使用其方法有重要作用。 call、apply的实现call与apply是所有函数对象内置的两个方法，均用于改变this的指向， 二者区别在于执行函数接收参数的形式不同。12345678910Function.prototype.call = Function.prototype.call || function() &#123; var args = [...arguments] var content = args.shift() if(content === null || content === undefined) content = window content.fn = this var result = content.fn(...args) // 如果是apply，传进来的参数为数组，则换成content.fn(args[0] ? ...args[0] : null) delete content.fn return result // 函数的返回值&#125; bind的实现bind的实现需要考虑2种可能，一种是直接bind完的函数直接被调用，一种是bind完的函数执行new操作，其中的this指向不同，得到的结果不一样，需要区别开来。12345678910Function.prototype.bind = Function.prototype.bind || function() &#123; var args = [...arguments] var content = Array.prototype.shift.call(args) var _this = this function Fn() &#123; return _this.apply(this instanceof Fn ? this : content, args.concat(arguments)) &#125; Fn.prototype = Object.create(this.prototype) return Fn&#125; 对象与数组解构ES6语法中三个点的解构写法，可通过以下方法babel转换，注意解构可能是空对象赋值，也可能是原有对象新增属性。12345678910111213141516171819202122// 对象赋值解构: newObj = &#123; ...obj1, ...obj2 &#125;var _extends = Object.assign || function() &#123; var target = [].shift.call(arguments) || &#123;&#125; for (var i = 0; i &lt; arguments.length; i++) &#123; var source = arguments[i] for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key] &#125; &#125; return target&#125;// 数组赋值解构: newArr = [ ...arr1, ...arr2 ]var _extends = function() &#123; var target = [].shift.call(arguments) || [] for (var i = 0; i &lt; arguments.length; i++) &#123; target.concat(arguments[i]) &#125; return target&#125;// 使用方式_extends(newObj, obj1, obj2) || _extends(newArr, arr1, arr2) let实现js中没有块级作用域的概念，let的声明实则是通过闭包模拟了一个块级作用域。12345678910for (let i = 0; i &lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 0)&#125;// 实则为：function let_loop(params) &#123; setTimeout(() =&gt; &#123; console.log(params) &#125;, 0)&#125;for (var i = 0; i &lt; 5; i++) &#123; let_loop(i)&#125; Object.create实现该方法接收一个对象并返回一个新的对象，新对象的原型将指向接收的参数对象。12345Object.prototype.create = Object.prototype.create || function(obj) &#123; var F = function() &#123;&#125; F.prototype = obj return new F()&#125; Object.keys实现Object.keys与Object.getOwnProperty两者的相同点在于当且只能遍历自身属性，无法遍历原型链上属性，区别点在于前者只能遍历自身可枚举的属性，后者可遍历自身可枚举与不可枚举属性。1234567Object.keys = Object.keys || function(o) &#123; var k = [], p = '' for (p in o) &#123; if (Object.prototype.hasOwnProperty.call(o, p)) k.push(p) &#125; return k&#125; clone深复制实现主要通过递归遍历方式进行简单的复制与赋值，未考虑函数类型的处理。12345678910Object.prototype.clone = function() &#123; var ts = Object.prototype.toString var o = ts.call(this) === '[object Array]' ? [] : &#123;&#125; for (var i in this) &#123; if (Object.prototype.hasOwnProperty.call(this, i)) &#123; o[i] = ['[object Object]', '[object Array]'].indexOf(ts.call(this[i])) &gt; -1 ? this[i].clone() : this[i] &#125; &#125; return o&#125; Promise实现ES6中Promise的实现比较复杂，涉及到多种状态机的判断，本模拟只是提供一种简单粗暴的实现思路，未做具体的状态判定，例如多级链式调用等情况。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class myPromise &#123; constructor(fn) &#123; this.sus = null this.fail = null this.stat = '' this.queue = [] const _this = this function reslove() &#123; _this.stat = 'sus' _this.sus = [...arguments] _this.queue.forEach(obj =&gt; &#123; obj.fn1(..._this.sus) &#125;) &#125; function reject() &#123; _this.stat = 'fail' _this.fail = [...arguments] _this.queue.forEach(obj =&gt; &#123; obj.fn2(..._this.fail) &#125;) &#125; fn(resolve, reject) &#125; then(fn1, fn2) &#123; if (this.stat === 'sus') &#123; fn1(...this.sus) &#125; else if (this.stat === 'fail') &#123; fn2(...this.fail) &#125; else &#123; this.queue.push(&#123; fn1, fn2 &#125;) &#125; &#125; //该all方式使用的是同步调用，与实际异步方式不同 all(arr) &#123; return new myPromise((resolve, reject) =&gt; &#123; var resArr = [], i = 0 function next() &#123; arr[i].then(res =&gt; &#123; resArr.push(res) i++ i === arr.length ? reslove(resArr) : next() &#125;, reject) &#125; next() &#125;) &#125;&#125; 自定义监听事件浏览器内置的事件监听有click，dbclick及其他鼠标事件等，但对于一些鼠标三击事件等非内置事件可能需要自定义。另外自定义事件还可用于参数传递，这点在vue里面的eventBus体现。1234567891011121314151617181920212223class myEvent &#123; constructor() &#123; this.obj = &#123;&#125; &#125; on(name, handler) &#123; if(!this.obj[name]) &#123; this.obj[name] = [] &#125; this.obj[name].push(handler) &#125; emit(name, ...args) &#123; if(!this.obj[name] || !this.obj[name].length) return this.obj[name].forEach(fn =&gt; &#123; fn(...args) &#125;) &#125; off(name, handler) &#123; if(!this.obj[name] || !this.obj[name].length) return this.obj[name].forEach((fn, index) =&gt; &#123; if(fn === handler) &#123; this.obj[name].splice(index, 1) &#125; &#125;) &#125;&#125; forEach/map/reduce/filter常见的几种高阶函数的模拟实现，其中reduce可以替换其他几个的功能。1234567891011121314151617181920212223242526272829303132//forEachArray.prototype.forEach = Array.prototype.forEach || function(fn, _this = null) &#123; for (var i = 0; i &lt; this.length; i++) &#123; fn.call(_this, this[i], i) &#125;&#125;//mapArray.prototype.map = Array.prototype.map || function(fn, _this = null) &#123; var arr = this, len = this.length, i = 0, resArr = [] while (i &lt; len) &#123; if (i in arr) &#123; resArr[i] = fn.call(_this, arr[i], i, arr) &#125; i++ &#125; return resArr&#125;//reduceArray.prototype.reduce = Array.prototype.reduce || function(fn, _this = null) &#123; var init = 0 for (var i = 0; i &lt; this.length; i++) &#123; init = fn.call(_this, init, this[i], i) &#125; return init&#125;//filterArray.prototype.filter = Array.prototype.filter || function(fn, _this = null) &#123; var arr = this, len = this.length, i = 0, resArr = [] while (i &lt; len) &#123; if (i in arr &amp;&amp; fn.call(_this, arr[i], i, arr)) &#123; resArr[i] = arr[i] &#125; i++ &#125; return resArr&#125; setTimeout模拟setInterval定时器12345678910111213141516171819202122232425262728293031323334353637383940414243// 简单封装let timer = nullfunction handler() &#123; console.log('well done')&#125;function intervalFn(fn, delay) &#123; fn() timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; intervalFn(fn, delay) &#125;, delay)&#125;intervalFn(handler, 3000)// 类的多实例封装class IntervalTimer &#123; constructor(handler, delay, isImmediate) &#123; this.timer = null this.handler = handler this.delay = delay this.isOff = false // 关闭定时器的标志位 this.isImmediate = !!isImmediate // 是否立即执行定时器，默认不立即执行 &#125; onInterval() &#123; this.isOff = false this.doInterval() &#125; offInterval() &#123; clearTimeout(this.timer) this.isOff = true &#125; doInterval() &#123; this.isImmediate &amp;&amp; this.handler() this.isImmediate = true // 此处加标志位做判断是防止在handler中调用了关闭定时器的操作，因此需要通过this.isOff置为true，从而阻止后面代码继续执行，避免再次打开定时器 if (this.isOff) return this.timer &amp;&amp; clearTimeout(this.timer) this.timer = setTimeout(this.doInterval.bind(this), this.delay) &#125; init() &#123; this.doInterval() &#125;&#125;// setInterval与以上方案的区别在于setInterval一旦开启之后不管回调函数是否已经执行完成只要时间间隔到达即刻将新的回调函数加入执行队列，假设执行回调函数时长比间隔周期长，可能会导致异常结果。而setTimeout模拟的方案则只有在上一个定时器的回调函数执行结束后才会根据间隔周期开启下一个定时器继续新的回调执行。 模拟webpack.merge方法的实现有以下o1、o2两个对象，通过merge方法合并生成result对象，对象属性实现拓展与覆盖。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 有对象o1、o2:var o1 = &#123; a: &#123; a1: &#123; a11: &#123; a111: &#123; a1111: 'o1-a1111' &#125;, a112: [], a113: [1, 2] &#125; &#125; &#125;, b: 9&#125;var o2 = &#123; a: &#123; a1: &#123; a11: &#123; a111: &#123; a1111: 'o2-a1111', a1112: 'o2-a1112' &#125;, a112: &#123;&#125;, a113: _ =&gt; &#123;&#125; &#125;, &#125; &#125;, c: 8&#125;// 合并生成result单个对象var result = &#123; "a": &#123; "a1": &#123; "a11": &#123; "a111": &#123; "a1111": "o2-a1111", "a1112": "o2-a1112" &#125;, "a112": &#123;&#125;, "a113": _ =&gt; &#123;&#125; &#125; &#125; &#125;, "b": 9, "c": 8&#125;// 实现方法：const merge = (() =&gt; &#123; const ts = _ =&gt; Object.prototype.toString.call(_) const isObject = _ =&gt; ts(_) === '[object Object]' const isArray = _ =&gt; ts(_) === '[object Array]' return (o1 = &#123;&#125;, o2 = &#123;&#125;) =&gt; &#123; // 这里简单借助for...in遍历数组与对象，缺点是遍历原型链太长导致效率低 // 可以优化区分类型对数组使用forEach、对象添加hasOwnProperity过滤 for (const key in o2) &#123; const value1 = o1[key], value2 = o2[key] const isDeep = (isArray(value1) &amp;&amp; isArray(value2)) || (isObject(value1) &amp;&amp; isObject(value2)) o1[key] = isDeep ? merge(value1, value2) : value2 &#125; return o1 &#125;&#125;)()// 调用console.log(merge(o1, o2)) end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究函数执行过程]]></title>
    <url>%2F2018%2F05%2F15%2F%E6%8E%A2%E7%A9%B6%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[了解函数执行过程发生了什么，有利于充分理解作用域、作用域链、闭包等问题，也有利于编写更优化更高性能的代码。本文按照本人的初步理解，尽最大可能讲明白执行过程的关键概念，可能有理解不到位出入的地方，毕竟这是个复杂的过程，欢迎讨论指正。 函数被调用的初始化阶段可以用一个执行环境EC对象来表示，该执行环境在函数被调用时压入执行环境栈中，保证程序按照正确的顺序被执行。每个函数有自己的执行环境，当执行一个函数时，该函数的执行环境被推入执行环境栈顶部并获取执行权(push)，当该函数执行完毕，其执行环境将从栈顶删除(pop)，并把执行权交给之前的执行环境。执行环境EC包含3个属性，分别为变量对象VO、作用域scope及作用域链scopeChain，初始化的过程就是给这3个属性求值并完成赋值的过程。先大概记住这么几句话： 函数的作用域与声明位置有关，与调用位置无关。 函数被调用的过程有2个阶段，一个是初始化阶段，一个是执行阶段。 函数内部this的指向与函数被调用环境有关，与声明位置无关。 函数的形参及变量提升在函数初始化阶段被声明，且函数内部声明的函数可覆盖形参中的函数，其他类型的声明则不会。 函数的作用域链在函数被调用的初始化阶段才真正形成。 变量对象VO属性VO对象包括所有的形参、内部函数提升的变量、内部函数声明，以及[[scope]]，this等属性，函数被调用的初始化阶段分别对这些属性求值。 参数声明其中arguments对象、形参、内部提升的变量以及内部函数声明，有以下几点规则： 函数形参 :VO对象的一个属性，属性名为形参名，值为实参值，若无实参传入，则值为undefined； 变量声明 :只针对通过var声明的变量才具有变量提升作用，此时属性名为变量名，值为undefined，如果该变量名与声明的函数名或函数的形参名相同，该变量声明将直接被忽略； 函数声明 :函数内部通过function关键字声明出来的具名函数，如果该函数名在变量对象中已存在，则该声明函数将覆盖原有的属性值。举2个栗子：123456789101112131415161718192021222324// 栗子一function a(x) &#123; console.log(x) function x() &#123;&#125;&#125;a(11) // function x()&#123;&#125;function b(x) &#123; console.log(x) var x = 22 console.log(x)&#125;b(11) // 11和22// 栗子二var name = 'World'~function () &#123;if (typeof name === 'undefined') &#123; var name = 'Jack' console.log('Goodbye ' + name)&#125; else &#123; console.log('Hello ' + name)&#125;&#125;()// 打印结果为：'Goodbye Jack' [[scope]]该属性根据内部函数定义声明的环境确定其属性值，其属性值指向VO对象本身。举个栗子，假设现有函数A，在其内部定义声明一个函数B，则在A函数的VO(A)对象上将会有属性{B: function, B[[scope]]: this或VO(A)}。每个函数在定义的时候，都会创建一个与之关联的[[scope]]属性，该属性总是指向定义函数时所在的环境，这也可以理解为函数的作用域与其定义声明的环境相关，因为[[scope]]属性指向VO本身，所以能访问到的属性有且只有当前的VO属性及索引到以上作用域的变量。12345678910111213141516171819202122232425262728293031var x = 10function a() &#123; console.log(x)&#125;function b() &#123; var x = 5 a()&#125;b()//变形1var x = 10function a() &#123; console.log(x)&#125;function b() &#123; x = 5 a()&#125;b()//变形2var x = 10function b() &#123; var x = 5 a() function a() &#123; console.log(x) &#125;&#125;b()// 分别打印: 10 5 5 thisthis属性求值，以下罗列几种值的可能性： Function Invocation Pattern诸如foo()的调用形式，是函数最直接的使用形式，注意这里的foo是作为单独的变量出现，而不是属性。在这种模式下，foo函数体中的this永远为Global对象，在浏览器中就是window对象。主要严格模式下为undefined。 Method Invocation Pattern诸如foo.bar()的调用形式，注意其特点是被调用的函数作为一个对象的属性出现，必然会有“.”或者“[]”这样的关键符号。在这种模式下，bar函数体中的this永远为“.”或“[”前的那个对象，如上例中就一定是foo对象。 Constructor Patternnew foo()的调用形式，其关键字new就很能说明问题，非常容易识别。在这种模式下，foo函数内部的this永远是new foo()返回的对象。 Apply Patternfoo.call(thisObject)和foo.apply(thisObject)的的调用形式，使用了内置的call和apply函数。在这种模式下，call和apply的第一个参数就是foo函数体内的this，如果thisObject是null或undefined，那么会变成Global对象。 指向html自身元素这种在事件处理中通过传递this可以将本身元素标签进行传递。 this还可能在函数内部指向arguments对象当函数作为形参传递时，通过arguments对象可以获取到该函数调用，这时函数内部的this指向即为arguments对象。应用以上6种方式，确定一个函数是使用什么样的Pattern进行调用的，就能很容易确定this是什么。另外，this是永远不会延作用域链或原型链出现一个“查找”的过程的，只会在函数调用时就完全确认。1234567891011121314151617181920212223//栗子var res = (function () &#123; var a = b = 11 var obj = &#123; a: 22, b: this.a, c: this.b, fn: function() &#123; console.log(this.a, b); (() =&gt; &#123; console.log(this.a) &#125;)() return function(c) &#123; var c console.log(this.a, b, c) &#125; &#125; &#125; return obj&#125;)()res.fn()(33)// 打印结果：// 22 11// 22// undefined 11 33 scope属性scope属性与VO对象同级，该属性与VO对象中的[[scope]]属性不一样，前者指的是上一级的作用域，后者指的是当前的作用域，两者的区别就在于作用域范围的不同。 scopeChain属性作用域链scopeChain属性值在初始化时，获取到EC对象中的scope属性，同时将VO属性添加到作用域链的顶端，这样就形成一条自顶向下的作用域链。任何标识符的查找都是通过这条链进行检索，一直检索到全局作用域下，如果还未检索到，则返回undefined，结束检索。 整理的一张导图，仅供参考 more]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas创建水印背景的思路]]></title>
    <url>%2F2018%2F04%2F25%2Fcanvas%E5%88%9B%E5%BB%BA%E6%B0%B4%E5%8D%B0%E8%83%8C%E6%99%AF%E7%9A%84%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最近入职一家金融公司，由于金融安全等级比较高，公司内部所有电脑、app等页面均默认带上个人登录账号信息水印，本文尝试着模拟实现一个添加自适应水印背景的方案。 step one: 创建canvas元素及容器 首先老样子，上来先写好所需元素结构，然后给点color see see，注意一点的是canvas元素添加宽高方式不能直接在样式表里面设置，转换一下思路，把canvas元素当做一个img标签来看就能明白为什么了，图片如果直接通过style设置宽高，将会有拉伸的可能。 canvas没有写width跟height属性时，默认值为300和150，这里先不写，因为后面需要根据容器的大小动态设置。 给canvas元素设置display:none是因为该画布并不需要出现在页面上，且不应该占据页面文档流位置。1234567891011&lt;!--元素部分--&gt;&lt;body&gt; &lt;canvas id="canvas" style="display:none"&gt;&lt;/canvas&gt; &lt;div id='container'&gt;test&lt;/div&gt;&lt;/body&gt;&lt;!--样式部分--&gt;&lt;style&gt;html,body &#123; margin: 0; padding: 0; &#125;#container &#123; width: 100vw; height: 100vh; &#125;&lt;/style&gt; step two: 函数实现部分考虑到函数的可复用性，将实现函数进行作用域封装，通过FIFE方式的好处是变量跟函数的声明动作只需要进行一次，当然也因此造成了作用域链长的问题。作用域内部全局声明2个变量，一个类似jq的$元素选择器，一个是不同函数间传递的图片变量。之后是3个实现的具体步骤，也分别通过函数方式进行区分。 动态获取容器宽高。首先获取需要添加背景水印的容器尺寸，由于元素的宽高设置可能通过内联也可能是外联样式进行设置，因此这里使用getComputedStyle方法进行获取元素的宽高(IE下是另外一个方法)，由于获取到的值是带px单位的字符串，而canvas只接受数字类型的宽高，因此通过parseInt方法进行一下转换，最后将值赋给canvas的width、height属性即可。 生成canvs图片。canvas是参数设置先行的特点，即所有的参数设置需要在画笔画下去之前进行设置才能生效，这里通过canvas画布的大小动态设置水印字符的规格可根据需求调整，比如间隔、字体、大小等，设置canvas字符串的关键方法是fillText，接受3个参数，分别是字符串、x坐标、y坐标。最后将canvas画布通过toDataURL方法导出为base64的图片格式。 设置canvas图片作为背景图。这一步比较简单，就是将第二步获取到的图片设置为容器的背景。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let getWaterMark = (function() &#123; //声明2个全局变量 const $ = document.querySelector.bind(document) let watermarkImage = null //声明3个函数 function getContainerSize(canvas, containerId) &#123; const containerEle = window.getComputedStyle($(containerId)) canvas.width = parseInt(containerEle.width, 10) canvas.height = parseInt(containerEle.height, 10) &#125; function getCanvasImg(canvas, str) &#123; let ctx = canvas.getContext("2d") ctx.font = "20px Helvetica" ctx.fillStyle = "rgba(225, 0, 0, .5)" ctx.rotate(-45 * Math.PI / 180) const canvasW = canvas.width * 1.414 const canvasH = canvas.height * 2 let widthArr = [], heightArr = [], n = 0 while (n &lt;= canvasW) &#123; widthArr.push(n) n += canvasW * .2 &#125; n = 100 while (n &lt;= canvasH) &#123; heightArr.push(n) n += canvasH * .15 &#125; widthArr.forEach(function(item) &#123; heightArr.forEach(function(it) &#123; ctx.fillText(str, item, it) item !== -item &amp;&amp; ctx.fillText(str, -item, it) &#125;) &#125;) watermarkImage = canvas.toDataURL("image/png") &#125; function setWatermark(id) &#123; watermarkImage &amp;&amp; $(id).style.background = `url($&#123;watermarkImage&#125;) no-repeat fixed` &#125; //返回调用函数 return function(canvasId = 'canvas', containerId = 'body', waterText = 'I am default') &#123; let canvas = $(canvasId) // 动态获取容器宽高 getContainerSize(canvas, containerId) //生成canvs图片 getCanvasImg(canvas, waterText) // 设置canvas图片作为背景图 setWatermark(containerId) &#125;&#125;)() step three: 窗口监听这里对窗口大小的缩放进行监听并动态修改背景图片大小，考虑到窗口大小缩放频率比较高，因此采用防抖函数节省性能支出。123456789101112//窗口监听window.onresize = function() &#123; debounce(() =&gt; &#123; getWaterMark('#canvas', '#container', 'zhangbinglin666') &#125;)&#125;//防抖函数let debounce = (function() &#123; let timer = null return function(fn, delay = 300) &#123; clearTimeout(timer) timer = setTimeout(fn, delay) &#125;&#125;)() step final: 效果最后的展示效果如下，源码地址这里]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈new的实例化过程]]></title>
    <url>%2F2018%2F03%2F22%2F%E8%B0%88%E8%B0%88new%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浏览器实现new实例化的过程我们都知道有三个步骤，分别是创建一个空的实例化对象this、将this的原型（__proto__属性）指向构造函数的prototype（实例原型）、执行构造函数并最终默认返回this。现假设业务开发中提出这么3点需求，需要代码层面进行实现，本文将尝试通过自定义一个方法模拟实现该业务的功能需求。 new的栗子首先看一下实际应用中new的使用，实例对象包括浏览器内置的Object、Array、Date等及自定义构造函数，其中构造函数内部的返回值如果没写或者返回的不是基本类型的值，则默认返回this。而对于构造函数原型上的方法默认返回值为undefined，因此如果需要支持链式调用，则需要显性返回一个this，即实例对象。如果使用ES6新定义的class关键字，则类的书写结构更加清晰，但要知道这只是语法糖，背后的实现还是通过构造函数的方式实现。12345678910111213141516171819202122232425262728//创建一个JQ构造函数，并支持链式调用function JQ(el) &#123; this.el = el return this //默认返回值，可以不写&#125;JQ.prototype.on = function(type, fn) &#123; this.el.addEventListener(type, fn) return this&#125;//使用方式var jq = new JQ(document.getElementById('id'))jq.on('mouseover', function() &#123; console.log('mouseover')&#125;).on('mouseleave', function() &#123; console.log('mouseleave')&#125;)// 使用ES6 class关键字的方式创建的类class JQ &#123; constructor(el) &#123; this.el = el &#125; on(type, fn) &#123; this.el.addEventListener(type, fn) return this &#125;&#125; 初步实现由于new是js的关键字，无法像浏览器内置函数如bind、forEach等直接覆盖，所以这里的模拟通过封装一个函数进行模拟，函数支持1个以上参数，第一个参数即为构造函数，剩下参数为该构造函数的参数，使用方式如下：var jq = myNew(JQ, el)。基本思路： 创建一个新的空对象，并获取构造函数 将构造函数的prototype赋给实例对象的原型，实现继承 实例对象通过call的方式调用构造函数 返回实例化对象1234567function myNew() &#123; var Constructor = [].shift.call(arguments) var obj = &#123;&#125; obj.__proto__ = Constructor.prototype Constructor.call(obj, arguments) return obj&#125; 优化版本以上版本整体思路是对的，但中间有几个点需要注意： 构造函数的prototype直接等于实例对象的__proto__，这种实现继承方式有2个问题，一个会导致原型可被实例对象轻易修改，一个是__proto__不兼容； 直接返回实例化对象，即默认返回this，没有考虑到构造函数返回其他类型值的可能。以下版本对上面2点进行优化：1234567891011121314151617181920212223242526function myNew() &#123; //第一步：获取构造函数 var Constructor = [].shift.call(arguments) //第二步：创建一个空的新对象并将原型指向构造函数的prototype属性 var obj = Object.create(Constructor.prototype) //第三步：传入参数执行构造函数，这里要保证调用对象为上面创建的对象，确保this的指向 var result = Constructor.apply(obj, arguments) //第四步：判断构造函数的返回值决定return内容，这里需要注意返回值为null的情况 return (result &amp;&amp; typeof result === 'object') ? result : obj&#125;// 使用方式var jq = myNew(JQ, document.getElementById('id'))jq.on('mouseover', function() &#123; console.log('mouseover')&#125;).on('mouseleave', function() &#123; console.log('mouseleave')&#125;)//关于Object.create的兼容Object.prototype.create = Object.prototype.create || function(obj) &#123; var F = function() &#123;&#125; F.prototype = obj return new F()&#125; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于防抖节流函数的实现与优化]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%85%B3%E4%BA%8E%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端开发中，对于大多数的事件监听都会导致页面的高频触发重渲染，诸如滚动事件、窗口缩放、鼠标事件等，而浏览器最常见的页面渲染的帧频为60fps，即每秒刷新帧数为60，约1000/16=16.7ms刷新一帧，因此任何低于高频率的操作皆无法及时的放映到页面上，消费无用功且极大消耗CPU性能。因此对于大多数高频执行考虑通过延迟执行的方式进行优化，类似的有防抖、节流等处理，详见本文。 防抖函数防抖函数的思路是通过屏蔽事件监听的过程，忽略其他阶段，只考虑执行最后一次事件处理函数。下面的方法默认最后一个事件处理的延迟执行操作时间为300毫秒，可以很好的屏蔽大部分的高频操作事件，达到提升性能的作用，且延迟执行时间可自由配置。栗子中设置了延迟时间为1000毫秒，假设用户持续操作窗口缩放的时间为2000毫秒，那么防抖函数将在2000毫秒之后+1000毫秒延迟时间，共3000毫秒之后执行处理函数。因此，该方式只适合时效性要求不是很高的事件处理上，不适合图片懒加载等要求及时的应用上面。12345678910111213141516//窗口监听事件window.onresize = function() &#123; debounce(doSth, 1000)&#125;//防抖函数let debounce = (function() &#123; let timer = null return function(fn, delay = 300) &#123; timer &amp;&amp; clearTimeout(timer) timer = setTimeout(fn, delay) &#125;&#125;)()//业务处理函数function doSth() &#123; console.log('well, some action here...')&#125; 节流函数节流函数的思路是通过类似轮询的方式，根据设置的定时间隔，每隔固定时长执行一次事件处理函数，相对于防抖函数具有更高的时效性。栗子中设置了延迟时间为1000毫秒，假设用户持续操作窗口缩放的时间为3000毫秒，那么节流函数将每隔1000毫秒执行一次处理函数，整个过程总共执行3次。但假如用户持续操作窗口缩放的时间比延迟时间短，只有500毫秒，则将退回防抖函数的处理方式。123456789101112131415161718192021222324252627//窗口监听事件window.onresize = function() &#123; throttle(doSth, 1000)&#125;//节流函数let throttle = (function() &#123; let timer = null, prev = null, now = null return function(fn, delay = 1000) &#123; now = new Date() if(!prev) &#123; fn() //当首次调用时立即执行 prev = new Date() return &#125; timer &amp;&amp; clearTimeout(timer) if(now - prev &lt;= delay) &#123; timer = setTimeout(fn, delay) //退回防抖方式 &#125; else &#123; fn() //当窗口缩放结束，第二次重新开启缩放时立即执行 prev = now &#125; &#125;&#125;)()//业务处理函数function doSth() &#123; console.log('well, some action here...')&#125; 一种更优化的思路这种方式与以上2种有以下几点不同： 通过一个标志位控制业务函数的执行； 事件触发立即执行业务函数，而不是延迟执行，且之后每隔所设置的延迟时间间隔后再次执行； 假设两种场景，一种是用户缩放窗口时间比所设置延迟时间小，则该方法立即执行了一次业务函数，之后延迟时间到达后标志位恢复；另外一种是用户缩放窗口时间比所设置延迟时间长，则该方法立即执行一次之后，每隔相同的延迟时间后标志位恢复循环执行。 结合以上几点，个人感觉这种方式比以上2种更优，如有不同意见，欢迎探讨。123456789101112131415161718192021222324252627//防抖节流函数class Optimistic &#123; constructor(fn, delay) &#123; this.method = this.method.bind(this) this.flag = true this.fn = fn this.delay = delay this.timer = null &#125; method() &#123; if (this.flag) &#123; this.timer &amp;&amp; clearTimeout(this.timer) this.flag = false this.fn() this.timer = setTimeout(() =&gt; &#123; this.flag = true &#125;, this.delay) &#125; &#125;&#125;const optimistic = new Optimistic(doSth, 1000).method// 窗口监听事件window.onresize = function() &#123; optimistic() &#125;//业务处理函数function doSth() &#123; console.log('well, some action here...')&#125; 方案源码这里]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发项目的一些规范]]></title>
    <url>%2F2018%2F01%2F11%2Fvue%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[总结利用vue开发几个项目过程中应用到的几条规范，规范对于多人团队开发极为重要，这里只针对vue框架的一个规范，js与css部分未加入，后续将继续总结维护更新。 vue规范1、所有命名必须具有语义化，不允许直接后缀加上1,2,3，js代码使用驼峰命名法，css代码使用-或者_连接符，组件首字符大写。2、关键代码需要注释说明，公用组件需要说明调用方式以及入参、响应参数。3、代码必须格式化，console.log以及注释之类的代码在调试完成后全部删除。4、组件书写顺序按照统一结构排版：&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;。5、组件template最外层标签添加唯一className，组件的name属性名于此相同，书写样式时最外层加上统一加上改className。6、生命周期书写顺序一般按照name、mixins、components、props、data、computed、watch、created、mounted、methods排序。7、提取公共css样式库，解耦css代码，提高className复用性。可参考css库8、公用组件放置components文件夹下，且对于常用的公用组件，将其注册为全局组件使用，非公用组件放置views相关模块文件夹下，所有组件必须首字母大写。9、一个组件逻辑代码部分总行数尽量不超过400行，如果超过考虑进行组件拆分，拆分有2种方式，一种是通过vue提供的mixins功能，一种是直接引入js文件方式，但需要注意作用域问题。同理methods里面尽量编写纯函数，函数解耦，函数功能单一化等。10、所有api的url路径统一提取到一个文件进行维护，可写为常量的形式。11、views文件目录按照功能模块的router层级设置，且最好每个功能模块有个index入口文件，方便快捷根据路由地址找到相关代码。12、vue项目文件目录中不允许存在中文字符，否则热加载失败。13、assets文件夹中尽量按照css、font、images、js文件夹进行区分，非静态资源尽量不要放置在static文件夹。14、所有路由采用按需懒加载方式，ES7的写法是: const ladyLoading = ulr =&gt; () =&gt; import(url)。15、若项目在main.js中引入第三方UI库，需要确保引入的UI库顺序在import App.vue之前，且样式覆盖表也在此之后，这样才能在webpack将css打包成一个文件的时候按序打包，否则可能出现样式错乱。 1234567891011121314151617181920212223242526&lt;template&gt;&lt;div class="test"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'test', mixins: [], components: &#123;&#125;, props: &#123;&#125;, data() &#123; return &#123;&#125; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123;&#125;, mounted() &#123;&#125;, methods: &#123;&#125;&#125;&lt;/script&gt;&lt;style lang="less"&gt;.test &#123;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人类简史阅记]]></title>
    <url>%2F2018%2F01%2F01%2F%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E9%98%85%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近看人类简史，里面提到一个挺有意思的点，人类从采集者身份走向农业时代是一个史上最大的骗局… 人类以为自己驯化了粮食植物，但其实是稻米小麦驯化了我们。 小麦不喜欢石头，人类扛起锄子捡石头，一番腰酸背疼；小麦喜欢独享空间、光线、水分，聪明的人类烈日炎炎锄禾日当午；小麦生病，人类饭饮不思，驱虫把脉；小麦口渴，人类砸壁垦荒，引泉止渴；小麦饥饿，人类筐箧中物，似粪滋肥；…… 明智人类作为麦田守望者，无畏一生，兢兢业业，折脊沉腰，俯首甘为孺子牛，如斯也。 俄后营养充沛，荷尔蒙上亢，养儿弄孙，激增的嗷嗷饥口要求更多肥沃之土壤，更高效高能之孵出。结局反而是量保质不再，不得初心，适得其反。 作者问聪慧人类为何会陷入这般致命误判？回答是：因为我们无法真正了解各种决定最后的结果。我们总以为工作努力辛苦一些，生活就能过得更好一点。 回归当代社会，似乎还是停留在一万年前祖先们的陷阱里，没得进化逃脱。如今我们陷身于欲望与焦虑、房奴与车奴，一味梦想还是要有的，一味明天总会更好的……一边不断熬夜达旦、辘辘肥肠，一边凑齐六味地黄丸搭着枸杞茶慰藉肾气。吸更多霾为下一代除害，赚更多钱为明天看更好医院吸更好氧气奋斗。 挺有意思的点子与感想，与君分勉，不要骂我…]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue递归组件的使用]]></title>
    <url>%2F2017%2F12%2F14%2Fvue%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vue、react等MVVM框架其中一个最大特点是充分利用了组件化可复用性的特点，这个优点体现在管理系统层级菜单的生成中。当层级菜单未知层级或者由后台动态生成时，此时便需要对组件进行递归渲染，vue中称之为递归组件。本文将通过展示一个demo说明使用递归组件时需要注意的几个点，以供参考。 简单聊聊递归递归至少有以下2个特点，一个是调用自己，一个是有结束条件。针对普通的递归函数，如果是具名函数，则可以通过直接使用函数名的方式调用自己，如果是匿名函数，则通过arguments提供的callee进行调用。而对于vue组件，若要调用自己，则需要先给组件赋名，通过设置name属性之后进行调用。至于结束条件是必备条件，满足条件则结束递归，否则将陷入死循环导致堆栈溢出，因此写递归的时候最重要的就是要考虑递归的边界条件。12345678910111213141516171819202122232425262728293031323334353637383940//普通递归函数写法function getMenus(arr = [], menus = []) &#123; arr.forEach(item =&gt; &#123; if (item.path) &#123; routes.push(item) &#125; if (!item.component) &#123; //条件判断 getMenus(item.children, menus) //调用自己 &#125; &#125;) return menus&#125;//递归组件写法&lt;template&gt; &lt;ul&gt; &lt;li v-for="(item, index) in data" :key='index'&gt; &lt;span @click="toggle(item, index)"&gt;&lt;/span&gt; &lt;treeMenu :data="item.children" v-if="scope[index]" /&gt; //v-if是关键 &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'treeMenu', //关键 props: &#123; data: &#123; type: Array, default: [] &#125; &#125;, data() &#123; return &#123; scope: &#123;&#125; &#125; &#125;, methods: &#123; toggle(item, index) &#123; if (item.children &amp;&amp; item.children.length) &#123; this.$set(this.scope, index, !this.scope[index]) &#125; &#125; &#125;&#125;&lt;/script&gt; 说说几个要点1、组件需要设置name属性，命名规则与组件引用相似。2、组件设计的时候需要考虑外部传递参数的形式，比如数组或map对象，需要统一约定好。3、由于需要生成多级菜单，因此会在li标签中嵌套递归自身组件，但每个组件之间没有太多关联，彼此之间数据独立，生命周期独立，因此设计组件的时候需要充分考虑组件的周期，避免不必要或者不合适钩子出现。4、通过引入scope对象，用于单独存储每个组件自身的状态，记录点击的item序号，结合v-if控制组件的显示隐藏，并相应切换icon。最终实现效果如图示，源码地址这里 可能存在的问题1、点击一级icon展开后，再点击二级icon展开，当一级icon收回之后，再展开时先前二级展开的状态丢失，这是由于使用了v-if的原因，可通过v-show替换，但因此也可能带来渲染性能上的问题。2、递归组件继承相同的样式，导致无法针对性设置样式，除非通过数据项进行判断覆盖渲染。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道js基础算法题引发的]]></title>
    <url>%2F2017%2F11%2F21%2F%E4%B8%80%E9%81%93js%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%2F</url>
    <content type="text"><![CDATA[最近工作中遇到一个需求如下：需要将不确定长度的数组[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]转换为JSON对象{&#39;a&#39;:{&#39;b&#39;:{&#39;c&#39;:{&#39;d&#39;:&#39;e&#39;}}}},由此探讨了几种可能性,并尝试反之由{a:{b:{c:{d:e}}}} =&gt; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]的实现方案，一并记录如下。 [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] =&gt; {a:{b:{c:{d:e}}}}几种实现方案第一种方法特点：简单粗暴,基本没有什么逻辑。123456789101112131415161718function arr2Obj(arr, str = '') &#123; let len = arr.length if (len &lt; 2) &#123; return &#125; for (var i = 0; i &lt; len; i++) &#123; if (i &lt; len - 1) &#123; str += `&#123;"$&#123;arr[i]&#125;":` &#125; else &#123; str += `"$&#123;arr[i]&#125;"` &#125; &#125; for (var j = 0; j &lt; len - 1; j++) &#123; str += '&#125;' &#125; return JSON.parse(str) // 或 return eval('(' + str + ')')&#125; 第二种方法特点：采用由里及外逆向扒开循环。1234567891011121314function arr2Obj2(arr) &#123; if (arr.length &lt; 2) &#123; return &#125; let obj = &#123;&#125;, len = arr.length obj[arr[len - 2]] = arr[len - 1] for (let i = len - 3; i &gt;= 0; i--) &#123; let objTemp = &#123;&#125; objTemp[arr[i]] = obj obj = objTemp &#125; return obj&#125; 第三种方法特点：采用递归循环,看时容易写时难。123456789101112131415function arr2Obj3(arrs, obj = &#123;&#125;) &#123; let el = arrs[0] if (arrs.length &gt; 2) &#123; if (!obj.hasOwnProperty(el)) &#123; obj[el] = &#123;&#125; &#125; arrs.splice(0, 1) arr2Obj3(arrs, obj[el]) return obj //注意此处的return位置以及return值很关键 &#125; if (arrs.length === 2) &#123; obj[el] = arrs[1] &#125;&#125; 递归方式实现{a:{b:{c:{d:e}}}} =&gt; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]1234567891011function obj2Arr(obj, arr = []) &#123; for (var prop in obj) &#123; arr.push(prop) if (typeof(obj[prop]) === 'object') &#123; return obj2Arr(obj[prop], arr) &#125; else &#123; arr.push(obj[prop]) return arr &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的一些常用指令]]></title>
    <url>%2F2017%2F11%2F11%2Fgit%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[总结项目常用到的几个git指令，特别当项目内网环境下开发，通过gitLab搭建本地git服务器，常常需要fork一个项目到自己远程仓库或者在远程仓库新增自己的分支，且需要与原仓库项目保持同步等。 常用git指令1、git remote -v 查看已添加的远程仓库详情2、git remote add storeName storeNamePath 添加远程仓库3、git remote rm storeName 删除远程仓库4、git push storeName master:zbl 将本地master分支提交到远程storeName仓库zbl分支上，如果远程storeName仓库中没有zbl分支，则默认创建zbl分支5、git push storeName –delete(或者-d) zbl 删除远程storeName的zbl分支6、git fetch storeName zbl 拉取远程storeName仓库zbl分支代码7、git merge storeName/zbl 将当前本地分支与拉取下来的storeName/zbl分支合并8、git pull storeName zbl 将远程storeName仓库zbl分支吓到本地并同时合并，是6与7的结合9、git branch -a 查看本地及关联远程仓库下的所有分支10、 git status 时时查看修改状态]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数封装库]]></title>
    <url>%2F2017%2F10%2F10%2F%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E5%BA%93%2F</url>
    <content type="text"><![CDATA[集合一些常用的函数封装，持续更新。 通过系统获取时间数据1234567891011121314151617181920function getDays(beginDay = '2017-9-28', endDay = '2017-10-15') &#123; let beginArr = beginDay.split('-') let endArr = endDay.split('-') beginArr[1] = parseInt(beginArr[1]) - 1 + '' //月份减1,系统才能按正确日期排列 endArr[1] = parseInt(endArr[1]) - 1 + '' let begin = new Date(...beginArr) //将日期格式转换为标准格式 let end = new Date(...endArr) let days = [] while ((end.getTime() - begin.getTime()) &gt;= 0) &#123; let year = begin.getFullYear() //获取起始日期的年月日 let month = (begin.getMonth() + 1).toString() //月份重新加1输出 if (month.length === 1) month = '0' + month let day = begin.getDate().toString() if (day.length === 1) day = '0' + day days.push(year + '-' + month + '-' + day) begin.setDate(begin.getDate() + 1) //setDate()方法是将当前日期的日设置为指定的1~31，同理有setMonth、setYear等方法 &#125; return days&#125; vue中利用axios封装Promise请求对象12345678910function requestLoginon(params) &#123; let instance = axios.create(&#123; headers: &#123; "X-Service-Id": "", "X-Service-Method": "", "Content-Type": "application/json" &#125; &#125;) return instance.post(`$&#123;base&#125;/pcn-core/login`, params).then(res =&gt; res.data)&#125; 通过身份证获取生日1234567891011121314function getBirthdayByIdNo(idNo) &#123; iIdNo = idNo.trim() let tmpStr = "" if (iIdNo.length === 15) &#123; tmpStr = iIdNo.substring(6, 12) tmpStr = "19" + tmpStr tmpStr = tmpStr.substring(0, 4) + "-" + tmpStr.substring(4, 6) + "-" + tmpStr.substring(6) &#125; if (iIdNo.length === 18) &#123; tmpStr = iIdNo.substring(6, 14) tmpStr = tmpStr.substring(0, 4) + "-" + tmpStr.substring(4, 6) + "-" + tmpStr.substring(6) &#125; return tmpStr&#125; 通过身份证获取性别123456789101112function getSexCodeByIdNo(idNo) &#123; iIdNo = idNo.trim() let tmpStr = "" if (iIdNo.length === 15) &#123; tmpStr = iIdNo.substring(14) &#125; if (iIdNo.length === 18) &#123; tmpStr = iIdNo.substring(16, 17) &#125; if (tmpStr) return return parseInt(tmpStr) % 2 === 0 ? 2 : 1&#125; 时间格式化12345678910function formatDate(timestamp) &#123; let d = timestamp ? new Date(timestamp) : new Date() let year = d.getFullYear() let month = d.getMonth() + 1 let date = d.getDate() let hour = d.getHours() let minute = d.getMinutes() let second = d.getSeconds() return year + "-" + (month &lt; 10 ? '0' + month : month) + "-" + (date &lt; 10 ? '0' + date : date)&#125; 移动端获取当前操作系统及浏览器信息跳转下载app地址1234567891011121314151617181920212223242526function appDownload(appleUrl, androidUrl) &#123; let ua = navigator.userAgent let browserInfo = function() &#123; //获取移动终端浏览器版本信息 return &#123; trident: ua.indexOf('Trident') &gt; -1, //IE内核 presto: ua.indexOf('Presto') &gt; -1, //opera内核 webKit: ua.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: ua.indexOf('Gecko') &gt; -1 &amp;&amp; ua.indexOf('KHTML') == -1, //火狐内核 mobile: !!ua.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!ua.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: ua.indexOf('Android') &gt; -1 || ua.indexOf('Linux') &gt; -1, //android终端或uc浏览器 iPhone: ua.indexOf('iPhone') &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: ua.indexOf('iPad') &gt; -1, //是否iPad webApp: ua.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125; &#125;() if (ua.toLowerCase().match(/MicroMessenger/i) == "micromessenger") &#123; document.write("&lt;img src='../../static/download_default.png' alt='点击右上角打开默认浏览器下载' width='100%'/&gt;") &#125; else if (browserInfo.ios || browserInfo.iPhone || browserInfo.iPad) &#123; window.location.href = appleUrl //跳转苹果市场 &#125; else &#123; window.location.href = androidUrl //跳转安卓市场 &#125; return&#125; 产生随机长度字符串12345678910111213141516171819202122232425// 第一种方式function randomStr(length) &#123; length = parseInt(length, 10) || 6 if (length &lt;= 6) &#123; return Math.random().toString(36).slice(2, length + 2) &#125; else &#123; let str = '' for (let i = 0; i &lt; Math.ceil(length / 6); i++) &#123; str += Math.random().toString(36).slice(2, 8) &#125; return str.slice(0, length) &#125;&#125;// 第二种常规方式function randomStr2(len) &#123; len = parseInt(len, 10) || 32 let chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678' /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ let str = '' for (i = 0; i &lt; len; i++) &#123; str += chars[Math.floor(Math.random() * chars.length]) &#125; return str&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由传参加密]]></title>
    <url>%2F2017%2F09%2F22%2Fvue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[vue单页面应用 + vue-router的特性，以及组件间的通讯需求，造就前端路由传参这一可期性。但路由传参由于参数的低安全性容易被随意篡改，从而轻易暴露用户隐私，因此对参数进行适当加密且不影响性能就成了另一个需求。本文列出一种对称加密算法对路由传参进行序列化加密供参考。 第一步 第二步 第三步 第四步 最后路由传参有个优势在于如果安卓或者ios端需要调用页面的时候可以入参，并且路由传参的页面强制刷新不会造成页面数据丢失，后期如果有这种需求可以考虑采用路由传参。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全]]></title>
    <url>%2F2017%2F08%2F11%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[常见的前端安全问题有XSS、CSRF、cookies、点击劫持、SQL注入、流量攻击等，以下简单的记录学习过程中的笔记与要点。 一、XSSxss跨站攻击类型有：反射型：URL参数直接注入(可通过短网址等方式进行url转换，从而更加隐秘)存储型：存储数据到DB时读取注入，危害更大 xss攻击注入点：1、html节点内容(即利用了innerHTML插入执行的脚本)2、html属性(利用src属性，或者图片的onerror属性)3、javascript代码4、富文本的本质就是一段复杂的html代码，这样才得以保留富文本的格式。当富文本保存到DB时保存的即该html代码。当存在html时会存在xss攻击风险。 防御措施：1、浏览器自带防御(针对反射型，且只能防御html节点内容及属性，针对JavaScript代码无法防御) 2、针对html节点内容，转义&lt;&gt;1234let escapeHtml = function(str) &#123; str = str.replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;') return str&#125; 3、针对html属性，转义””1234567let escapeHtmlProperty = function(str) &#123;if(!str) return ''str = str.replace(/"/g,'&amp;quto;')str = str.replace(/'/g,'&amp;#39;')str = str.replace(/ /g,'&amp;#32;')return str&#125; 以上两个函数合并成一个：123456789let escapeHtml = function(str) &#123; if(!str) return '' str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g,'&amp;quto;') str = str.replace(/'/g,'&amp;#39;') //str = str.replace(/ /g,'&amp;#32;') 按html标准书写代码，该处可以不对空格进行转义 return str&#125; 4、针对js的转义(注意html转义与js代码转义不一样)123456let escapeForjs = function(str) &#123; if(!str) return '' str = str.replace(/\\/g,'\\\\') str = str.replace(/"/g,'\\"') return str&#125; 上面的转义函数可以防御大部分js代码注入，但还不是很安全，最保险的方式是直接将用户输入的代码用JSON.stringify格式化，再原封返回即可。 5、富文本的输入一般在输入数据库之前进行过滤5.1、黑名单过滤的方式(比较繁琐)1234567let xssFilter = function(html) &#123; if(!html) return '' html = html.replace(/&lt;\s*\/?script\s*&gt;/g,'') html.replace(/javascript:[^'"]*/g,'') ... return html&#125; 5.2、白名单过滤的方式(只保留部分标签与属性，比较保险)介绍一个cheerio库进行解析dom还可以直接利用第三方库–js-xss6、CSP(content-security-policy设置，可查看MDN) 二、CSRFCSRF跨站请求伪造原理：1.用户登录A网站2.A网站确认身份信息3.B网站页面向A网站发起请求(带A网站身份信息)…特征：B网站向A网站发起请求带A网站的cookies不访问A网站的前端referer指向B网站…危害：利用了用户登录态用户不知情完成业务请求防御：1.在服务器返回的cookies中将samesite属性设置为strict，这样只有同域网站才能获取到cookies(但是该属性目前只有在谷歌浏览器中支持)2.向服务器提交信息的时候需要前端A网站的验证信息，比如验证码，token等(nodejs中ccp插件用于提供图形验证码)3.利用前后端匹配token值(前端可以通过在input输入框中隐藏直接提交或者通过将token值保存到meta标签中)，从而判断是否来自正规的A网站的请求4.验证referer，禁止第三方网站请求1/^https?:\/\/localhost/.test(request.header.referer) 三、cookies特性1、只能使用自己域名下的cookies2、有效期3、设置URL上的层级有效4、http-only只允许请求或者接受的时候读取，不允许document.cookie读取5、secure只允许在https中获取6、sameSite7、删除的方式只能通过设置有效期为过去式cookies作用1.存储个性化设置2.存储未登录时用户的唯一标识3.存储已经登录的用户凭证4.存储其他业务数据cookies-登录用户凭证的使用方式：1.用户ID + 后台签名(服务器通过sha2等方式对用户ID进行算法加密之后连着用户ID及签名字符串一块通过cookies返回到前端，当前端提交请求时将该cookies一并提交，后台再计算用户ID进行校验)2.sessionId(用户初次登录成功的时候服务器根据用户ID匹配生成一个sessionId返回给到前端cookies中，之后前端每次请求将带着该sessionId与后台服务器缓存或者数据库中进行匹配获取到对应的用户信息)cookis的安全策略有：1.使用签名防止篡改2.对用户ID进行加密(避免明文显示)3.设置http-only(防止XSS盗用cookies)4.设置secure(只允许https获取cookies)5.设置same-site(防止CSRF利用用户的登录态) 四、点击劫持用户不知情情况下亲手点击(将实际真实的A网站通过iframe嵌入到B网站中，并设置opacity为0，在用户看不到的情况下诱导用户点击B网站上的信息，实则已点击了透明的A网站)防御方法：1.通过JavaScript脚本禁止内嵌(通过判断top.location == window.location)2.X-FRAME-OPTIONS禁止内嵌(通过在相应头header中设置X-Frame-Options属性值为DENY即可禁止该网站被内嵌)，该方法各浏览器兼容很好，推荐使用 五、httpshttp传输窃听篡改(traceroute/window下tracert可以查看网站访问背后的链路节点(各种代理转发)，任何一个节点都可以查看http的明文内容)https原理在浏览器端用SSL(也叫TLS)进行加密之后在链路节点间用密文传输，到达服务器之后再按规则进行明文转换 六、密码-哈希算法1.明文-密文 == 一一对应2.雪崩效应，只要明文有一个差异，整个密文都会不一样3.密文-明文无法反推4.密文固定长度常用的哈希算法：md5、sha1、sha256等单向变换可以通过彩虹表(彩虹表罗列多种密码组合，然后通过查询密文获取对应的明文)进行查询，如果要对抗彩虹表防止密码轻易在彩虹表中被查询到，可以增加密码长度及复杂度，甚至通过多重md5加密，如md5(md5(codecodecode…))，md5(sha1(codecodecode…))等帮用户密码加盐 七、SQL注入防御1.关闭错误输出2.入参时检查数据类型3.对入参数据进行转义4.使用参数化查询(更有保障)5.使用ORM(对象关系映射) 八、流量攻击服务器大规模流量攻击(很难防御)1.TCP半连接2.Http连接3.DNS(解析域名服务器)4.大规模DDOS攻击防御1.防火墙2.交换机、路由器3.流量清洗4.高防IP(云服务厂商重指向到高防IP进行流量清洗)预防1.避免重逻辑业务2.快速失败快速返回3.防雪崩机制4.有损服务5.CDN(静态请求,减轻服务器压力) 九、总结1.简述XSS原理来自用户输入的数据被当做脚本程序被执行，主要包括2.简述XSS防御方法浏览器内置方法对数据进行适当转义&lt;&gt;”‘&amp;对富文本设置白名单CSP指定哪些内容可以被执行哪些不被执行3.XSS防御需要注意的点转义的时候需要注意使用的场景与范围4.CSRF的原理盗用用户登录态，携带cookies对目标网站发起请求5.CSRF危害在用户不知情情况下盗用用户身份6.如何防御same-site规定只允许指定网站访问带验证码或token判断referer7.cookies的作用浏览器存储数据，用户个性化设置、登录标识、身份识别8.cookies与localStorage最大区别是cookies在范围网站时可以自动携带，而storage不可以9.cookies与session关系：服务端产生sessionId通过cookies存在到浏览器中10.cookies具有：无法跨域、存在path层级、有效期、http-only无法通过js读取、secure、same-site等特性，cookies只能通过设置过期时间才能进行删除]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常开发笔记]]></title>
    <url>%2F2017%2F07%2F14%2F%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[收集整理日常开发中的雷区以及可汲取之处，以期日后回望，并不定期更新。 1. npm build的时候需在配置路由中添加”/“根路由，这样在打开index.html的时候默认才是在根路由下。 2. 通过绝对位置进行定位的元素设置垂直居中的方法： 1234position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%); 3. arrow小箭头纯css代码： 1234567891011position: absolute; border: 2.5px solid #fff; border-top: 0; border-left: 0; content: " "; top: 50%; right: -15px; width: .1rem; height: .1rem; -webkit-transform: translateY(-50%) rotate(45deg); transform: translateY(-50%) rotate(45deg); 4. index.html页面中引入html/body两个元素的media query样式，用于适配不同屏幕下元素大小，之后在以其为根元素在其页面内使用rem单位进行样式设置,或者可以通过动态在mounted钩子中设置html元素的font-size。 5. vue组件中可定制图片体积大小上限，从而决定是否将其转换为base64格式文件直接保存在js代码中，从而减少网络请求。 6. 对于v-for渲染出来的列表，可以对其id属性绑定传值，通过e.target.id或者e.currentTarget.id(两个区别在于前者识别的是点击元素，后者识别的是绑定点击事件的元素)获取到该值。 7. 常见的图标类可以通过icomoon在线转换为字体图标，通过引入css及font字体即可在相关标签中加入className，对className设置font-size属性及color属性可对改变其大小与颜色。 8. mint-ui引入之后，在组件中如果设置了scoped，则在该组件的局部样式中无法对UI组件进行修改，解决方案可以通过对vue组件最外层div设置class或者id，然后通过该唯一class或者id包裹组件内部元素的样式。 9. v-show与v-if区别在v-show不满足条件的情况下还会渲染相应的内容但不显示，而v-if如果不满足条件即不渲染且隐藏。 10. vue文件夹不允许使用中文命名，否则无法进行热重载。 11. css写点击选中打钩样式： 12345678910111213141516171819202122232425262728293031323334.icon &#123; display: inline-block; background-color: #fff; border-radius: 100%; border: 1px solid #ccc; position: relative; width: 20px; height: 20px; vertical-align: middle;&#125;.icon:after &#123; border: 2px solid transparent; border-left: 0; border-top: 0; content: " "; top: 3px; left: 6px; position: absolute; width: 4px; height: 8px; -webkit-transform: rotate(45deg) scale(0); transform: rotate(45deg) scale(0); -webkit-transition: -webkit-transform .2s; transition: -webkit-transform .2s; transition: transform .2s; transition: transform .2s,-webkit-transform .2s; border-color: #fff; -webkit-transform: rotate(45deg) scale(1); transform: rotate(45deg) scale(1);&#125; .icon.checked &#123; //点击之后添加上checked类名即可 background-color: #26a2ff; border-color: #26a2ff;&#125; 12. 空对象（包括数组）无法直接判断是否为假值！可通过Object.keys(obj).length或者JSON.stringify(obj) === ‘{}’进行判断。 13. 当ref在标准标签中时代表获取该DOM元素，当ref在子组件时，则代表获取该组件，包括了该组件的id、class以及方法等。可以通过this.$refs.refName.method调用子组件的方法。但是当ref与v-for结合使用时，this.$refs.refName获取到的是一个数组，此时可通过制定数组元素调用指定子组件的方法。 14. nextTick方法主要是针对vue的虚拟DOM异步执行更新的方式创造的，虚拟DOM具有缓冲作用，不会时时更新，只有当一个函数执行完毕之后再统一进行DOM更新。因此，在数据更新之后使用nextTick回调函数可以在DOM统一更新之后调用执行。 15. 背景图全撑开样式设置： 12345.bg &#123; background: url('../../assets/img/zbl_ceshibg.png') no-repeat; background-size: 100% 100%; height: 4.7rem;&#125; 16. input元素的focus、blur事件无法进行代理执行，只能在目标元素上进行响应。(委托代理无法实现) 17. 小程序中bindtap与catchtap两种点击事件的区别:bindtap事件发生过程通过捕获阶段进入到目标阶段获取目标target元素，之后执行从里往外冒泡，从而有机会在冒泡阶段执行到父节点绑定的事件，绑定事件的元素可通过currentTarget获得。catchtap事件发生过程只经历了捕获阶段到目标阶段target元素，阻止了冒泡行为。 18. 小程序中navigateTo方法缓存当前页面（不关闭）并打开新的页面，redirectTo方法关闭当前页面并打开新的页面，navigateBack方法直接跳转回未关闭的页面，可多级进行跳转，但该方法没办法进行路由传参。 19. 字符串的slice、substring、substr三个方法区别：slice(a,b)截取两个参数从小到大之间的字段，可传负数(负数加上字符串长度即为截取的索引，也可以直接从尾倒数回来，-1代表最后一位，以此类推)；substring(a,b)截取两个参数从小到大之间的字段，但传入的负数将被强行转换为0；substr(a,n)第一位参数表示截取开始的索引(可为负数)，第二位参数表示截取的字符串长度(负数将转换为0)。 1234567var stringValue = “hello world”;alert(stringValue.slice(-3)); //"rld"alert(stringValue.substring(-3)); //"hello world"alert(stringValue.substr(-3)); //"rld"alert(stringValue.slice(3,-4)); //"lo w"alert(stringValue.substring(3,-4)); //"hel"alert(stringValue.substr(3,-4)); //""(空字符串) 20. 区别：双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了,多了1个div，少用大致4个css属性（圣杯布局中间div的padding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4），双飞翼由此相对简洁一些。现在主要以flex进行布局。 21. 项目可优化部分有：下拉刷新、页面切换过渡效果、禁用微信浏览器访问页面存在下拉漏出黑色区域、多请求并发优化问题。 22. vue组件传值的几种方式：1.props down event up的父子组件通信2.路由传参(关键参数需要加密)3.vuex状态管理4.event bus注册全局事件5.sessionStorage存储 23. 产生随机长度字符串：12345678910111213141516171819202122232425// 第一种方式let randomStr = (length) =&gt; &#123; length = parseInt(length, 10) || 6 if (length &lt;= 6) &#123; return Math.random().toString(36).slice(2, length + 2) &#125; else &#123; let str = '' for (let i = 0; i &lt; Math.ceil(length / 6); i++) &#123; str += Math.random().toString(36).slice(2, 8) &#125; return str.slice(0, length) &#125; &#125; let len = Math.random() * 100 randomStr(len)// 第二种常规方式let randomStr2 = (len) =&gt; &#123; len = parseInt(len, 10) || 32 let chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678' /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ let str = '' for (i = 0; i &lt; len; i++) &#123; str += chars[Math.floor(Math.random() * chars.length]) &#125; return str&#125; 24. 清空一个数组的方式：12341、let one = [1,3,5]one.length = 0 //one =&gt; []2、let two = [2,4,6]two.splice(0) //two =&gt; []，利用了splice会改变原数组的方法，splice方法返回被删除元素组成的一个新数组 25. ES6中的let关键字本质上是对闭包的一个封装，从而影响其作用域。 26. 产生当前毫秒的时间戳的方法：new Date().getTime() === new Date().valueOf() //true 27. babel-runtime: es语法做转义； fastclick: 解决移动端点击300毫秒延时问题； babel-polyfill：主要针对es6的promise等补丁。 28. 父元素清除浮动坍塌12345678910111213 .clearfix:after &#123; content: ' '; display: block; height: 0; visibility: hidden; clear: both;&#125;=&gt;等价于 (BFC的原理).clearfix:after &#123; content: ' '; display: table; clear: both;&#125; 29. 多个li元素设置为inline-block之后，元素之间会存在几个px的间隙，通过在其ul元素上设置font-size: 0可以解决这个问题。 30. box-sizing: border-box的作用是将padding的值往设定好的元素高度内部挤，而不会往外延伸影响到元素整体高度的计算。 31. rem不兼容IE8及以下浏览器，flex不兼容IE9及以下浏览器。 32. 一个原型及原型链的栗子1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;原型链栗子&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="aaa"&gt;aaa&lt;/div&gt; &lt;div id='bbb'&gt;bbb&lt;/div&gt;&lt;/body&gt;&lt;script&gt; function $(classOrId) &#123; this.Ele = document.querySelector(classOrId) &#125; $.prototype.html = function(value) &#123; let ele = this.Ele if (!value) &#123; return ele.innerHTML &#125; else &#123; ele.innerHTML = value return this &#125; &#125; $.prototype.on = function(type, fn) &#123; let ele = this.Ele ele.addEventListener(type, fn) return this &#125; let elementa = new $('.aaa') elementa.on('click', () =&gt; &#123; console.log(this) //window &#125;) let elementb = new $('#bbb') elementb.on('mouseover', function() &#123; console.log('mouseover') &#125;).html('666')&lt;/script&gt;&lt;/html&gt; 33. https 34. vue路由跳转间的登录态判断 35. 预设式的响应式设置1234&lt;img src='img/480.png' srcset='img/480.png 480w, img/800.png 800w, img/1200.png, 1200w' size='(min-width:800px) calc(100vw - 2rem), 100vw'/&gt; //size默认值是不带查询条件的100vw，如果存在多个查询条件，可以通过逗号隔开 //浏览器从小尺寸变为大尺寸时会依据带宽、dpi值、像素比等综合因素自动切换图片大小，当浏览器从大尺寸变回小尺寸时图片将仍然保留大尺寸时的图片，因为此时该图片已缓存。12345678//多组条件响应图片，目前IE浏览器均不支持，高级浏览器才支持，可通过引入picturefill第三方补丁库进行打补支持。&lt;picture&gt; &lt;source media='(max-width: 800px)' srcset='img/a.png 600w' /&gt; &lt;source srcset='img/a-default.png 1200w' /&gt; &lt;source type='image/svg+xml' srcset='logo.svg 480w' /&gt; &lt;source type='image/webp' srcset='logo.webp 480w, logo-m.webp 800w, logo-l.webp 1200w' /&gt; &lt;img src='img/a.png' /&gt; //默认显示&lt;/picture&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的2种跨域请求方式]]></title>
    <url>%2F2017%2F06%2F10%2Fjsonp%E7%9A%842%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JSON和JSONP虽然只有一个字母的差别，但其实两者根本不是一回事：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。本文主要介绍下常用的jsonp跨域请求方式传输JSON格式数据以及jsonp与ajax的区别。 先解释下JSONP的由来： 1、因为浏览器的安全机制，只要请求资源与当前页面地址的域名或端口号不一致，那么ajax发送的数据请求皆会存在跨域无权限访问的问题，不管是静态页面、动态网页、web服务资源，都访问不了。 2、我们都知道凡带有”src”属性的标签都拥有跨域的能力，常见的标签如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;，加上Web页面上只要能获取js脚本文件即可调用或执行，不受跨域影响。 3、于是，推演出了一种称作JSONP的非正式传输协议，该协议的要点就是允许用户传递一个callback参数给服务端，然后服务端通过该callback参数作为函数名包装JSON数据，然后返回数据给到客户端，客户端提供一个自定义回调函数进行数据处理。 4、这种获取远程数据的方式看起来很像ajax，但ajax和jsonp两者本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签调用服务器提供的js脚本。ajax与jsonp的区别并不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。所以两者最大的区别还是在于获取服务器数据的行为方式上的不一样。 基于以上几点，本文介绍jsonp跨域发送数据请求常用的2种方法，虽然写法上不同，但实质上都是一致的，只是jq在ajax中对其进行了封装，但注意ajax与jsonp没有实质关系。 本文以百度搜索提供的一个支持JSONP请求的API接口进行发送请求，地址为：http://suggestion.baidu.com/su?wd=#content#&amp;cb=callback (#content#为搜索关键词) 一、原生js实现12345678910111213141516171819// 定义一个数组，发送多次请求 let arr = ['苹果', 'apple', 'fruit', '我爱苹果'], headEle = document.querySelector('head'), resultArr = [] arr.forEach(val =&gt; &#123; let scriptEle = document.createElement('script') let url = `http://suggestion.baidu.com/su?wd=$&#123;val&#125;&amp;cb=callback` // ES6的反引号写法 // 注意！上面的`cb`为百度定义的格式，不可以更改！！！ scriptEle.src = encodeURI(url) // encodeURI为js原生的中文url编码方法 headEle.appendChild(scriptEle) headEle.removeChild(headEle.querySelector('script')) // 先添加再移除 &#125;) function callback(data) &#123; // 回调函数调用接受响应数据 resultArr.push(data.s) // 's'属性是返回json数据中的属性 if (resultArr.length === arr.length) console.log(resultArr) // 输出包含4个数组元素的一个数组 &#125; 二、使用JQuery封装实现12345678910111213141516171819202122&lt;script src='http://code.jquery.com/jquery-latest.js'&gt;&lt;/script&gt; let arr = ['苹果', 'apple', 'fruit', '我爱苹果'], resultArr = [] arr.forEach(val =&gt; &#123; let url = `http://suggestion.baidu.com/su?wd=$&#123;val&#125;` $.ajax(&#123; type: 'get', url: encodeURI(url), // 指定此请求为jsonp请求，响应返回的数据格式即为jsonp格式 dataType: 'jsonp', jsonp: 'cb', success: function(data) &#123; resultArr.push(data.s) if (resultArr.length === arr.length) console.log(resultArr) &#125;, error: function(err) &#123; console.log(err) &#125; &#125;) &#125;) 注意点： json格式的数据结构长这样: {‘a’:’apple’,’b’:’banana’}，而jsonp格式的数据结构长这样: callback({‘a’:’apple’,’b’:’banana’})，由上面的定义知道，发送jsonp请求需要服务器返回一个callback参数作为函数名包装的JSON数据，所以如果服务器没有设定允许返回jsonp格式的数据，那么我们是无法完成jsonp跨域请求的，哪怕强制在url地址上加了”&amp;callback=handleCallbackFunction”,服务器返回的数据还是json数据，无法被客户端定义的回调函数获取，下面这个url地址就无法进行jsonp请求，有兴趣的可以将上面代码中的url换成这个试一试。替换url：1`http://api.tmkoo.com/search.php?keyword=$&#123;val&#125;&amp;apiKey=4399320012393234&amp;apiPassword=331nd3342d&amp;pageSize=30&amp;pageNo=1` 解决方案由后端发起http跨域请求，以nodejs为例，引入request模块，关键代码如下：1234567891011121314const express = require('express')const request = require('request')const app = express()let url = `http://api.tmkoo.com/search.php?keyword=$&#123;val&#125;&amp;apiKey=4399320012393234&amp;apiPassword=331nd3342d&amp;pageSize=30&amp;pageNo=1`request(encodeURI(url), (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body) //body中即可获得返回的json数据 &#125;&#125;)app.listen(8888, () =&gt; &#123; console.log('started...')&#125;)]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回到原点]]></title>
    <url>%2F2017%2F06%2F07%2F%E5%9B%9E%E5%88%B0%E5%8E%9F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[今天全国高考，回想2011年我的高考作文命题——回到原点，思绪有些复杂。今天我再一次高考，交上这篇800字文章，谨记过往，不忘原点，从心出发。 2011年6月7号早上9点01分，我拿到语文卷的命题作文——回到原点。跟大多数人一样，夹杂着紧张与惊喜，我当时脑子里的第一反应就是诸如“最初的梦想”，“不忘初心，砥砺前行”，“又回到最初的起点，记忆中你青涩的脸…”这样的关键词，其实这跟“回到原点”还是有些差别。 回到原点，其实讲的是田径场上一圈下来由起点回到原点的意思，放远点讲就是一个由土生向尘亡的轮回归属。古希腊赫拉克利特说，“一双脚永远不可能踏进同一条河流”，因为时间会韶逝，空间会易转，你永远也找不到两片同样的树叶。花开复花落，潮涨既潮退，云卷亦云舒。一个圆规画圆，两只脚由始再到原，转到的那个原点永远不会是同一个点，那我们为什么还要回到原点？ 回想一下，我们是否经常耳荡“如果让我再年轻十年”,“如果再给我一个大学”，“如果再给我一个机会”…种种如果，皆为原点，皆为重塑。我们常说梦想还是要有的，万一实现了，可梦想何来？真的是某天白日做梦想想就来，还是跋山涉水之后醍醐灌顶，东风自然来？没错，回到原点，就是要重新审视最初的梦想与现实历经之间的矛盾，也是重整旗鼓韬光养晦的契约。一次踏进冰河并不可怕，但如果两次三次踏进“同一条”河流，那么这个原点将越描越黑。 回到原点，其实就是在面对各种洗礼之后重新面临选择。生命之流汩汩，总有九十九式的桥需要去回眸，有青葱绿石的，有古典端庄的，有陆离斑驳的…走一遭，到东吴，择一桥，回西蜀。不管择与否，主动的随流的，浪淘尽之后，回归原点，还得再次选择。当然，只要有选择总是有机会成本的，成本公式就是πr²。走的时间越远路子越长，圆饼就越大，当再次回到圆点面临选择时，能易志甚至舍弃的代价就越高。所以生命洪流，需要时时省思脚下船，船到桥头虽直，可怕一条暗道直流到黑，适时需要登桥眺望，择善流行。 2017年2月6号，依昔记得是大年初八，一个背包的独行客，走到起点般的原点。昨日6月6号，刚好满四月。四个月的朝七晚九，四个月的独往孤来，四个月的点滴获取，四个月的日行一小时，满满当当。如今重赴原点，从心出发。 好了，匆匆一瞥，已然神游，开卷啦，原点常在，期待大家都能给各自生活交上一份满意的答卷。 林龙儿2017/06/07•广州]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2 开发"饿了么"项目的一些总结]]></title>
    <url>%2F2017%2F06%2F01%2Fvue2%E5%BC%80%E5%8F%91%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近一段时间探索着运用vue2开发一个饿了么的开源项目，纵观网上大部分资料只介绍了前端单页面的开发过程，并没有涉及到后端及数据库部分。本项目以前端SPA的开发为主，并针对前端到后端服务器的逻辑层进行编写。css部分直接引用了网上开源的代码，未重点关注。本文记录开发过程中踩过的坑以及一些注意点，供大家参考。 本项目开发过程中使用到的技术栈 vue-cli + vue-router + axios + vue2 + vuex + Express + MongoDB + mongoose + webpack2 + ES6 使用vue-cli脚手架快速搭建项目结构通过vue自带的vue-cli工具，可以快速的创建一个项目结构，我们只需在src中进行源码编写即可，其他大部分工作cli工具都已经帮我们生成。本项目的目录结构说明如下： 使用vue-router实现SPAvue-router的基本思想是在主页面中引入标签，然后定义路由，通过&lt;router-link&gt;&lt;/router-link&gt;把router挂在到app上，并把各个子页面渲染到&lt;router-view&gt;&lt;/router-view&gt;里面。通过vue-router创建一个实例对象并进行路径配置，即可轻易实现前端路由的切换，本项目主要实现在一个单页面上进行3个子页面间的切换动作，图示红色区域即为典型的单页面路由功能。 使用axios进行后台数据请求运用axios插件的优势在于支持ES6的Promise特性，通过.then() .catch()的方式很方便的对响应结果进行处理。在引入axios的时候需要注意一点，要么可以直接将axios挂载到全局Vue的prototype原型链上，这样所有的vue实例均可直接通过this.$axios.get()…调用，要么通过import方法在需要使用axios的地方引入，然后直接axios.get()…调用，但注意这里并不需要加上vue.use(axios)，因为axios就是一个纯粹的第三方插件，引入之后即可直接使用。axios的使用方法如下：123456this.$axios.get('/api/seller').then(res =&gt; &#123; //this.$axios的用法前提是将axios挂载到Vue的原型上，否则需要使用import引入axios的方法 this.seller = JSON.parse(JSON.stringify(res.data)) &#125;).catch(err =&gt; &#123; console.log(err) &#125;) 另外还需要注意一点，这里因为涉及到前后端服务器不同端口号的跨域请求问题，需要在vue-cli生成的目录中找到config文件夹下的index.js文件，在proxyTable属性中添加上如下代码，从而在本地重新启动一个新的服务器进行代理。12345678910proxyTable: &#123; //配置跨域请求参数 '/api': &#123; target: 'http://localhost:3000/', //本地'localhost:8080/api'的地址将被代理为'http://localhost:3000/' changeOrigin: true, pathRewrite: &#123; '/api': '' // '/api'将被替换为''(空) &#125; &#125; &#125; 基于vue2搭建前端架构Vue.set()开发商品数量模块的时候，使用了一个Vue.set()或者vm.$set()方法，该方法可响应式的给对象添加一个属性，并触发view视图更新。如果只是简单的使用 Object.assign() 或 extend() 添加属性,无法响应视图更新。在该模块中通过给一个商品动态附上一个数量属性还有一个明显的优势，就是该属性在任意的父组件或子组件间进行值的更改之后，其他的引用组件都会响应更改，”一动而牵全身”，因为他们引用的是同一片内存地址。本项目中共有3个地方引用到该属性，分别是商品显示页、商品详情页、购物车详情页。12345678addCart(event) &#123; if (!this.food.count) &#123; Vue.set(this.food, 'count', 1) //强制赋予food一个新的属性，并监听该数据 &#125; else &#123; this.food.count++ &#125;&#125; better-scroll项目中要实现移动端滑动，所以引入了一个”better-scroll”插件，该插件虽然简单的几个配置之后即可达到滑动效果，但是它的创建时机相当重要，因为它的创建需要依据滚动元素的css布局进行计算，所以如果在数据尚未取得并渲染之后创建，最终将得不到滑动效果。基于这一点，推荐结合vue提供的nextTick()方法(nextTick是vue中一个类似setTimeout的方法)，在下一次DOM更新之后进行计算，并且在每次数据更新(DOM结构树发生变动)之后调用refresh()方法重计算，必要时可通过watch属性监听变动数据实时refresh，否则将会出现滚动误差。该插件的引入一般在mounted钩子函数中引入,但是如果是通过axios发送请求，因为请求是异步的，需要等待服务器响应，所以可能会出现数据尚未回来，但mounted已挂载的情况，所以这时候该插件的引入就需要放在axios的回调函数中去执行了。123456789mounted() &#123; this.$nextTick(() =&gt; &#123; //nextTick方法相当于setTimeout定时器，用于处理异步回调问题 this.scroll = new BScroll(this.$refs.ratings, &#123; click: true, bounceTime: 300 &#125;) &#125;)&#125; 子组件的多重引用在设置子组件的时候，需要给子组件绑定多少个变量，多少个方法，这是个宏观问题。可能这个地方引用需要2个变量，另一个地方引用该组件需要4个变量，同时2个地方的引用需要的方法也各不同，那这时候就要考虑该组件的可复用性，重新进行变量和方法设定，或者尽可能减少变量和方法数量的绑定，提高可复用性。这一点在我重写评价筛选方法的时候代码的冗长，难以复用性，就是个很大的坑。 vuex数据统一访问接口在项目中多个地方引用了这行数据classMap: [&#39;decrease&#39;, &#39;discount&#39;, &#39;special&#39;, &#39;invoice&#39;, &#39;guarantee&#39;]，会出现的很大问题是，如果项目中需要对该数据进行增删，那每一个引用的地方都要相应找出来并进行修改，当引用的数量多了之后，那就麻烦大了。好在vue中有一个vuex插件，有个state”中间仓库”概念，它负责保存关键的数据状态，所有的组件只可mapGetter到这个数据并在mutations中操作数据，不可能直接更改，这样如果需要改动数据，只要改动state中的数据，其他引用的组件将跟着发生改变。本项目中将该组数据单独放在state中，共有3个子组件引用了该数据，子组件可通过this.$store.state.classMap方式访问到该数据。注册store的方式如下：123456789import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; classMap: ['decrease', 'discount', 'special', 'invoice', 'guarantee'] &#125;&#125;) export与importES6中export与import 有4种常用的使用方式：1、export的时候将需要导出的变量用一个{}包装起来，然后在import的时候相对应用{}引入该变量；12345let exportVar = 'have a nice day!', fooexport &#123;exportVar,foo&#125; //导出,也可以通过as将foo名字改为bar再导出import &#123;exportVar,foo&#125; from '...' //导入console.log(exportVar) 2、这种方式是直接在export后面定义要导出的函数或变量；123export let foo = () =&gt; &#123;console.log("fnFoo")&#125;, bar = "stringBar" //导出import &#123;foo, bar&#125; from "..." //导入console.log(foo()) 3、这种导出方式不需要知道变量的名字，相当于匿名，直接将开发接口给export，如果一个js模块文件只有一个功能，可以使用export default默认导出，在引入之后可以将default变量名随意更改，这也是本项目中使用最多的一种方式；12export default &#123;&#125; //导出import someName from "..." //导入 4、整体导出导入，导出文件中有多个export；12345678export function getName() &#123; //导出 console.log('name')&#125;export function getAge()&#123; //导出 console.log('age')&#125;import * as someName form '....' //导入console.log(someName.getName()) 使用Express搭建后台服务器这里主要使用node.js中比较优秀的express框架快速搭建一个服务器，释放可访问端口号及暴露的文件路径，并且提供http访问接口，express还可以使用各种中间件对请求及相应前后的数据进行中间操作，可扩展性很强大。本项目以前端为主，express只是简单提供3个请求接口，并对接数据库返回请求资源。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const express = require('express')const path = require('path')const app = express()app.get('/seller', (req, res, next) =&gt; &#123; //多个回调 console.log('访问了seller数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].seller) &#125; &#125;)&#125;)app.get('/ratings', (req, res, next) =&gt; &#123; console.log('访问了ratings数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].ratings) &#125; &#125;)&#125;)app.get('/goods', (req, res, next) =&gt; &#123; console.log('访问了goods数据' + ' -- ' + new Date()) next()&#125;, (req, res) =&gt; &#123; MDL.find(&#123;&#125;, function(err, results) &#123; if (err) &#123; console.log(err) &#125; else &#123; res.json(results[0].goods) &#125; &#125;)&#125;)app.set('port', process.env.PORT || 3000)app.use(express.static(path.join(__dirname, '.'))) //托管静态资源app.listen(app.get('port'), () =&gt; &#123; console.log('Express server listening on port ' + app.get('port'))&#125;) 使用MongoDB数据库储存数据使用MongoDB数据库的原因是因为饿了么开源项目提供的数据为json数据类型，可以直接导入使用，而且MongoDB非SQL型数据库具有更加灵活的操作性。 使用mongoose操作数据库mongoose是一个针对MongoDB操作的第三方插件，该插件封装了很多原生的操作指令，使得通过mongoose的操作更加简洁高效。另外项目中还通过Robomongo这个可视化的数据库GUI进行数据导入，可省去在shell窗口中敲送指令并提供更良好的数据展示。数据库的创建关键代码如下： 123456789101112const mongoose = require('mongoose')mongoose.connect('mongodb://localhost:27017/elemeDB')const schema = mongoose.Schemaconst aModel = new schema(&#123; //定义数据类型 seller: Object, goods: Array, ratings: Array&#125;)const MDL = mongoose.model('elemes', aModel) //创建或连接到指定集合// 本项目只针对数据查询，未涉及insert、update、remove等操作 使用webpack2打包项目webpack主要是在项目完成开发之后，进行的一种代码打包动作，它可以将项目主页中使用到的链接、资源等进行加载注入并进行一定的编码操作。webpack2与webpack1略微不同，webpack2最主要的有以下4个属性： entry：指入口文件的配置项，它可以是一个数组，允许有多个入口点。 如果只有一个入口的话，可以直接使用双引号”./entry.js”；output：配置打包结果，path定义输出的文件夹，filename定义打包结果文件的名称；module：定义对模块的处理逻辑，可以用loaders定义一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。plugins：这个是放置各种第三方插件的属性，使用第三方插件可以完成更多loader不能完成的功能。 本项目在确认开发基本ok之后，通过npm run build，即可完成项目打包上线。 使用ES6新语法编写代码众所周知，ES6是以后的常态化书写趋势，所以在该项目中边学边用，最常用的大概就是解决回调金字塔的Promise属性、箭头函数、反引号、const/let、属性属性值同名简写、export/import等，具体使用方法就不细写了，ES6的主要作用还是起到代码规范化同时更简洁高效的达到以前需要冗长代码才能实现的效果。ES6新特性传送门 最终效果]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Vue</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5新特性--本地dataDaseStorage的运用]]></title>
    <url>%2F2017%2F05%2F24%2FH5%E6%96%B0%E7%89%B9%E6%80%A7--%E6%9C%AC%E5%9C%B0dataDaseStorage%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于HTML5中新增的”SQLite”数据库存储方式，网上的介绍资料比较少，这种存储方式突破往常cookie临时性及存储空间限制，可以将数据永久存储在本地，并且存储空间可扩展至5~10MB，本篇以一个通讯录存储demo进行演示，同时温习下MySQL的相关语法，以供参考。 完整代码及相关注释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;HTML5 dataDaseStorage&lt;/title&gt; &lt;link rel="stylesheet" href="./bootstrap.min.css"&gt; &lt;style&gt; .middle-box &#123; display: table; width: 450px; height: 300px; border: 1px solid lightskyblue; margin: 0 auto; &#125; .middle-inner &#123; display: table-cell; vertical-align: middle; text-align: center; &#125; #list &#123; text-align: center; &#125; .table.table-bordered &#123; width: 50%; margin: 0 auto; &#125; th, td &#123; border: 2px solid green !important; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="middle-box"&gt; &lt;div class="middle-inner"&gt; &lt;form class="form-inline"&gt; &lt;h3&gt;通讯录&lt;/h3&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="userName"&gt;姓名：&lt;/label&gt; &lt;input type="text" id="userName" name="userName" class="form-control text" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="mobilephone"&gt;手机：&lt;/label&gt; &lt;input type="text" id="mobilephone" name="mobilephone" class="form-control" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div class="form-group"&gt; &lt;label for="company"&gt;公司：&lt;/label&gt; &lt;input type="text" id="company" name="company" class="form-control" required/&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;input type="button" onclick="saveMsg()" value="新增记录" class="btn btn-default btn-info" style="width: 55%;" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;div id="list"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 加载完毕后取出数据 window.onload = function() &#123; loadAll(); &#125; // 创建或打开已有数据库API var db = openDatabase('contactdb', '', 'local database describe', 204800); // 4个参数含义： // databasename: 数据库名字； // version：数据库版本号，选填； // description：数据库描述； // size：给数据库分配的空间大小； //保存数据API function saveMsg() &#123; var userName = document.getElementById("userName").value; var mobilephone = document.getElementById("mobilephone").value; var company = document.getElementById("company").value; var timestamp = parseInt(new Date().getTime()/1000); if (userName &amp;&amp; mobilephone &amp;&amp; company) &#123; db.transaction(function(tx) &#123; //contact为 table name，4个问号分别由后一个参数值替代，后2个参数为回调函数 tx.executeSql('insert into contact values(?,?,?,?)', [userName, mobilephone, company, timestamp], onSuccess, onError); &#125;); &#125; else &#123; alert('请输入完整信息！') &#125; &#125; //删除数据API function deleteMsg(phone) &#123; if (confirm('确定要删除吗？')) &#123; db.transaction(function(tx) &#123; tx.executeSql('delete from contact where phone=?', [String(phone)], onSuccess, onError); &#125;); &#125; &#125; // 两个回调 function onSuccess() &#123; alert("操作成功"); document.getElementById("userName").value = ''; document.getElementById("mobilephone").value = ''; document.getElementById("company").value = ''; loadAll(); &#125; function onError(tx, error) &#123; alert("操作失败" + error.message); &#125; //读取本地sqlLite数据API function loadAll() &#123; var list = document.getElementById("list"); db.transaction(function(tx) &#123; //如果初始数据表不存在，则创建一个空的数据表 tx.executeSql('create table if not exists contact(name text,phone text,company text,createtime INTEGER)', []); tx.executeSql('select * from contact', [], function(tx, rs) &#123; // console.log(rs); if (rs.rows.length) &#123; var tableEle = document.createElement('table'); tableEle.classList.add('table'); tableEle.classList.add('table-bordered'); tableEle.innerHTML = "&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;手机&lt;/th&gt;&lt;th&gt;公司&lt;/th&gt;&lt;th&gt;添加时间&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;"; for (var i = 0; i &lt; rs.rows.length; i++) &#123; var row = rs.rows[i]; tableEle.innerHTML += "&lt;tr&gt;&lt;td&gt;" + (i + 1) + "&lt;/td&gt;&lt;td&gt;" + row.name + "&lt;/td&gt;&lt;td&gt;" + row.phone + "&lt;/td&gt;&lt;td&gt;" + row.company + "&lt;/td&gt;&lt;td&gt;" + TimeChange(row.createtime) + "&lt;/td&gt;&lt;td&gt;&lt;input type='button' value='删除' onclick='deleteMsg(" + row.phone + ")' class='btn btn-danger'/&gt;&lt;/td&gt;&lt;/tr&gt;"; &#125; list.innerHTML = ''; list.appendChild(tableEle); &#125; else &#123; list.innerHTML = "目前通讯录为空，请添加新成员吧"; &#125; &#125;); &#125;); &#125; //根据时间戳生成时间对象 function TimeChange(value) &#123; var d = new Date(value * 1000); return (d.getFullYear()) + "-" + (d.getMonth() + 1) + "-" + (d.getDate()) + " " + (d.getHours()) + ":" + (d.getMinutes()) + ":" + (d.getSeconds()); &#125;&lt;/script&gt;&lt;/html&gt; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-Flex 弹性响应式布局的栗子]]></title>
    <url>%2F2017%2F05%2F21%2FCSS3%20Flex%E5%BC%B9%E6%80%A7%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E6%A0%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[本栗子主要记录如何运用CSS3的flex新特性进行快速的响应式布局，以及区别于以往DIV+CSS繁琐的垂直居中定位方法，通过flex方法方便快捷的实现子元素的垂直居中。 主体body布局如下： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;body&gt; &lt;header&gt;I am header&lt;/header&gt; &lt;div id='main-body'&gt; &lt;nav&gt;&lt;h3&gt;nav&lt;/h3&gt;&lt;/nav&gt; &lt;article&gt;&lt;h3&gt;article&lt;/h3&gt;&lt;/article&gt; &lt;aside&gt;&lt;h3&gt;aside&lt;/h3&gt;&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;I am footer&lt;/footer&gt;&lt;/body&gt;&lt;/head&gt;&lt;/html&gt; CSS样式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768* &#123; margin: 0; padding: 0;&#125;body &#123; font: 24px Arial; min-width: 300px;&#125;/*头尾普通布局*/header, footer &#123; display: block; height: 60px; line-height: 60px; background: lightyellow; text-align: center;&#125;/*内容区使用flex弹性布局*/#main-body &#123; display: flex; display: -webkit-flex; flex-direction: row; -webkit-flex-direction: row; min-height: calc(100vh - 120px); /*保证sticky-footer, 即让footer永远沉底不会浮起来，配合display:flex 使用*/ background: lightgrey;&#125;#main-body&gt;nav &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 1 1 20%; -webkit-flex: 1 1 20%; align-items: center; justify-content: center; background: lightskyblue;&#125;/*3个值，第1个表示窗口拉伸时的该子元素的扩展倍数，第2个表示窗口缩小时的缩小倍数，第3个表示该子元素所占父元素的比例*/#main-body&gt;article &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 2 4 55%; -webkit-flex: 2 4 55%; align-items: center; justify-content: center; background: lightgreen;&#125;#main-body&gt;aside &#123; display: flex; /*为子元素h3居中而设*/ display: -webkit-flex; flex: 1 2 25%; -webkit-flex: 1 2 25%; align-items: center; justify-content: center; background: #CCCCFF;&#125;#main-body h3 &#123; padding: 5px 40px; border: 1px dashed #FFF;&#125;@media (max-width:768px) &#123; #main-body &#123; flex-direction: column; -webkit-flex-direction: column; &#125; #main-body&gt;article &#123; order: -1; -webkit-order: -1; &#125;&#125; 屏幕宽度大于768px时的效果：（高度保持不变） 屏幕宽度压缩小于等于768px的效果：（高度保持不变） 以下记录下几个设置要点： 1、设置display属性值为flex的元素即成为了父项，其内部包含的子元素即可使用flex属性进行弹性布局，子元素如若继续添加display: flex的属性，则该子元素也将成为其所包含的子元素的父项，以上栗子中设置子元素成为父项目的是让其包含的元素可以进行垂直居中设置。 2、以上两种效果的子元素项目的排序与html中默认的顺序相关，但可通过flex中的order属性进行切换，默认值为0，值设置的越小则更顺序靠前。 3、各个子元素的内容垂直居中效果是利用flex中justify-content 和 align-items两个属性进行调整，前者调整主轴方向上的对齐方式，后者调整交叉轴上的对齐方式，在父项上设置两个属性值均为”center”，则可以让包含的子元素垂直水平居中。 不使用flex属性的情况下实现元素垂直居中的代码，基本兼容所有浏览器： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; /*以下带*号的属性设置是为了兼容IE6、7*/ .middle-box &#123; display: table; /*关键设置*/ width: 300px; height: 200px; border: 1px solid #ff0000; margin: 0 auto; *position: relative; &#125; .middle-inner &#123; display: table-cell; /*关键设置*/ vertical-align: middle; /*关键设置*/ text-align: center; /*关键设置*/ *position: absolute; *top: 50%; *left: 50%; &#125; .middle-inner&gt;p &#123; *position: relative; *top: -50%; *left: -50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="middle-box"&gt; &lt;div class="middle-inner"&gt; &lt;p&gt; &lt;span&gt;Nice to meet YOU !&lt;/span&gt;&lt;/br&gt; &lt;span&gt;Have a nice day !&lt;/span&gt;&lt;/br&gt; &lt;span&gt;See YOU !&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果： 另外，今天学到一个实用的方法，可在不熟悉一个陌生函数的情况下，借助ES6中新增的Array.from方法，获知未知函数的参数个数及类型。顺利mark一下，代码： 1234[1,2,3].filter(function() &#123; console.log(Array.from(arguments)); &#125;)//result: [1, 0, Array(3)] [2, 1, Array(3)] [3, 2, Array(3)]]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DocumentFragment重构页面]]></title>
    <url>%2F2017%2F05%2F17%2FDocumentFragment%E9%87%8D%E6%9E%84%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Javascript里面有这样一个东西: DocumentFragment (中文翻译大概就叫”文档片段”)，很多前端攻城狮可以并不怎么常用或者了解它，它本身并不属于主DOM树的一部分，但它可以将一批子元素附加到自身，然后再将自身附加的所有子元素一次性添加到主DOM树中。这种方式不需要对一个真正的根节点进行操作，DocumentFragment附加子元素的所有操作都在浏览器内存中进行，不影响DOM树，因此将子元素插入到DocumentFragment对象中不会引起页面回流(reflow，即对元素位置和几何上的重新计算)。因此使用DocumentFragment重构页面能很大的优化性能，网上试验的结果显示比直接操作DOM快了70% … 下面举个简单的栗子： 以往的写法： 12345678910&lt;ul id='ul'&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt;const fruit = ['apple', 'cherry', 'banana']for (let i in fruit) &#123; let liEle = document.createElement('li') liEle.innerHTML = fruit[i] document.querySelector('#ul').appendChild(liEle)&#125;&lt;/script&gt; 运行结果： DocumentFragment的写法： 123456789101112&lt;ul id='ul'&gt;&lt;/ul&gt;&lt;script&gt;let docFragment = document.createDocumentFragment() //创建一个新的DocumentFragment对象const fruit = ['apple', 'cherry', 'banana']fruit.forEach(value =&gt; &#123; let liEle = document.createElement('li') liEle.innerHTML = value docFragment.appendChild(liEle)&#125;)document.querySelector('#ul').appendChild(docFragment) //一次性插入DOM树&lt;/script&gt; 第一种方法中每进行一次遍历，appendChild操作会向DOM树请求一次回流，注意是回流不是重绘(回流比重绘耗时更多)，因为append操作改变了ul元素之后的整体结构。第二种方法中DocumentFragment实际上像一个伪DOM父节点，在这个例子中可以把它当成虚拟的UL元素。这种方法代码量虽然稍微多了点，但只在最后进行一次appendChild操作改变DOM模型树，浏览器只进行一次性回流，因此能很好的优化加载性能。 Vue框架中就是大量运用了该方法，不直接针对DOM对象进行操作，而是将需要增删改的对象都先挂载在DocumentFragment这个虚拟的DOM对象上进行操作，最后完成数据处理之后再一次性提交给浏览器进行回流、重绘呈现新的页面。 关于页面的回流与重绘，简单的理解就是： 回流是指页面的重新布局，任何元素的规模尺寸、布局、显示隐藏等操作都会改变BOM树结构，因此每改动一次都需要进行一次重构。每个页面至少需要一次回流，就是在页面第一次加载的时候。 重绘是指当标签元素更新了一些不会影响到页面布局的属性时，浏览器进行的重新绘制。诸如的属性主要是外观风格这些，比如color、background等等。 详细的内容参考点这里]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Express 单页面切换与跨域请求实例]]></title>
    <url>%2F2017%2F05%2F15%2FVue-Express%20%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最近在学习Vue2.0单页面应用，基本想要达到的效果是前端单页面不刷新切换，同时利用Vue-resource插件实现ajax跨域请求数据的功能，本文主要记录下实践过程中觉得是个坑的地方。实现效果如下： 初始化项目// 全局安装 vue-cli $ npm install vue-cli --g // 创建一个基于 webpack 模板的新项目，项目名为`aVueTest` $ vue init webpack aVueTest // 安装package依赖 $ cd aVueTest $ npm install // 启动项目 $ npm run dev 初始化之后浏览器打开并出现Vue的界面，则初始化成功，进行下一步。 创建前端主页面比较简单，主要注意下router-link中不同的路径写法对应不同to的绑定方法，代码如下： 123456789101112131415161718192021222324&lt;template&gt; &lt;div id="app2"&gt; &lt;h1&gt;Have a nice day!&lt;/h1&gt; &lt;button @click="getOne()"&gt;getOne&lt;/button&gt; &lt;button @click="getZero()"&gt;getZero&lt;/button&gt; &lt;p&gt;返回的数据 :&#123;&#123; resResult &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;b&gt;result:&lt;/b&gt; &lt;router-view class='changestyle'&gt;&lt;/router-view&gt; &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to='/' tag="button"&gt;home&lt;/router-link&gt; &lt;!--路径为字符串时，to不需要v-bind绑定，tag属性设置渲染成什么标签--&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link :to='&#123;name: "foo"&#125;' tag="button"&gt;foo&lt;/router-link&gt; &lt;!--绑定一个对象--&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to='/bar' tag="button"&gt;bar&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;span class="icon"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 前端路由功能的实现其中演示只写了Home、Foo、Bar3个基本的路由功能，实现单页面不刷新的状态下进行组件切换，在浏览器中表现为域名后/#/routerPath，这也是与直接跳转刷新地址的一个区别。代码如下： 123456789101112131415161718192021222324252627282930313233import Vue from 'vue'import App from './App.vue'import VueRouter from 'vue-router'import VueResource from 'vue-resource'// import Home from './components/Home/home.vue'// import Foo from './components/Foo/foo.vue'import Bar from './components/Bar/bar.vue' //一次性引入，会影响加载效率const Home = resolve =&gt; require(['./components/Home/home.vue'],resolve) //懒加载引入，当路由指向该路径时再进行加载const Foo = resolve =&gt; require(['./components/Foo/foo.vue'],resolve) //懒加载Vue.config.productionTip = falseVue.use(VueRouter) //必写，告诉Vue以下要使用Router插件Vue.use(VueResource) //必写，告诉Vue以下要使用Resource插件const router = new VueRouter(&#123; routes: [ &#123;path: '/', name:'home', component: Home&#125;, &#123;path: '/foo', name:'foo', component: Foo&#125;, &#123;path: '/bar', name:'bar', component: Bar&#125; ]&#125;)/* eslint-disable no-new */new Vue(&#123; router: router, template: '&lt;Appoo&gt;&lt;/Appoo&gt;', //该template属性与components属性配合使用，该模板文件最终将绑定在#app内 components: &#123; Appoo: App &#125;&#125;).$mount('#app')router.push('/bar') //初始加载时默认选中的地址 Vue-resource发送跨域请求ajax的跨域请求一般都是通过在服务器端设置头部信息接受跨域请求，而Vue-resource的跨域请求方式不同，是通过在本地虚拟一个代理服务器，然后再通过这个代理服务器向目标服务器发送请求信息，之后再原路返回响应信息，因此需要在Vue的config文件夹中对index.js文件中进行代理服务器配置，配置如下： 123456789proxyTable: &#123; //配置跨域请求参数 '/api': &#123; target: 'http://localhost:10086/', //本地'localhost:8080/api'的地址将被代理为'http://localhost:10086/' changeOrigin: true, pathRewrite: &#123; '/api': '' // '/api'将被替换为''(空) &#125; &#125; &#125; 配置完之后，现在回到App.vue文件中，敲写Vue-resource的代码，注意其他的路由组件只要需要进行后台请求，都可以在Vue实例中利用Vue-resource，以下只在App.vue中实现从后端请求返回一个&quot;0&quot;和&quot;1&quot;的数据。代码如下： 12345678910111213141516171819202122232425262728export default &#123; data() &#123; return &#123; //data数据需要用一个函数包装 resResult: '', sendUrl: '/api/getOne', //这里的'/api'在代理服务之后会被rewrite为'' params: &#123;code: '007'&#125; &#125; &#125;, methods: &#123; getOne() &#123; let vm = this //这里的vm===this，申明vm的作用是为了减少后面this对原型链多层查找 vm.$http.post(vm.sendUrl, vm.params).then((res) =&gt; &#123; //这里就是Vue-resource的写法了，使用了ES6 promise的语法 console.log(res.body) vm.resResult = res.body &#125;). catch((err) =&gt; &#123; //捕获错误 console.log(err) &#125;) &#125;, getZero() &#123; this.sendUrl = '/api/getZero' this.params = &#123;code: '008'&#125; this.getOne() this.sendUrl = '/api/getOne' this.params = &#123;code: '007'&#125; &#125; &#125; &#125; 后台服务器的启动基于Node.js的Express框架，简单编写2个路由接口供前端请求，代码如下： 1234567891011121314151617181920212223const express = require('express')const app = express()const path = require('path')const bodyParser = require('body-parser')app.use(bodyParser.json()) //request.body的解析middlewareapp.use(bodyParser.urlencoded(&#123;extended: true&#125;))let routerArray = ["/getZero",'/getOne'] //接受所有的路由apiapp.post(routerArray,(req,res)=&gt; &#123; if (req.body.code == '007') &#123; res.end('1') &#125; else if(req.body.code == '008') &#123; res.end('0') &#125; else &#123; res.end('Not allowed...') &#125;&#125;)app.use(express.static(path.join(__dirname,'.')))app.listen(10086,() =&gt; console.log('started...')) //启动10086端口与前端Vue启动的8080就是通过proxyTable实现互通的 项目文件结构树如下：]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现百度搜索的跨域请求]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[今天在写ajax的时候查了个资料，了解到HTML标签中script标签的src属性是可以进行跨域请求的，而在ajax请求中，默认情况下，浏览器不允许其访问跨域访问资源，只要源地址与请求的域名、端口号不同，则请求失败，当然通过在服务端设置头文件请求等方式也可实现跨域请求(如设置&quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;)。但对于一些特殊的跨域请求可以变相通过script标签去获得，比如本栗子通过调用百度的搜索功能接口，实现百度首页中的搜索联想功能。 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JS跨域搜索&lt;/title&gt; &lt;style&gt; * &#123; margin: 0px; padding: 0px; &#125; img &#123; width: 270px; height: 129px; /*display: block; margin: 0 auto;*/ &#125; .container &#123; width: 100%; text-align: center; &#125; .search &#123; margin-top: 30px; height: 38px; overflow: hidden; &#125; #inputID &#123; width: 540px; height: 36px; border: 1px solid #3385ff; border-right: none; vertical-align: top; text-indent: 6px; &#125; #inputBtn &#123; width: 100px; height: 38px; border: none; background: #3385ff; color: white; cursor: pointer; font-size: 15px; &#125; .content &#123; width: 640px; margin: 0 auto; border: 1px solid lightgrey; display: none; &#125; ul &#123; list-style: none; text-align: left; &#125; li &#123; margin-left: 3px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;img src="bd_logo.png" alt="百度logo"&gt; &lt;div class="search"&gt; &lt;input type="text" id="inputID"/&gt;&lt;input type="button" value="百度一下" id="inputBtn" onclick="location.href = 'http://www.baidu.com/';"&gt; &lt;/div&gt; &lt;ul class="content"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var searchSuggestion = "http://suggestion.baidu.com/su?wd=#content#&amp;cb=callback"; var headEle = document.getElementsByTagName('head')[0]; document.querySelector("#inputID").addEventListener('keyup', function(e) &#123; var scriptMark = document.getElementsByClassName('JSONP')[0]; if (e.keyCode == "13") &#123; //监听enter事件 location.href = 'http://www.baidu.com/'; &#125; else &#123; if (scriptMark) &#123; headEle.removeChild(scriptMark); &#125; var scriptEle = document.createElement('script'); scriptEle.classList.add('JSONP'); scriptEle.src = searchSuggestion.replace("#content#", document.querySelector("#inputID").value); headEle.appendChild(scriptEle); &#125; &#125;) function callback(data) &#123; document.querySelector(".content").innerHTML = ""; if (data['s'].length) &#123; for (let i in data["s"]) &#123; document.querySelector(".content").style.display = "inline-block"; document.querySelector(".content").innerHTML += "&lt;li onclick=handleClk(this)&gt;" + data["s"][i] + "&lt;/li&gt;"; &#125; &#125; else &#123; //如果输入的关键词不存在联想，则将ul框隐藏 document.querySelector(".content").style.display = "none"; &#125; &#125; function handleClk(e) &#123; //处理选中词条 document.querySelector("#inputID").value = e.innerHTML; document.querySelector(".content").style.display = "none"; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; end]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组与对象的深复制与浅复制]]></title>
    <url>%2F2017%2F05%2F09%2FJS%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[今天记录一下Javascript语言中数组与对象两种数据结构的深复制与浅复制方法，温故知新常乐也。 对象的浅复制方法有：浅复制, 复制的是该对象的内存地址，任意一个数据变动会导致另一个也变。1obj = &#123;x:1,y:3&#125;; 方法1：1var obj2 = obj; 方法2：1var obj2 = Object.create(obj); //浅复制 对象的深复制方法有：方法1：1var obj2 = JSON.parse(JSON.stringfy(obj)); //深复制，复制的只是数据 方法2： 数组的浅复制与对象类似，这里只写数组深复制的几种方法：注意字符串、数字每次赋值之后都会将一个新的内存地址指向给到新变量。 1var arr = [1,3,5]; 方法1：1var arr2 = arr.slice(); 方法2：1var arr2 = arr.concat(); 方法3：1var arr2 = arr.filter(()=&gt;&#123;return true&#125;); 方法4：1var arr2 = JSON.parse(JSON.stringfy(arr)); 总结： 基本的数据类型都属于深复制，包括数字、字符串、布尔值等，数组与对象不属于基本数据类型，直接赋值的方式属于内存地址（即指针）的赋值，所以实际指向的值会动态变化。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾几道JS基础算法题]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%9B%9E%E9%A1%BE%E5%87%A0%E9%81%93JS%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[士别三日当刮目相看，题隔三月也有了些许新意。最近静下心来，回头去重新看看以前在freeCodeCamp上做过的JS基础算法题，结合最近了解的ES6一些新特性，对同样的题目可能会有不一样的想法了，所以选了几题梳理并记录一下，如果有更好的解题思路或者建议欢迎指教呀。 给定N个字符串,找出其中重复的字符串和它重复的次数主要有两种思路： 简单粗暴的使用2个 for 循环 正则表达式match方法 第1种方法： 1234567891011121314151617181920212223function abc(str) &#123; var obj = &#123;&#125;, flag = 0, resultStr = ''; for (let i = 0 ;i &lt;str.length; i++) &#123; if (str[i] in obj) &#123; obj[str[i]] += 1; //注意此处必须使用[]形式赋值！！！ flag = 1; &#125; else &#123; obj[str[i]] = 1; &#125; &#125; if (flag == 0) &#123; console.log("字符串不存在重复元素！"); //判断不存在重复元素 &#125; else &#123; var max = Math.max.apply(null,Object.values(obj)); for (let i in obj) &#123; if (obj[i] == max) &#123; resultStr += i + ","; &#125; &#125; console.log("结果为：" + resultStr + "出现的次数"+ max); &#125; &#125;abc("广东省广州市广州大学城广东工业大学") 第2种方法： 1234567891011121314151617function abc(str) &#123; var n = 0, newChar; for (var i=0; i&lt;str.length; i++) &#123; var regExp = new RegExp(str.charAt(i),"g"); //注意此处如果匹配的正则表达式是变量值，则必须通过new RegExp构造函数来创建一个正则实例 var arr = str.match(regExp); if (arr.length&gt;n) &#123; //match方法获得匹配到的值并组成一个数组 n = arr.length; newChar = str.charAt(i); &#125; &#125; return newChar + "出现的次数："+ n;&#125;abc("广东省广州市广州大学城广东工业大学")//栗子：//input: "广东省广州市广州大学城广东工业大学".match(/广/g);//output: ["广", "广", "广", "广"] 重复输出一个给定的字符串主要有三种思路： 使用 for 循环 使用递归 使用ES6 repeat() 第1种使用for循环最常规的方法： 12345678function repeatStringNumTimes(string, times) &#123; var repeatedString = ""; for(var i = 0 ; i &lt; times ; i++) &#123; repeatedString += string; &#125; return repeatedString;&#125;repeatStringNumTimes("abc", 3) 第2种通过条件判断和递归的方法：123456function repeatStringNumTimes(string, times) &#123; if(times &lt; 0) return ""; if(times == 1) return string; else &#123; return string + repeatStringNumTimes(string, times - 1); &#125;&#125;repeatStringNumTimes("abc", 3); 第3种使用ES6 repeat() 方法：ES6新特性虽然带来很大的使用便利性，但要多少理解一些底层的原理.1234function repeatStringNumTimes(string, times) &#123; return times &gt; 0 ? string.repeat(times) : ""; //三目运算&#125;repeatStringNumTimes("abc", 3); 数组去重提供以下6种思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var filterArr = [1,2,5,undefined,2,'2',4]//method-1function arrFilter(arr, resArr = []) &#123; for (var i = 0; arr[i]; i++) &#123; if(resArr.indexOf(arr[i]) === -1) resArr.push(arr[i]) &#125; return resArr&#125;arrFilter(filterArr)//method-2,原理与上面类似resArr = filterArr.filter((value, index, arr) =&gt; arr.indexOf(value) === index)//method-3resArr = [...new Set(filterArr)]//method-4function arrFilter(arr, resArr = [], i = 0) &#123; while (arr[i]) &#123; if(arr.indexOf(arr[i], i + 1) === -1) resArr.push(arr[i]) i++ &#125; return resArr&#125;arrFilter(filterArr)//method-5function arrFilter(arr) &#123; return arr.reduce((prev, next) =&gt; &#123; if(prev.indexOf(next) === -1) prev.push(next) return prev &#125;, [])&#125;//method-6function arrFilter(arr) &#123; var newArr = [arr[0]] arr.sort() //聚合 for(var i = 1, len = arr.length; i &lt; len; i++) &#123; if(arr[i] !== arr[i - 1])&#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让博客加载速度快一些]]></title>
    <url>%2F2017%2F05%2F05%2F%E8%AE%A9%E5%8D%9A%E5%AE%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%BF%AB%E4%B8%80%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[每每打开自己的博客时，发现加载速度真的要好久好久，体验感实在有点差，最近实在看不下去了，想着到底是啥原因导致的，有什么办法可以提高那么一点点的加载速度也行。网上查看了一些资料，知道GitHub的服务器是在美国GitHub公司，我又刚好是把代码托管在GitHub上，所以每次访问自己的GitHub Pages都需要爬山涉水往美国所在地的服务器取数据啊，加上访问的带宽也很一般，加载缓慢也在所难免了，这真是个悲伤的故事 … 不过还好，国内也有一个“高仿”GitHub的代管仓库Coding码市，Coding最近也提供了免费的Coding Pages以及自定义域名。所以我们的想法是通过将代码托管在两个仓库上，然后当输入同一个域名时，DNS可以通过解析IP让国外的IP地址访问到GitHub上的Pages，让国内的IP地址访问国内的Coding服务器上的托管Pages，这样不仅国内访客访问速度可以快一些，还能实现国内外分流，大概有了这个简单的想法，于是以下结合网上一些资料进行了一番尝试。 第一步注册创建一个Coding账号，新建一个repo仓库，基本与GitHub类似，不同的一点就是Coding上可以免费创建私有仓库。创建完成之后进入该仓库的代码菜单中，选中Pages服务，在该页面中分别设置以下几个参数： 第二步完成Coding的配置之后，进行DNS解析，因为我用的是万网的域名，万网自带DNS云解析，所以这里演示的是万网的域名解析配置，但是都大同小异，配置如下： 第三步完成以上配置后，接下来就是让Hexo每次deploy代码的时候往GitHub和Coding仓库都push一份，这就需要在Hexo的_config.yml 配置文件中修改deploy路径，具体如下： 12345deploy: ##发布的仓库地址 type: git repo: github: https://github.com/binglinzhang/binglinzhang.github.io.git,master coding: https://git.coding.net/zhangbinglin/myBlog.git,master 配置完之后以后每次hexo generate和hexo deploy都会往这两个仓库一起push，中间可能需要输入账号密码，可通过在电脑跟仓库上添加公钥，之后在本机电脑push就不需要再输入密码了。 最后以上所有配置完成之后，在浏览器再次输入域名访问，发现国内IP加载速度确实快了一点。在cmd中ping一下域名发现IP地址有2个，一个显示是美国一个是香港，而之前域名只配置GitHub仓库的时候，每次ping出来的IP地址都在美国，这可能也是用Coding Pages访问比较快一些的原因吧。当然网页加载速度慢还跟其他很多因素相关，比如跟外部资源加载，音乐图片链接等息息相关，这就涉及到前端性能优化的大范畴了。以上只从服务器距离写点自己个人的愚见，如果有不对的地方还请指正，感激感激。。。]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恰同学少年，谁主沉浮]]></title>
    <url>%2F2017%2F05%2F04%2F%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4%EF%BC%8C%E8%B0%81%E4%B8%BB%E6%B2%89%E6%B5%AE%2F</url>
    <content type="text"><![CDATA[红日初升，其道大光；河出伏流，一泻汪洋；潜龙腾渊，鳞爪飞扬；乳虎啸谷，百兽震惶；鹰隼试翼，风尘翕张；奇花初胎，矞矞皇皇；干将发硎，有作其芒；天戴其苍，地履其黄；纵有千古，横有八荒，前途似海，来日方长。美哉，我少年中国，与天不老；壮哉，我中国少年，与国无疆！]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5 webWorkers的异步多线程]]></title>
    <url>%2F2017%2F05%2F03%2FH5%20webWorkers%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[假如有这样一个需求：在浏览器页面上输出1~99999之间的所有质数，要求有较好的用户体验，且不借助setTimeout()，setInterval()或调用XMLHttpRequest，该如何设计？ 第一种方法 完整代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1~99999之间的质数有：&lt;p id="result"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; for (let i = 2; i&lt;= 99999; i++) &#123; //求质数方法 let j = 2; while (i%j != 0) &#123; j++ ; &#125; if ( j == i ) &#123; document.getElementById("result").innerHTML += i + ", "; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 以上方法的优点是代码少，且只需要一个文件，不存在跨文件传输数据问题，但缺点也很明显，只有当浏览器JS引擎全部处理完所有的数据之后才会通过DOM把数据添加到HTML页面上，那么当处理99999内质数的时候浏览器大概需要歇菜5秒钟，此时用户只能干瞪着浏览器无法继续操作，如果99999之后再加上一个9，那需要等待的时间还得翻几倍，这就是JS单线程处理存在的一个问题。 那么有没有可能让浏览器优先把页面展示出来，然后后台一边处理数据，一边把处理好的数据先返回回来，再通过DOM动态添加到页面上？最近学习到web Workers，它是运行在后台的 JavaScript，独立于其他脚本，不影响页面性能。用户可以继续点击、选取页面内容等，而此时 web worker 在后台继续运行，多线程并行，上代码。 第二种方法 前端完整代码如下：其中worker.js为另一个js文件，用于处理业务，之后通过postMessage接口与worker进行通信，这也是跨源通信（cross-origin messaging）的一种方式。postMessage接口除了可以向worker传递私有数据类型，还支持JSON数据结构的传递。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1~99999之间的质数有：&lt;p id="result"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var worker = new Worker("worker.js"); //new Worker()构造函数引进一个js文件 worker.onmessage = function(e) &#123; //监听message事件 document.getElementById("result").innerHTML += e.data + ", " ; &#125;&lt;/script&gt;&lt;/html&gt; worker.js文件的代码如下： 123456789for (let i = 2; i&lt;= 99999; i++) &#123; let j = 2; while (i%j != 0) &#123; j++ ; &#125; if ( j == i ) &#123; postMessage(i) ; //postMessage()方法对应前端onmessage监听事件，发送数据的接口 &#125; &#125; 那么还有一个问题，因为onmessage该监听事件是一个回调函数，存在异步问题，如果单个js文件需要处理的业务逻辑太多，需要分成多个js文件去处理，且下一个js文件的执行需要得到上一个js文件处理的结果，这时候就会想到用ES6中的promise方法，于是模拟代码如下： 123456789101112131415new Promise(function(resolve,reject) &#123; resolve(); &#125;).then(function() &#123; var worker = new Worker("worker.js"); worker.onmessage = function(e) &#123; //监听获取worker返回的数据 document.getElementById("result").innerHTML += e.data + ", " ; &#125; &#125;).then(function() &#123; var worker2 = new Worker("worker2.js"); worker2.onmessage = function(e) &#123; //监听获取worker2返回的数据 document.getElementById("result").innerHTML += e.data + ", " ; &#125; &#125;).then(null,function(err) &#123; console.log(err); &#125;) 假设两个js文件postMessage回来的数据是”aaa”和”bbb”，这时候在浏览器运行多次之后会出现2种不同的结果，原因请大家想想。不甘心的我在没有其他更好的方法的情况下又重回了“回调金字塔”，能勉强实现功能的代码如下： 12345678910var worker = new Worker("worker.js"); worker.onmessage = function(e) &#123; document.getElementById("result").innerHTML += e.data + ", " ; var worker2 = new Worker("worker2.js"); worker2.onmessage = function(e) &#123; document.getElementById("result").innerHTML += e.data + ", " ; worker2.close(); //worker属于系统层面的线程,占用资源密集。因此，在完成任务之后及时终止进程 &#125; worker.close(); &#125; 以上是我在学习这个知识点的时候的一些尝试与想法，如果你有更好的办法呢，希望指教，O(∩_∩)O。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入URL到页面加载发生了什么]]></title>
    <url>%2F2017%2F05%2F01%2F%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[最近网上看到这样一个问答题，先前从没想到过有这么深入复杂的各种逻辑，涉及到计算机网络、域名服务器、浏览器性能优化等等，今天参考网上的一些说法大概写几点简单的理解，以待闲暇之余继续逐个深入了解探讨。 1、浏览器查找域名对应的IP地址 这一步包括DNS具体的解析查找过程以及DNS的优化，包括DNS多级缓存，由近及远有：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;域名服务器缓存…，还有就是DNS负载均衡，具体知识点需要google更多。 2、浏览器向web服务器发送一个HTTP请求 服务器的永久重定向响应（从http://example.com 到 http://www.example.com），关于为什么要重定向，其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://example.com/和http://www.example.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。所以要把带www的和不带www的地址归到同一个网站排名下。 还有一个原因是用不同的地址会造成缓存友好性变差。 3、浏览器跟踪重定向地址，发起GET请求 该过程浏览器向远程服务器请求该IP地址对应存放的HTML页面。 4、服务器”处理”请求，向浏览器发回一个HTML响应 该过程服务器响应请求并返回一个静态的HTML页面给到浏览器解析。 5、浏览器解析显示HTML 浏览器解析HTML页面结构构建DOM树，同时找出需要继续向外加载的请求。 6、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 浏览器再次发送网络请求，获取页面上所需的图片、音视频、外部资源等。 7、浏览器发送异步请求（ajax请求等） 浏览器处理script标签中的JS代码，如果存在局部ajax请求则继续发送网络请求。 更详细的参考资料]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《滚蛋吧，肿瘤君》有点感]]></title>
    <url>%2F2017%2F04%2F29%2F%E3%80%8A%E6%BB%9A%E8%9B%8B%E5%90%A7%E8%82%BF%E7%98%A4%E5%90%9B%E8%A7%82%E6%84%9F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今晚忙里偷闲，看了个电影，名字叫《滚蛋吧，肿瘤君》。感触颇多，记录下此刻内心的一点想法。 生活品性虽不忠，却不影响对才华的仰慕，斯者如超级丹。 主演白百合确实演的细腻入微，几番哽咽。 故事主要分3条线索，一个是孤身港湾之外，幸之如艾米、老郑之辈的水手护帆， 时常惊喜，时而轻狂，三言两语陪你理尽光头，处理“生前生后事”的娃娃亲们。 一个是伶仃远洋憋屈无助时候一句“妈，我要回港湾”的谷底暖阳。 最后一个也是倾注更多帧数的话题， 般若艾米追逐事业无视身体加班加点优秀上进的生活， 般若熊顿率性欢颜敢梦敢为有你有我有色有味的人生。 无谓好坏，都是生活态度的一种抉择。 生活本不止于脚下的非黑即白，心往远阳的人多了，生活也就多了更多炫彩。 但笑傲江湖讲，气剑归宗葵花宝典，身体就是生活的葵花宝典。 逐事业也好，戏人生也罢，坐井底也可，游江左也堪，总归一“本”字到头。 活着，你才有所有，有所无，非命无情，一无所有，夫复何求？]]></content>
      <categories>
        <category>生活呀</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创业是一种生活态度]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%88%9B%E4%B8%9A%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%9F%E6%B4%BB%E6%80%81%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[如果你问一个二十出头的年轻人，是想要被催促着买车买房结婚生子的生活，还是谈论着梦想改变世界、让自己一辈子不白活的生活，大多数人会想要后者，却最终选择前者。这就像苹果和微软一样，大多数人都喜欢苹果，但他们都在用Windows操作系统。那些谈论的人还在谈论，而那些梦想改变世界的人，才是真的没有白活。你能想象十几年前睡在硅谷Univ Ave（大学街）165号地板上那几个20出头的小伙儿，后来分别创办了视频网站YouTube、社交网站Linkedin和点评网站Yelp么？ 创业就像走在一条长长的道路上，你看不见尽头，望不到边。有人忍受不了孤独而走上众人的通途，有人受不了困苦沿着脚印一步步退后，只有一种人可以看到豁然开朗的景色：他们从不畏孤独、险途，他们始终与梦想相伴，他们记得为什么出发，所以他们始终都能到达。 你为什么要创业？以下罗列3个参考意见： 1、创业是一种态度冯大辉（丁香园首席技术官）所理解的“创业”，是一种对待工作的态度。 不是说自己一定要单干，比如注册个公司，当个说一不二的老板，才是在创业。想明白工作是为了自己，而不是感觉在为别人打工，这就是创业。 创业，就是一个更为积极、更为明确的工作态度。“我不在创业，就在去创业的路上。”这是我刚加入阿里巴巴那段时间的签名。 罗云登（电商创业者）同样认为创业和态度有关。 如果明天是世界末日，我还会选择创业，这是一种人生态度。 小时候想创业，那是因为受到家人的影响，让人感到一种成就感；中学时候想创业，是为了能住上自己喜欢的房子，开上自己喜欢的车子，去梦想的地方旅行；高中时候开始做网店，找货源，搞宣传，明白赚钱不易。创业是为了让父母过上好的生活，能帮助到自己身边困难的亲人朋友，不仅仅是为了自己要成就什么；大学后开始尝试做不一样的事情，慢慢知道自己要干什么样的事情，并为之努力，未曾放弃，坚持至今。 随着时间的推移，创业观、世界观、互联网观逐渐成熟，明白了创业最大的乐趣是，当你知道你正在做的事情改善了许多人的生活，你慢慢意识到这是一件多么有价值的事情啊！然后继续下去，乐此不疲。其实我们兜售的不是产品，而是梦想。 2、改变自己老杨（懒汉互联网站创始人）刚刚步入创业的行列，这个问题是他不可逾越、但又总想躲避的一个问题。 好好的办公室坐着不舒服吗？ 非得花3个小时的路程只为见客户5分钟，而且一路上又是地铁、公交、步行，又不熟悉见面地点，空气也不好。这是为什么？ 每个月有稳定的收入不舒服吗？ 非得冒着付出远大于回报，甚至是没有回报还倒贴的风险去做事情。这是为什么？ 轻松的工作不舒服吗？ 非得出去苦口婆心地介绍自己及自己的产品，既充当开发者、又当美工、编辑、市场、销售，还要充当财务。这是为什么？ 朝九晚五的工作不舒服吗？ 非得比别人起得早、干得晚，周末毫无怨言地加班，没时间陪家人，没有假期。这是为什么？ …… 我不想等自己老去的时候，回想起过去却是一片空白，一点值得回忆的事情都没有。我不想后悔和叹息，自己尝试了，不管是对还是错，努力过后就无怨无悔。我只是不想虚度光阴。充实和富有挑战，才是自己骨子里最本质的东西。我不期望自己能改变别人的世界，但愿能改变自己的世界。 3、实现人生目标林培中（知乎控，无业游民）认为，要回答为什么创业，有个前提是弄清楚我们的人生目标是什么？ 这个问题，因人而异，没有标准答案。 第一种人希望自己成为一个比降临人世之初更好的人，例如稻盛和夫。这种人往往希望每天都能过得更充实，能把每一分每一秒都用在提高自己、实现自己的人生价值上。 第二种人，希望能好好地享受生活。只要自己和身边的人能够幸福快乐，就已经足够了。 这两种人，并没有优劣之分。克里斯托弗·莫利有一句话说得很好：“只有一种成功——能以你自己的生活方式度过你的一生。” 还有第三种人，他们认为人生就是一场灾难，只希望人生能早早结束。但第三种人没有明确的创业动机，可以忽略。 在了解了不同的人有不同的人生目标后，我们就可以分别讨论他们创业的目标了。 在第一种人中，选择了创业的人也可以分为两类： 一类是有着明确目标的人，第二类是没有明确目标的人（这里假设他们都能承担责任）。胜间和代说过：“我们的人生设计应该是，尽量做自己擅长的事，把赚来的钱请别人做自己不擅长的事。”然而在日常工作中，作为员工的我们往往从事着老板安排的工作，而这些有可能对我们本身价值并不大，或是我们并不愿意做的。从事这样的工作，会让我们对自己产生深深的违和感。 “这就是我想要的生活？”“我这么辛苦到底为了什么？”（正在从事自己感兴趣的工作或是只想得过且过的人除外。）每个人都希望从事自己喜欢的职业，每天做自己想做的事，然而现实是，并非每个人都能如愿以偿。 于是，在第一种人中，第一类人不甘这样下去，有着自己明确的目标，而且有勇气去承担责任的人，选择了创业。对于他们而言，创业是为了充分利用时间，提高自我，实现自己的价值。而第二类人则只是认为与其为别人工作，不如为自己工作。他们创业的目的只是渴望随心所欲的自由，或是认为只有为自己工作，才能实现人生价值。他们只是单纯地在逃避生活。 第二种人创业的目的很简单。创业就是他们享受生活的方式。就像有人会选择骑着自行车环游世界，而有人则会选择坐飞机环游世界一样，是创业还是为他人工作，只是个人享受生活的方式不同罢了。 最后，请让我引用最近微博上很流行的一句话为这个回答终结。 一个不成熟男人的标志是他愿意为某种事业英勇地死去，一个成熟男人的标志是他愿意为某种事业卑贱地活着。——《麦田守望者》 本文内容是我在读《创业时，我们在知乎聊什么》P6~12的文摘，我手中在读是第116899本，欢迎借阅分享。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express + Formidable 实现拖拽文件上传服务器]]></title>
    <url>%2F2017%2F04%2F23%2FExpress%20%2B%20Formidable%20%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%8B%96%E6%8B%BD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[功能需求：以往通过设置“input”标签的type类型为“file”可进行文件选择上传，但该方法效率较低，用户交互体验不是很好，因此通过H5新增的拖放API进行多个文件选择上传，并能在服务端保存成功。 前端页面简单代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;style media="screen"&gt; #target &#123; border: medium double black; width: 200px; height: 80px; text-align: center; line-height: 75px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="target"&gt;Drop files here&lt;/div&gt; &lt;div id="data"&gt;&lt;/div&gt; &lt;br&gt; &lt;input type="submit" value="提交" onclick="handleCLK()"&gt;&lt;/body&gt;&lt;/html&gt; 前端通过Ajax发送上传数据请求，关键代码如下： 其中关键点在于通过FormData对象包装得到一个“文件对象”，从而满足Ajax数据发送要求。 12345678910111213141516171819202122232425262728293031323334353637&lt;script type="text/javascript" src="jquery-1.12.4.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var target = document.getElementById("target");target.ondragenter = handleDrag;target.ondragover = handleDrag;function handleDrag(e) &#123; e.preventDefault();&#125;var fd = new FormData(); //实例化一个FormData对象target.ondrop = function (e) &#123; var files = e.dataTransfer.files; //存储上传的所有文件 var divP = document.getElementById("data"); for (var i = 0; i &lt; files.length; i++) &#123; divP.innerHTML += "文件名：" + files[i].name + "文件大小：" + files[i].size + "&lt;br&gt;"; fd.append("file" + i, files[i]); //将上传的文件丢给FormData实例对象，才能传输给后端，否则需要使用form表单形式提交 &#125; e.preventDefault();&#125;function handleCLK() &#123; $.ajax(&#123; type: "POST", url: "/upload", data: fd, //该对象即为上面FormData实例化之后append到的数据文件 processData: false, //此两行必须添加，否则会与jQuery库冲突报错 contentType: false, //此两行必须添加，否则会与jQuery库冲突报错 success: function (data) &#123; if (data == "1") &#123; console.log("success..."); &#125; else &#123; console.log("something wrong..."); &#125; &#125; &#125;)&#125;&lt;/script&gt; 后端处理响应并返回响应值给前端请求，关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637var express = require("express") //引入Express模块var app = express()var formidable = require('formidable') //引入formidable模块var fs = require("fs")app.post("/upload", function (req, res) &#123;var form = new formidable.IncomingForm();form.parse(req, function (err, fields, files) &#123; for (let i in files) &#123; //此处必须使用let定义i，否则会出现异步问题，具体可参考setTimeout(function()&#123;&#125;,0)的含义 var n = 0; var stream = fs.createReadStream(files[i].path); //创建一个读数据流 stream.on("data", function (chunk) &#123; fs.writeFile(require("path").join(__dirname, files[i].name), chunk, &#123;flag: "a"&#125;, function (err) &#123; //将上传的内容从磁盘读取并写入当前文件夹 if (err) &#123; console.log(err); res.end("0"); &#125; &#125;) &#125;) stream.on("end", function () &#123; n++; if (n == Object.keys(files).length) &#123; //获取对象属性数量生成一个数组，通过数组length得知对象属性个数 console.log("end"); res.end("1"); //当同时上传多个文件时需要对n进行判断，只有当全部上传完成之后才返回响应值 &#125; &#125;) &#125;&#125;);&#125;)app.use(express.static(require("path").join(__dirname, "."))); //暴露文件app.listen(8080, function () &#123;console.log("started..");&#125;) 其中关键点在于”formidable”模块实例一个对象之后对数据流的写入保存，而且需要考虑如果同时上传多个文件使用for…in的遍历方法时，需要考虑let块级作用域结合回调函数异步处理的相互影响。另外如何获取一个对象的属性数量？ 以上代码只是作为演示，具体项目中还有很多可以优化，比如如果用户拖拽文件之后，又重新拖拽几个文件，点击上传，这样在前端代码块中的files会出现问题。另外formidable模块会将数据直接写入磁盘，而且不会擦除，时间久了会很占用空间，关于后端接收数据是否有更优解，比如express中间件multer?等等 …]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习过程中积累的笔记]]></title>
    <url>%2F2017%2F04%2F21%2FJavascript%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A7%AF%E7%B4%AF%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近整理先前作为初学者积累的Javascript学习笔记，回过头来看还是觉得基础很重要啊，虽然随着积累的知识越多，经验越丰富，但基本的知识点万变不离宗，还是要回过头时常翻看下，想起了当年我高考的语文作文：“回到原点”，多恰当哈哈 … 解释型语言：可直接在浏览器或者操作系统执行的文件编译型语言：源代码通过编译器编译生成二进制可执行文件（特点：运行速度快，执行效率高） 局部变量只能在本变量声明的函数内部调用，跳出该函数体之后即无法调用。全局变量在整个代码中都可以进行调用。栗子： 123456789var i = "bling"; //通过var定义了全局之后在控制台中输出i跟输出window.i效果一样function myName() &#123; var i = "Bryn"; // 注意此处通过var定义变量之后，i变为局部变量，如果把var关键字去掉,则变成了给i重新赋值，i还是挂载在window下的全局变量，返回输出的结果即为“Bryn"&#125; myName(); function myLikes() &#123; alert(i);&#125;myLikes(); //返回结果为"bling" 在for语句或者switch选择语句中有以下2个关键语句：continue:执行该语句后即停止当前循环，进入下一次循环；break:执行该语句后立马跳出循环体，不再执行后面动作。 A+=10等效于A=A+10A-=10等效于A=A-10同理还有A=10；A/=10*栗子： 12345var a=10, b=20 , c=30;++a; //立马执行，a即为11a++; //再次调用时执行，此时a还是11e=++a+(++b)+(c++)+a++; //e = 13 + 21 + 30 + 13alert(e); //弹出提示对话框：77 形参即形式，实参即内容，形参只充当占位符，实参决定形参真正的值。函数内的局部变量优先级高于全局变量。 全等运算符（===）：只有当数值大小与数值类型一样才能返回true。&amp;&amp;表示与逻辑运算符，只有当多个参数同时满足条件才执行；||表示或逻辑运算符，只要有任一参数满足条件即执行； JavaScript Object Notation 简称 JSON，它使用JavaScript对象的格式来存储数据。JSON是灵活的，因为它允许数据结构是字符串，数字，布尔值，字符串，和对象的任意组合。 12345678Math.random(); //生成一个[0,1)之间的随机数Math.round(); //把一个数字四舍五入为最接近的整数,算法为Math.floor(x+0.5)，将原来的数字加上0.5后再向下取整，所以Math.round(11.5)结果为12，Math.round(-11.5)结果为-11Math.floor(); //向下取整，如floor(8.9)=8Math.ceil(); //向上取整,如ceil(8.1)=9parseInt(); //字符串取整，如parseInt("15.49")=15,parseInt(1.5)=1Math.max.apply(null,arr); //取任意长度数组中的最大值Math.min.apply(null.arr); //取任意长度数组中的最小值 正则表达式支持的通配符：. 通配任何字符中的一个字符；\d 通配数字中的一个字符,[0,9]；\D 不是数字的字符；\s 空白字符（空白字符有5个，空格” “、换行\n、回车\r、制表符\t、换页符\f）；\S 非空白字符；\w 通配所有的单词字符，包括数字、大小写字母、下划线（63个字符）；\W 通配非单词字符；[a-z]、[A-Z]、[0-9]、[A-Za-z]（包含大小写英文字符）、[a-z0-9]；栗子： [afg]==(a|f|g)；[a\-fg]==(a|-|f|g) ;^ 以什么开始；$ 以什么结束；？ 出现0次或者1次（用于修饰前面的通配字符，不可单独使用，下面同理）；* 出现0次或者多次，即可匹配任意长度 ;+ 出现1次或者多次；{m,n} 出现m到n次；\b 不会消耗任何字符只匹配一个位置，常用于匹配单词边界；栗子：从字符串中”This is Regex”匹配单独的单词 “is” 正则表达式为：\bis\b；\b 不匹配”is”两边的字符，只识别两边是否为单词的边界；栗子：/^[a-z].$/ 表示以小写字母开头的任意2个字符,如a7；p8/^[a-z].？$/ aaa错误/^[a-z].*$/ aaa正确/^[a-z].+$/ aaa正确/^[a-z].{1,3}$/ aaaa正确/^[a-z].{3}$/ 只有aaaa正确 /\d/ 只匹配包含一个数字的字符，如2，5；/\d+/ +用于修饰d，所以匹配到包含一个或者多个的数字组合，如50,123；/\d/g 匹配全局包含一个数字的字符，如25匹配得到[“2”,”5”]；/\d+/g 如25,123匹配得到[“25”,”123”]；/\d+/gi 不分大小写匹配；([ab]+)\1：\1是对前面括号内容的引用次数，因此该匹配只会匹配多个重复a或重复b； 以下这些正则表达式中”^”表示字符类的否定：[^a]表示“匹配除了a的任意字符”;[^a-zA-Z0-9]表示”找到一个非字母也非数字的字符”;[\^abc]表示”找到一个插入符^或者a或者b或者c”;[^\^]表示”找到除了插入符^外的任意字符”;经过对比，发现只要是”^”这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头，也就是说”[]”代表的是一个字符集，”^”只有在字符集中才是反向字符集的意思。 字符串与数组一些常用的内置函数：1234567891011121314151617181920212223242526var regExp=new RegExp() //创建正则表达式；new RegExp().test(string) //测试字符串是否包含表达式，返回值为true or false；string.replace(new RegExp(),and) //用and把字符串中的所有.替换成and；string.match(new RegExp()) //输出匹配到的数组结果，最长匹配原则；string.search(new RegExp()) //输出匹配到的值的首个索引号；var myArr=new Array() //数组创建的其他方式 ;Arr.push() //往最后一个元素后添加数组元素，返回数组长度，更改原数组；Arr.pop() //移除数组最后一个元素,并返回该元素的值,更改原数组的长度；Arr.shift() //移除数组第一个元素，并返回该元素的值,更改原数组的长度；Arr.unshift() //添加元素作为数组的第一个元素，返回值为数组长度；//以上4个方法作用效果相反，push(),pop(),shift(),unshift();string.split(//) //split后面可以加正则表达式按最长匹配原则进行分割；string.slice() //截断字符串，左边括号部分包括，右边括号部分不包括，不改变原数组；string.substr() //返回字符串中从指定位置开始到指定长度的子字符串；string.charCodeAt() //字符串转ASCII码；String.fromCharCode() //ASCII码转字符串；array.reverse() //就地反转数组顺序，改变原数组；array.join() //数组连成字符串；array.toString() //数组转换为字符串；array.slice() //截断数组，左边括号部分包括，右边括号部分不包括；array.slice(n,array.length) //返回一个数组被截断n个元素之后还剩余的元素；array.map(function()&#123;&#125;) //mapmap函数对每一个数组元素进行计算，如+3，-50，*4a等；array.reduce(function()&#123;&#125;,0) //reduce函数对数组内部元素间进行操作，如前后相加相减等；array.filter(function()&#123;&#125;) //filter过滤函数，不改变原数组；array.sort(function(a,b)&#123;return a-b;&#125;) //sort实现重新排序数组大小，升降序通过reverse()改变；array.splice() //增加或减少数组内元素，返回值为被删除元素组成的数组，该函数改变原数组； 不会改变原数组的函数操作有： filter();concat();map();slice();replace();改变原数组的函数操作有： push();shift();unshift();splice();reverse();sort();]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo +Markdown 搭建个人博客关键步骤]]></title>
    <url>%2F2017%2F04%2F15%2FGitHub%20%2B%20Hexo%20%2BMarkdown%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[前人摘树，后人乘凉。小的我喝了茶乘了凉，总不能一下就人走茶凉吧，因此也记录下自己在搭建本blog过程中认为比较重要的几点，如果能助人一二，那敢情甚好，不若自己遗忘时回望回望也是极好的，O(∩_∩)O …环境要求：本文基于win7编写，电脑上需安装node.js及git. 一、创建gitHub特定托管仓库登录个人gitHub账号（没有注册的请自行百度注册），点击右上角+图标，选中“New repository”新建一个仓库. 建仓填写仓库相关信息，如图所示，仓库“Repository name”的命名必须遵循如下规则：“Owner”中的用户名+.github.io，该地址具有唯一性. 图中因为我已经创建过该用户名仓库，所以限制不允许重复创建. 其中仓库描述为选填，仓库默认为“Public”公共仓库，“Private”私人仓库需要付费购买，这里用公共仓库进行演示。初始化仓库也可选可不选，这里不选，后面直接git push自己需要的文件上去，点击“Create Repository”完成创建. 完成创建后，返回该仓库，进入“Settings”中，找到GitHub Pages 可见到“binglinzhang.github.io”显示已经发布，此时即可通过访该地址进行访问. 访问该地址默认会查找仓库根目录下的index.html文件，由于现在我们的仓库为空，需要在本地建仓并push文件到自己的GitHub上，具体的git操作功能不详细说明（常用的git clone，git add –all，git commit -m “…”，git push，git status必须会啊），不明白的可以参考廖雪峰大神的git教程，此处push一个index.html文件到自己的远程仓库上，通过访问自己的仓库即可看到刚刚上传的index.html页面的内容. 图片地址栏中显示的是域名，具体设置参考以下. 想要绑定自己的域名，则需对自己已注册过的域名进行解析(没有注册的可以通过万网注册，需要RMB)，我使用的是阿里云的万网域名解析，按图示进行设置，其中192.30.252.153和192.30.252.154为github提供的两个服务器IP地址，CNAME记录值为上面我们创建的github博客地址. 设置完成之后放回上面提到的“Settings”，在Custom domain下填入自己的域名，保存即可. 二、Hexo的安装与配置下载安装hexo，打开cmd命令行，输入： npm install -g hexo-cli 该安装为全局安装，完成之后在桌面创建一个文件夹，随意命名为”myBlog”, 在命令行中cd到该文件夹中，输入： hexo init 通过以上命令，Hexo帮我们初始化了一个博客项目，内容包括如下： 如果没有.deploy_git文件夹，则需cd到myBlog文件夹下输入： npm install hexo-deployer-git --save 以上文件中_config.yml为主要的配置文件，我们主要修改的内容为以下几项： · 修改网站相关信息123456title: yourblogsubtitle: your subtitledescription: your describeauthor: XXXlanguage: zh-CNtimezone: Asia/Shanghai 注意： 每一项的填写，其:后面都必须保留一个空格，下同。 · 配置个人域名url: http://zhangbinglin.cn · 配置部署1234deploy:type: gitrepo: https://github.com/binglinzhang/binglinzhang.github.io.gitbranch: master 其中repo项为上面创建的Github仓库地址，通过如下图方式copy，注意不要漏掉最后的.git. 此时，在cmd命令行中输入hexo server即可启动本地服务器，默认端口号是4000，因此在游览器中输入http://localhost:4000/ 即可进行访问. 如果希望别人也能访问到我们的文件，此时则需要将本地的文件push到GitHub上，具体指令如下： hexo generate hexo deploy 此时即可通过binglinzhang.github.io或者我们解析后的域名zhangbinglin.cn进行访问. 具体的主题、模板、插件等可访问官网进行优化设置：Hexo文档 三、Markdown书写Markdown是一门简便轻量级的高效率的标记语言，有自己的语法，不多也不难，网上看几个例子即能领会，这里不细讲，推荐一款MarkdownPad2软件，可实现基本的日常写作，看图，百度云盘传送门：密码：fg0v 以上内容只是写了关键的几个步骤，最关键的是要有清晰的思路，比如GitHub在这里起到什么作用，Hexo是怎么跟GitHub结合的，为什么要用Markdown，Markdown如何更高效的插入大量图片，在线存储自己的图片有哪些途径，GitHub仓库地址解析为自己的域名后如何通过自己的域名让别人访问到更多资源等等.]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>